{"version":3,"sources":["webpack://lexurgy/webpack/universalModuleDefinition","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/BufferedTokenStream.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/CharStreams.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/CommonTokenFactory.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/CommonTokenStream.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/FileStream.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/InputStream.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/IntervalSet.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/LL1Analyzer.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/Lexer.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/Parser.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/ParserRuleContext.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/PredictionContext.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/Recognizer.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/RuleContext.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/Token.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/Utils.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATN.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNConfig.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNConfigSet.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNDeserializationOptions.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNDeserializer.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNSimulator.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNState.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ATNType.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/LexerATNSimulator.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/LexerAction.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/LexerActionExecutor.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/ParserATNSimulator.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/PredictionMode.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/SemanticContext.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/Transition.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/atn/index.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/dfa/DFA.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/dfa/DFASerializer.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/dfa/DFAState.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/dfa/index.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/error/DiagnosticErrorListener.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/error/ErrorListener.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/error/ErrorStrategy.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/error/Errors.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/error/index.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/index.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/polyfills/codepointat.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/polyfills/fromcodepoint.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/tree/Tree.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/tree/Trees.js","webpack://lexurgy/../node_modules/source-map-loader/dist/node_modules/antlr4/tree/index.js","webpack://lexurgy/./kotlin-dce/LscLexer.js","webpack://lexurgy/./kotlin-dce/LscParser.js","webpack://lexurgy/./kotlin-dce/LscVisitor.js","webpack://lexurgy/./kotlin-dce/wrapper.js","webpack://lexurgy/./kotlin-dce/arrayUtils.js","webpack://lexurgy/./kotlin-dce/callableReferenceUtils.js","webpack://lexurgy/./kotlin-dce/conversions.js","webpack://lexurgy/./kotlin-dce/core.js","webpack://lexurgy/./kotlin-dce/misc.js","webpack://lexurgy/./kotlin-dce/polyfills.js","webpack://lexurgy/./kotlin-dce/markerFunctions.js","webpack://lexurgy/./kotlin-dce/rtti.js","webpack://lexurgy/./kotlin-dce/long.js","webpack://lexurgy/./kotlin-dce/runtime/Enum.kt","webpack://lexurgy/./kotlin-dce/runtime/arrayUtils.kt","webpack://lexurgy/./kotlin-dce/primitiveCompanionObjects.kt","webpack://lexurgy/./kotlin-dce/generated/_Arrays.kt","webpack://lexurgy/./kotlin-dce/generated/_Ranges.kt","webpack://lexurgy/./kotlin-dce/kotlin/UByte.kt","webpack://lexurgy/./kotlin-dce/kotlin/UInt.kt","webpack://lexurgy/./kotlin-dce/kotlin/UShort.kt","webpack://lexurgy/./kotlin-dce/Ranges.kt","webpack://lexurgy/./kotlin-dce/collections/Collections.kt","webpack://lexurgy/./kotlin-dce/collections/Maps.kt","webpack://lexurgy/./kotlin-dce/collections/Sets.kt","webpack://lexurgy/./kotlin-dce/collections/Sequences.kt","webpack://lexurgy/./kotlin-dce/generated/_Collections.kt","webpack://lexurgy/./kotlin-dce/util/Preconditions.kt","webpack://lexurgy/./kotlin-dce/collections/Iterables.kt","webpack://lexurgy/./kotlin-dce/generated/_Sequences.kt","webpack://lexurgy/./kotlin-dce/generated/_Strings.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/string.kt","webpack://lexurgy/./kotlin-dce/Iterators.kt","webpack://lexurgy/./kotlin-dce/ProgressionIterators.kt","webpack://lexurgy/./kotlin-dce/CharCode.kt","webpack://lexurgy/./kotlin-dce/Progressions.kt","webpack://lexurgy/./kotlin-dce/text/StringNumberConversions.kt","webpack://lexurgy/./kotlin-dce/time/Duration.kt","webpack://lexurgy/./kotlin-dce/kotlin/UnsignedUtils.kt","webpack://lexurgy/./kotlin-dce/Collections.kt","webpack://lexurgy/./kotlin-dce/Range.kt","webpack://lexurgy/./kotlin-dce/Unit.kt","webpack://lexurgy/./kotlin-dce/internal/progressionUtil.kt","webpack://lexurgy/./kotlin-dce/kotlin/builtins.kt","webpack://lexurgy/./kotlin-dce/kotlin/coroutines/CoroutineImpl.kt","webpack://lexurgy/./kotlin-dce/util/Standard.kt","webpack://lexurgy/./kotlin-dce/util/Result.kt","webpack://lexurgy/./kotlin-dce/coroutines/Continuation.kt","webpack://lexurgy/./kotlin-dce/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://lexurgy/./kotlin-dce/kotlin/exceptions.kt","webpack://lexurgy/./kotlin-dce/kotlin/kotlin.kt","webpack://lexurgy/./kotlin-dce/generated/_ArraysJs.kt","webpack://lexurgy/./kotlin-dce/generated/_CollectionsJs.kt","webpack://lexurgy/./kotlin-dce/generated/_WhitespaceChars.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/AbstractMutableCollection.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/AbstractMutableList.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/AbstractMutableMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/AbstractMutableSet.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/ArrayList.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/ArraySorting.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/EqualityComparator.kt","webpack://lexurgy/./kotlin-dce/kotlin/Comparator.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/HashMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/HashSet.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/InternalHashCodeMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/InternalStringMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/LinkedHashMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/LinkedHashSet.kt","webpack://lexurgy/./kotlin-dce/kotlin/console.kt","webpack://lexurgy/./kotlin-dce/kotlin/coroutines/SafeContinuationJs.kt","webpack://lexurgy/./kotlin-dce/kotlin/exceptionUtils.kt","webpack://lexurgy/./kotlin-dce/kotlin/reflect/KClassImpl.kt","webpack://lexurgy/./kotlin-dce/kotlin/collections/InternalMap.kt","webpack://lexurgy/./kotlin-dce/kotlin/jsOperators.kt","webpack://lexurgy/./kotlin-dce/kotlin/reflect/primitives.kt","webpack://lexurgy/./kotlin-dce/kotlin/reflect/reflection.kt","webpack://lexurgy/./kotlin-dce/kotlin/regexp.kt","webpack://lexurgy/./kotlin-dce/kotlin/sequence.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/StringBuilderJs.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/char.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/numberConversions.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/regex.kt","webpack://lexurgy/./kotlin-dce/text/Strings.kt","webpack://lexurgy/./kotlin-dce/generated/_ComparisonsJs.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/stringsCode.kt","webpack://lexurgy/./kotlin-dce/collections/AbstractCollection.kt","webpack://lexurgy/./kotlin-dce/collections/AbstractIterator.kt","webpack://lexurgy/./kotlin-dce/collections/AbstractList.kt","webpack://lexurgy/./kotlin-dce/collections/AbstractMap.kt","webpack://lexurgy/./kotlin-dce/collections/AbstractSet.kt","webpack://lexurgy/./kotlin-dce/collections/IndexedValue.kt","webpack://lexurgy/./kotlin-dce/collections/Iterators.kt","webpack://lexurgy/./kotlin-dce/collections/MapWithDefault.kt","webpack://lexurgy/./kotlin-dce/collections/MutableCollections.kt","webpack://lexurgy/./kotlin-dce/collections/ReversedViews.kt","webpack://lexurgy/./kotlin-dce/collections/SequenceBuilder.kt","webpack://lexurgy/./kotlin-dce/collections/SlidingWindow.kt","webpack://lexurgy/./kotlin-dce/comparisons/Comparisons.kt","webpack://lexurgy/./kotlin-dce/coroutines/ContinuationInterceptor.kt","webpack://lexurgy/./kotlin-dce/coroutines/CoroutineContext.kt","webpack://lexurgy/./kotlin-dce/coroutines/CoroutineContextImpl.kt","webpack://lexurgy/./kotlin-dce/coroutines/intrinsics/Intrinsics.kt","webpack://lexurgy/./kotlin-dce/ranges/Ranges.kt","webpack://lexurgy/./kotlin-dce/text/Appendable.kt","webpack://lexurgy/./kotlin-dce/text/Char.kt","webpack://lexurgy/./kotlin-dce/text/regex/MatchResult.kt","webpack://lexurgy/./kotlin-dce/util/Lazy.kt","webpack://lexurgy/./kotlin-dce/util/Tuples.kt","webpack://lexurgy/./kotlin-dce/reflect/KClasses.kt","webpack://lexurgy/./kotlin-dce/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://lexurgy/./kotlin-dce/kotlin/math.kt","webpack://lexurgy/./kotlin-dce/kotlin/random/PlatformRandom.kt","webpack://lexurgy/./kotlin-dce/kotlin/text/utf8Encoding.kt","webpack://lexurgy/./kotlin-dce/util/DeepRecursive.kt","webpack://lexurgy/./kotlin/generated/_Collections.kt","webpack://lexurgy/./kotlin/collections/Maps.kt","webpack://lexurgy/./kotlin/collections/Sets.kt","webpack://lexurgy/./kotlin/comparisons/Comparisons.kt","webpack://lexurgy/./kotlin/text/Strings.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/AntlrUtils.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/Errors.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Declarations.kt","webpack://lexurgy/./kotlin/util/Standard.kt","webpack://lexurgy/./kotlin/collections/MutableCollections.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Emitters.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Matchers.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Matrices.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Parser.kt","webpack://lexurgy/./kotlin/collections/Collections.kt","webpack://lexurgy/./kotlin/generated/_ComparisonsJs.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/RepeaterType.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/SoundChanger.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Syllabifier.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Transformers.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/sc/Variables.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/SegmentTree.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/Utils.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/lexurgy/Words.kt","webpack://lexurgy/./kotlin/generated/_Maps.kt","webpack://lexurgy/./kotlin/generated/_Strings.kt","webpack://lexurgy/../src/commonMain/kotlin/com/meamoria/mpp/antlr/AntlrRuntime.kt","webpack://lexurgy/../src/jsMain/kotlin/com/meamoria/lexurgy/MainJs.kt","webpack://lexurgy/../src/jsMain/kotlin/com/meamoria/lexurgy/sc/AntlrLsc.kt","webpack://lexurgy/../src/jsMain/kotlin/com/meamoria/lexurgy/sc/SoundChanger.kt","webpack://lexurgy/../src/jsMain/kotlin/com/meamoria/lexurgy/Utils.kt","webpack://lexurgy/../src/jsMain/kotlin/com/meamoria/mpp/antlr/AntlrRuntimeAdapters.kt","webpack://lexurgy/webpack/bootstrap","webpack://lexurgy/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","Token","Lexer","Interval","TokenStream","BufferedTokenStream","tokenSource","call","tokens","index","fetchedEOF","prototype","Object","create","constructor","mark","release","marker","reset","seek","lazyInit","adjustSeekIndex","get","consume","length","LA","EOF","sync","i","n","fetch","t","nextToken","tokenIndex","push","type","getTokens","start","stop","types","undefined","subset","contains","LT","LB","k","setup","setTokenSource","nextTokenOnChannel","channel","token","previousTokenOnChannel","getHiddenTokensToRight","nextOnChannel","DEFAULT_TOKEN_CHANNEL","from_","to","filterForChannel","getHiddenTokensToLeft","prevOnChannel","left","right","hidden","getSourceName","getText","interval","fill","s","text","B","InputStream","fs","window","importScripts","CharStreams","fromString","str","fromBlob","blob","encoding","onLoad","onError","reader","FileReader","onload","e","is","target","result","onerror","readAsText","fromBuffer","buffer","toString","fromPath","path","callback","readFile","err","data","fromPathSync","readFileSync","CommonToken","TokenFactory","CommonTokenFactory","copyText","DEFAULT","source","line","column","createThin","CommonTokenStream","lexer","DEFAULT_CHANNEL","getNumberOfOnChannelTokens","FileStream","fileName","decodeToUnicodeCodePoints","name","strdata","stream","_index","codePoint","codePointAt","codeUnit","charCodeAt","_size","_loadString","defineProperty","offset","pos","Math","min","String","fromCodePoint","slice","IntervalSet","intervals","readOnly","item","first","v","INVALID_TYPE","addOne","addInterval","addRange","l","h","splice","max","reduce","addSet","other","intervalslength","r","pop","complement","removeRange","len","map","removeOne","x","literalNames","symbolicNames","elemsAreChar","toTokenString","toCharString","toIndexString","names","fromCharCode","join","j","elementName","a","EPSILON","Set","BitSet","ATNConfig","RuleStopState","RuleTransition","NotSetTransition","WildcardTransition","AbstractPredicateTransition","pc","predictionContextFromRuleContext","PredictionContext","SingletonPredictionContext","LL1Analyzer","atn","HIT_PRED","getDecisionLookahead","count","transitions","look","alt","lookBusy","_LOOK","transition","EMPTY","LOOK","stopState","ctx","lookContext","calledRuleStack","seeThruPreds","addEOF","c","state","context","add","isEmpty","returnState","states","getReturnState","removed","ruleIndex","remove","getParent","newContext","followState","stateNumber","isEpsilon","MIN_USER_TOKEN_TYPE","maxTokenType","set","label","Recognizer","RecognitionException","LexerNoViableAltException","input","_input","_factory","_tokenFactorySourcePair","_interp","_token","_tokenStartCharIndex","_tokenStartLine","_tokenStartColumn","_hitEOF","_channel","_type","_modeStack","_mode","DEFAULT_MODE","_text","MORE","SKIP","HIDDEN","HIDDEN_CHANNEL","MIN_CHAR_VALUE","MAX_CHAR_VALUE","tokenStartMarker","emitEOF","continueOuter","ttype","match","console","log","stack","notifyListeners","recover","emit","skip","more","mode","m","pushMode","debug","popMode","sourceName","emitToken","getCharIndex","cpos","lpos","eof","getAllTokens","msg","getErrorDisplay","getErrorListenerDispatch","syntaxError","d","getErrorDisplayForChar","getCharErrorDisplay","re","ParseTreeListener","DefaultErrorStrategy","ATNDeserializer","ATNDeserializationOptions","TerminalNode","ErrorNode","TraceListener","parser","Parser","_errHandler","_precedenceStack","_ctx","buildParseTrees","_tracer","_parseListeners","_syntaxErrors","setInputStream","enterEveryRule","ruleNames","visitTerminal","node","symbol","exitEveryRule","contructor","bypassAltsAtnCache","setTrace","getCurrentToken","reportMatch","recoverInline","addErrorNode","matchWildcard","_buildParseTrees","getParseListeners","addParseListener","listener","removeParseListener","idx","indexOf","removeParseListeners","triggerEnterRuleEvent","enterRule","triggerExitRuleEvent","reverse","exitRule","getTokenFactory","setTokenFactory","getATNWithBypassAlts","serializedAtn","getSerializedATN","deserializationOptions","generateRuleBypassTransitions","deserialize","compileParseTreePattern","pattern","patternRuleIndex","getTokenStream","ParseTreePatternMatcher","compile","getInputStream","setTokenStream","notifyErrorListeners","offendingToken","o","hasListener","inErrorRecoveryMode","addTokenNode","invokingState","isErrorNode","visitErrorNode","addContextToParseTree","parentCtx","addChild","localctx","enterOuterAlt","altNum","setAltNumber","removeLastChild","getPrecedence","enterRecursionRule","precedence","pushNewRecursionContext","previous","unrollRecursionContexts","retCtx","getInvokingContext","precpred","inContext","isExpectedToken","following","nextTokens","rt","getExpectedTokens","getExpectedTokensWithinCurrentRule","getRuleIndex","ruleName","getRuleIndexMap","getRuleInvocationStack","p","getDFAStrings","decisionToDFA","dumpDFA","seenOne","dfa","printer","println","decision","print","trace","RuleContext","Tree","INVALID_INTERVAL","TerminalNodeImpl","ErrorNodeImpl","ParserRuleContext","parent","invokingStateNumber","children","exception","InterpreterRuleContext","copyFrom","child","badToken","getChild","getToken","getTypedRuleContext","ctxType","getTypedRuleContexts","contexts","getChildCount","getSourceInterval","Hash","cachedHashCode","PredictionContextCache","cache","hashCode","hash","update","finish","EmptyPredictionContext","EMPTY_RETURN_STATE","ArrayPredictionContext","parents","returnStates","globalNodeCount","id","hasEmptyPath","updateHashCode","existing","equals","up","merge","b","rootIsWildcard","mergeCache","rootMerge","payloads","mergeRoot","spc","singleParent","apc","a_","mergeSingletons","mergedReturnStates","mergedParents","a_parent","b_parent","payload","mergedParent","M","uniqueParents","q","combineCommonParents","mergeArrays","outerContext","getCachedPredictionContext","contextCache","visited","changed","updated","ConsoleErrorListener","ProxyErrorListener","_listeners","INSTANCE","_stateNumber","tokenTypeMapCache","ruleIndexMapCache","checkVersion","toolVersion","addErrorListener","removeErrorListeners","getTokenTypeMap","tokenNames","getTokenNames","getTokenType","tokenName","getErrorHeader","getOffendingToken","getTokenErrorDisplay","replace","sempred","actionIndex","RuleNode","INVALID_ALT_NUMBER","depth","getRuleContext","getPayload","getAltNumber","altNumber","accept","visitor","visitChildren","Trees","toStringTree","recog","ri","EMPTY_SOURCE","getTokenSource","clone","size","txt","arrayToString","standardEqualsFunction","standardHashCodeFunction","hashFunction","equalsFunction","Map","AltDict","DoubleDict","seed","round","random","pow","remainder","bytes","h1","h1b","c1","c2","k1","key","value","values","concat","or","bits","keys","minValue","apply","hashKey","put","entries","entry","oldValue","containsKey","getKeys","getValues","arguments","Array","isArray","hashStuff","escapeWhitespace","escapeSpaces","titleCase","charAt","toUpperCase","substr","equalArrays","ATN","grammarType","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","ruleToTokenType","lexerActions","modeToStartState","nextTokensInContext","nextTokensNoContext","nextTokenWithinRule","addState","removeState","defineDecisionState","getDecisionState","expected","DecisionState","SemanticContext","checkParams","params","isCfg","semanticContext","reachesIntoOuterContext","props","precedenceFilterSuppressed","config","checkContext","NONE","LexerATNConfig","lexerActionExecutor","passedThroughNonGreedyDecision","checkNonGreedyDecision","hashCodeForConfigSet","equalsForConfigSet","nonGreedy","Utils","hashATNConfig","equalATNConfigs","ATNConfigSet","fullCtx","configLookup","configs","uniqueAlt","conflictingAlts","hasSemanticContext","dipsIntoOuterContext","OrderedATNConfigSet","merged","getStates","getPredicates","preds","optimizeConfigs","interpreter","getCachedContext","addAll","coll","containsFast","clear","setReadonly","verifyATN","defaultOptions","ATNType","ATNStates","ATNState","BasicState","BlockStartState","BlockEndState","LoopEndState","RuleStartState","TokensStartState","PlusLoopbackState","StarLoopbackState","StarLoopEntryState","PlusBlockStartState","StarBlockStartState","BasicBlockStartState","Transitions","Transition","AtomTransition","SetTransition","RangeTransition","ActionTransition","EpsilonTransition","PredicateTransition","PrecedencePredicateTransition","LexerActions","LexerActionType","LexerSkipAction","LexerChannelAction","LexerCustomAction","LexerMoreAction","LexerTypeAction","LexerPushModeAction","LexerPopModeAction","LexerModeAction","ADDED_UNICODE_SMP","SUPPORTED_UUIDS","initArray","tmp","options","stateFactories","actionFactories","isFeatureSupported","feature","actualUuid","idx1","checkUUID","readATN","readStates","readRules","readModes","sets","readSets","readInt","bind","uuid","readInt32","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","PARSER","temp","split","version","readUUID","pair","loopBackStateNumbers","endStateNumbers","nstates","stype","stateFactory","LOOP_END","loopBackStateNumber","endStateNumber","loopBackState","endState","numNonGreedyStates","numPrecedenceStates","isPrecedenceRule","nrules","LEXER","startState","tokenType","nmodes","readUnicode","iset","i1","i2","trans","nedges","src","trg","arg1","arg2","arg3","edgeFactory","addTransition","outermostPrecedenceReturn","ndecisions","decState","actionType","data1","data2","lexerAction","lexerActionFactory","generateRuleBypassTransition","bypassStart","bypassStop","excludeTransition","stateIsEndStateFor","matchState","maybeLoopEndState","epsilonOnlyTransitions","isPrecedenceDecision","checkCondition","condition","message","readLong","byteToHex","bth","createByteToHex","bb","int","RANGE","RULE","PREDICATE","PRECEDENCE","ATOM","ACTION","SET","NOT_SET","WILDCARD","sf","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","af","CHANNEL","CUSTOM","MODE","POP_MODE","PUSH_MODE","TYPE","DFAState","ATNSimulator","sharedContextCache","ERROR","INVALID_STATE_NUMBER","stateType","serializationNames","isNonGreedyExitState","LexerActionExecutor","resetSimState","sim","dfaState","SimState","LexerATNSimulator","startIndex","prevAccept","dfa_debug","MIN_DFA_EDGE","MAX_DFA_EDGE","match_calls","copyState","simulator","s0","matchATN","execATN","old_mode","s0_closure","computeStartState","suppressEdge","next","addDFAState","predict","toLexerString","ds0","isAcceptState","captureSimState","getExistingTargetState","computeTargetState","failOrAccept","edges","reach","getReachableConfigSet","items","addDFAEdge","prediction","closure","skipAlt","cfg","currentAltReachedAcceptState","getTokenName","getReachableTarget","fixOffsetBeforeMatch","treatEofAsEpsilon","charPos","execute","matches","initialContext","speculative","getEpsilonTarget","serializationType","predIndex","evaluatePredicate","append","savedcolumn","savedLine","settings","tk","cfgs","proposed","firstConfigWithRuleStopState","newState","getDFA","tt","LexerAction","action","isPositionDependent","LexerIndexedCustomAction","updatedLexerActions","requiresSeek","stopIndex","numActions","PredPrediction","PredictionMode","NoViableAltException","ParserATNSimulator","predictionMode","LL","_startIndex","_outerContext","_dfa","debug_closure","debug_add","debug_list_atn_decisions","retry_debug","adaptivePredict","getLookaheadName","precedenceDfa","getPrecedenceStartState","atnStartState","applyPrecedenceFilter","setPrecedenceStartState","previousD","D","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","requiresFullContext","SLL","predicates","conflictIndex","evalSemanticContext","reportAttemptingFullContext","execATNWithFullContext","alts","reportAmbiguity","computeReachSet","predictedAlt","getUniqueAlt","altSubSets","getConflictingAltSubsets","allSubsetsConflict","getConflictingAlts","hasSLLConflictTerminatingPrediction","predicateDFAState","decisionState","nalts","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","resolvesToJustOneViableAlt","LL_EXACT_AMBIG_DETECTION","allSubsetsEqual","getSingleViableAlt","reportContextSensitivity","intermediate","skippedStopStates","closureBusy","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","lookToEndOfRule","allConfigsInRuleStopStates","endOfRuleState","statesFromAlt1","configSet","updatedContext","evalPrecedence","ambigAlts","orContext","nPredAlts","pred","pairs","containsPredicate","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","succeeded","failed","evaluate","predPredictions","complete","predictions","predicateEvaluationResult","collectPredicates","closureCheckingStopState","parms","getRuleName","closure_","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","newDepth","numCtxs","blockEndStateNum","blockEndState","returnStateNumber","returnStateTarget","ruleTransition","precedenceTransition","predTransition","actionTransition","pt","currentPosition","predSucceeds","getPredicate","newSemCtx","andContext","isCtxDependent","altsets","getAlts","dumpDeadEndConfigs","nvae","decs","getDeadEndConfigs","error","exact","dup","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasNonConflictingAltSet","all","configToAlts","getStateToAltMap","minAlt","Predicate","PrecedencePredicate","AND","operands","opnds","precedencePredicates","filterPrecedencePredicates","reduced","OR","sort","compareTo","differs","evaluated","label_","makeLabel","ruleStart","serializationTypes","minVocabSymbol","maxVocabSymbol","DFASerializer","LexerDFASerializer","DFA","_states","precedenceState","setPrecedenceDfa","DFAStatesSet","sortedStates","buf","getStateString","getEdgeLabel","baseStateStr","getAltSet","ErrorListener","DiagnosticErrorListener","exactOnly","recognizer","getDecisionDescription","reportedAlts","delegates","offendingSymbol","Errors","InputMismatchException","FailedPredicateException","ParseCancellationException","ErrorStrategy","errorRecoveryMode","lastErrorIndex","lastErrorStates","BailErrorStrategy","reportError","endErrorCondition","beginErrorCondition","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","getMessage","followSet","getErrorRecoverySet","consumeUntil","la","singleTokenDeletion","reportUnwantedToken","expecting","whatFollowsLoopIterationOrRule","startToken","escapeWSAndQuote","reportMissingToken","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","nextTokenType","tokenText","currentSymbol","expectedTokenType","current","lookback","recoverSet","follow","Error","captureStackTrace","offendingState","deadEndConfigs","predicate","formatMessage","predicateIndex","codepointat","fromcodepoint","tree","object","$defineProperty","position","TypeError","string","Number","second","stringFromCharCode","floor","_","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","isFinite","RangeError","SyntaxTree","ParseTree","ParseTreeVisitor","ParseTreeWalker","visit","getSymbol","walk","getNodeText","res","getChildren","list","getAncestors","ancestors","findAllTokenNodes","findAllNodes","findAllRuleNodes","findTokens","nodes","_findAllNodes","descendants","antlr4","serializedATN","decisionsToDFA","ds","LscLexer","COMMENT","SEP","CHANGE","CONDITION","EXCLUSION","ANCHOR","NEWLINE","WHITESPACE","O_PAREN","C_PAREN","NULL","MATRIX_START","MATRIX_END","LIST_START","LIST_END","AT_LEAST_ONE","OPTIONAL","HYPHEN","NEGATION","SYLLABLE_BOUNDARY","WORD_BOUNDARY","BETWEEN_WORDS","CLASSREF","INTERSECTION","CLASS_DECL","FEATURE_DECL","SYLLABLE_FEATURE","DIACRITIC","DIA_BEFORE","DIA_FIRST","DIA_FLOATING","SYMBOL","SYLLABLE_DECL","EXPLICIT_SYLLABLES","CLEAR_SYLLABLES","ANY_SYLLABLE","DEROMANIZER","ROMANIZER","ALL_MATCHING","FIRST_MATCHING","PROPAGATE","LITERAL","UNCHANGED","NUMBER","NAME","STR1","STR","channelNames","modeNames","grammarFileName","LscVisitor","LscParser","LscFileContext","RULE_lscFile","StatementContext","RULE_statement","ClassDeclContext","RULE_classDecl","ClassElementContext","RULE_classElement","FeatureDeclContext","RULE_featureDecl","FeatureModifierContext","RULE_featureModifier","PlusFeatureContext","RULE_plusFeature","NullAliasContext","RULE_nullAlias","DiacriticDeclContext","RULE_diacriticDecl","DiacriticModifierContext","RULE_diacriticModifier","SymbolDeclContext","RULE_symbolDecl","SymbolNameContext","RULE_symbolName","SyllableDeclContext","RULE_syllableDecl","SyllablePatternContext","RULE_syllablePattern","DeromanizerContext","RULE_deromanizer","RomanizerContext","RULE_romanizer","InterRomanizerContext","RULE_interRomanizer","ChangeRuleContext","RULE_changeRule","ChangeRuleModifierContext","RULE_changeRuleModifier","FilterContext","RULE_filter","BlockContext","RULE_block","BlockElementContext","RULE_blockElement","BlockTypeContext","RULE_blockType","ExpressionListContext","RULE_expressionList","RuleNameContext","RULE_ruleName","ExpressionContext","RULE_expression","FromContext","RULE_from","ToContext","RULE_to","RuleElementContext","RULE_ruleElement","BoundedContext","RULE_bounded","GroupContext","RULE_group","ListContext","RULE_list","LookaroundContext","RULE_lookaround","SequenceContext","RULE_sequence","FreeElementContext","RULE_freeElement","CompoundEnvironmentContext","RULE_compoundEnvironment","ConditionContext","RULE_condition","ExclusionContext","RULE_exclusion","EnvironmentListContext","RULE_environmentList","EnvironmentContext","RULE_environment","EnvironmentBeforeContext","RULE_environmentBefore","EnvironmentAfterContext","RULE_environmentAfter","IntersectionContext","RULE_intersection","InterfixElementContext","RULE_interfixElement","NegatedContext","RULE_negated","PostfixContext","RULE_postfix","CaptureContext","RULE_capture","RepeaterContext","RULE_repeater","SimpleContext","RULE_simple","AnySyllableContext","RULE_anySyllable","ClassRefContext","RULE_classRef","CaptureRefContext","RULE_captureRef","FancyMatrixContext","RULE_fancyMatrix","FancyValueContext","RULE_fancyValue","NegatedValueContext","RULE_negatedValue","AbsentFeatureContext","RULE_absentFeature","FeatureVariableContext","RULE_featureVariable","EmptyContext","RULE_empty","SylBoundaryContext","RULE_sylBoundary","BoundaryContext","RULE_boundary","BetweenWordsContext","RULE_betweenWords","RepeaterTypeContext","RULE_repeaterType","MatrixContext","RULE_matrix","MatrixValueContext","RULE_matrixValue","PlusFeatureValueContext","RULE_plusFeatureValue","FeatureValueContext","RULE_featureValue","NameContext","RULE_name","TextContext","RULE_text","statement","visitLscFile","lscFile","_la","_alt","featureDecl","diacriticDecl","symbolDecl","classDecl","syllableDecl","deromanizer","changeRule","interRomanizer","romanizer","visitStatement","classElement","visitClassDecl","classRef","visitClassElement","plusFeature","featureValue","featureModifier","nullAlias","visitFeatureDecl","visitFeatureModifier","visitPlusFeature","visitNullAlias","matrix","diacriticModifier","visitDiacriticDecl","visitDiacriticModifier","symbolName","visitSymbolDecl","visitSymbolName","syllablePattern","visitSyllableDecl","ruleElement","compoundEnvironment","visitSyllablePattern","block","visitDeromanizer","visitRomanizer","visitInterRomanizer","changeRuleModifier","visitChangeRule","filter","visitChangeRuleModifier","fancyMatrix","visitFilter","blockElement","blockType","visitBlock","expressionList","visitBlockElement","visitBlockType","expression","visitExpressionList","visitRuleName","from","visitExpression","visitFrom","visitTo","bounded","intersection","negated","postfix","simple","sequence","visitRuleElement","group","lookaround","visitBounded","visitGroup","visitList","visitLookaround","freeElement","visitSequence","visitFreeElement","exclusion","visitCompoundEnvironment","environment","environmentList","visitCondition","visitExclusion","visitEnvironmentList","environmentBefore","environmentAfter","visitEnvironment","visitEnvironmentBefore","visitEnvironmentAfter","interfixElement","visitIntersection","visitInterfixElement","visitNegated","capture","repeater","visitPostfix","captureRef","visitCapture","repeaterType","visitRepeater","anySyllable","empty","sylBoundary","boundary","betweenWords","visitSimple","visitAnySyllable","visitClassRef","visitCaptureRef","fancyValue","visitFancyMatrix","plusFeatureValue","negatedValue","absentFeature","featureVariable","visitFancyValue","visitNegatedValue","visitAbsentFeature","visitFeatureVariable","visitEmpty","visitSylBoundary","visitBoundary","visitBetweenWords","visitRepeaterType","matrixValue","visitMatrix","visitMatrixValue","visitPlusFeatureValue","visitFeatureValue","visitName","visitText","Kotlin","isBooleanArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","getCallableRef","f","callableName","toByte","toChar","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","obj","objType","getObjectHashCode","numberHashCode","getStringHashCode","bufFloat64","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","throwMarkerError","imul","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","identityHashCode","Long","low_","low","high_","high","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","radix","opt_radix","substring","radixToPower","parseInt","power","multiply","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toInt","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","log2","ceil","LN2","delta","approxRes","approxRem","modulo","and","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","suspendCall","coroutineResult","coroutineReceiver","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","ensureNotNull","throwNPE","startsWith","searchString","lastIndexOf","endsWith","subjectString","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","O","relativeStart","end","relativeEnd","finalValue","normalizeOffset","typedArraySlice","begin","subarray","arrays","TypedArray","Function","self","array","totalOrderComparator","compareFunction","Kind","isType","klass","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isComparable","Comparable","isCharSequence","CharSequence","ordinal","initValue","fillArrayVal","element","filterNotNullTo","destination","IntRange","asCollection","iterator","hasNext","NoSuchElementException","checkIndexOverflow","last","single","emptyList","listOf","optimizeReadOnlyList","emptySet","setOf","optimizeReadOnlySet","separator","prefix","limit","truncated","transform","step","minimumValue","maximumValue","emptySequence","TakeSequence","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","Exception","RuntimeException","newSize","defaultValue","ArrayList","arrayCopyResize","fromIndex","toIndex","comparator","midPoint","reverseIndex","ch","toArray","copyToArrayImpl","collection","copyToArray","collectionsSort","endIndex","destinationOffset","rangeSize","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","initialCapacity","elements","_stableSortingIsSupported","comparison","getStableSortingIsSupported","mergeSort","median","leftIndex","rightIndex","leftValue","rightValue","checkIsMutable","modified","it","times","hasPrevious","newValue","iter","modCount","arrayCopy","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","createJsMap","original","BaseOutput","BufferedOutput","initialResult","ClassCastException","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","lastEntry","_head","_tail","old","newEntry","build","outputStream","write","messageString","flush","cur","simpleName","jsClass","PrimitiveKClassImpl","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","kClass","content","uppercase","MIN_HIGH_SURROGATE","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","MAX_LOW_SURROGATE","isWhitespaceImpl","char","RegExp","IndexOutOfBoundsException","reversed","isLowSurrogate","isHighSurrogate","concatToString","toInsert","newLength","dstIndex","stringCsq","exec","test","findNext","Regex","replacement","lastStart","sb","foundMatch","range","collectionSizeOrDefault","nonGlobalOptions","subSequence","literal","AbstractList","ignoreCase","JsMath","n1","n2","s1","s2","toLowerCase","regex","regionMatchesImpl","thisOffset","otherOffset","MatchGroup","computeNext","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","isVarargs","IndexingIterator","IndexedValue","putAll","emptyMap","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","SequenceScope","reverseElementIndex","throwOnFailure","ConstrainedOnceSequence","GeneratorSequence","seedFunction","nextFunction","FlatteningSequence","itemIterator","nextItemIterator","SubSequence","nextItem","nextState","toCollection","filledSize","AbstractIterator","selectors","compareValues","fn","diff","compareValuesByImpl","bufferInitialCapacity","capacity","isFull","done","widx","maxCapacity","RingBuffer","newCapacity","safe","getOrThrow","acc","interceptor","CombinedContext","operation","initial","newLeft","uppercaseChar","thisUpper","otherUpper","checkRadix","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","NumberFormatException","padChar","indices","regionMatches","currentStartIndex","strings","findAnyOf","currentIndex","DelimitedRangesSequence","asList","delimiters","splitToSequence","accumulator","nextSearchIndex","groupValues","initializer","isInitialized","InitializedLazyImpl","Pair","that","toMutableList","resultSize","sortWith","IndexingIterable","partialWindows","checkWindowSizeStep","thisSize","MovingSubList","windowSize","windowedIterator","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","instance","UnsafeLazyImpl","output","delegate","NullPointerException","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toIntOrNull","numberFormatError","suffix","filterNotNull","listT","listR","getOrImplicitDefault","mapOf","toMutableMap","optimizeReadOnlyMap","ReversedListReadOnly","constrainOnce","Comparator","ComparableRange","startFound","padEnd","delimiter","currentOffset","isLimited","lineSequence","isNode","NodeJsOutput","BufferedOutputToConsoleLog","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"mappings":"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lB0jC,EAAMjiC,KAAKH,IAEFmiC,GAAeniC,aAAa8W,GACnC9W,EAAEwL,YAAY9M,GAChB0jC,EAAMjiC,KAAKH,GAIb,IAAI,IAAIH,EAAE,EAAEA,EAAEG,EAAE6X,gBAAgBhY,IAC/Bmd,EAAMqlB,cAAcriC,EAAEuX,SAAS1X,GAAInB,EAAOyjC,EAAYC,IAIxDplB,EAAMslB,YAAc,SAAStiC,GAEzB,IADH,IAAIoiC,EAAQ,CAACpiC,GACFH,EAAE,EAAEA,EAAEG,EAAE6X,gBAAgBhY,IAC5BuiC,EAAQA,EAAMrjB,OAAO/B,EAAMslB,YAAYtiC,EAAEuX,SAAS1X,KAEtD,OAAOuiC,GAIXvkC,EAAQmf,MAAQA,G,aCtIhB,IAAItG,EAAO,EAAQ,MACnB7Y,EAAQmf,MAAQ,EAAhB,YACAnf,EAAQye,SAAW5F,EAAK4F,SACxBze,EAAQgS,kBAAoB6G,EAAK7G,kBACjChS,EAAQwjC,iBAAmB3qB,EAAK2qB,iBAChCxjC,EAAQyjC,gBAAkB5qB,EAAK4qB,iB,eCR/B,IAAIiB,EAAS,EAAQ,MAIjBC,EAAgB,CAAC,YACjB,oBACA,qBACA,iCACA,4BACA,qBACA,oBACA,qBACA,oBACA,4BACA,qCACA,sCACA,+BACA,qBACA,gBACA,oBACA,gBACA,gBACA,kBACA,gBACA,4BACA,oCACA,uBACA,kBACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,eACA,gBACA,eACA,eACA,eACA,gBACA,eACA,eACA,gBACA,eACA,eACA,kBACA,uBACA,yBACA,uBACA,uBACA,qBACA,uBACA,uBACA,uBACA,yBACA,qBACA,qBACA,uBACA,uBACA,yBACA,yBACA,yBACA,uBACA,yBACA,uBACA,yBACA,uBACA,2BACA,8BACA,sBACA,qBACA,2BACA,kBACA,uBACA,kDACA,qBACA,eACA,sBACA,iCACA,eACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,kBACA,iBACA,eACA,eACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,oBACA,kBACA,uBACA,oBACA,qBACA,oBACA,oBACA,oBACA,mBACA,gBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,gBACA,eACA,gBACA,eACA,gBACA,gBACA,eACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,eACA,eACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,eACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,eACA,eACA,iBACA,gBACA,gBACA,eACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,eACA,eACA,gBACA,gBACA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,YAC3B,eAAgB,SAAU,gBAC1B,qBAAsB,kBACtB,eAAgB,cAAe,YAC/B,eAAgB,iBAAkB,YAClC,UAAW,YAAa,SAAU,OAClC,OAAQ,MAAO,OAAQ,QAAS,MAChC,iBAEjC4xB,EAAS/jC,UAAUinC,gBAAkB,SAIrChoC,EAAQ,EAAW8kC,G,eC5cnB,IAAIJ,EAAS,EAAQ,MACjBuD,EAAa,QAAAn+B,EAKb66B,EAAgB,CAAC,YACjB,oBACA,oBACA,sCACA,yBACA,qBACA,oBACA,qBACA,oBACA,iCACA,sCACA,sCACA,sCACA,sCACA,+BACA,mBACA,kBACA,oBACA,iBACA,iBACA,gBACA,gBACA,eACA,kBACA,gBACA,gBACA,kBACA,iBACA,gBACA,gBACA,kBACA,iBACA,qBACA,+BACA,8BACA,gCACA,6BACA,gCACA,4BACA,kBACA,kBACA,kBACA,gBACA,gBACA,gBACA,kBACA,gBACA,kBACA,eACA,gBACA,kBACA,kBACA,iBACA,kBACA,gBACA,gBACA,kBACA,kBACA,gBACA,mBACA,kBACA,iBACA,iBACA,gBACA,kBACA,oBACA,gBACA,mBACA,eACA,gBACA,eACA,gBACA,sBACA,0BACA,0BACA,wBACA,yBACA,yBACA,0BACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,0BACA,yBACA,uBACA,yBACA,0BACA,yBACA,yBACA,6BACA,wCACA,uBACA,oBACA,eACA,gBACA,kBACA,eACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,eACA,kBACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,kBACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,eACA,kBACA,gBACA,eACA,eACA,eACA,kBACA,eACA,eACA,iBACA,eACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,gBACA,kBACA,gBACA,eACA,eACA,eACA,eACA,gBACA,eACA,gBACA,iBACA,iBACA,eACA,eACA,eACA,gBACA,iBACA,eACA,eACA,eACA,gBACA,iBACA,gBACA,gBACA,eACA,eACA,gBACA,gBACA,eACA,gBACA,gBACA,eACA,eACA,gBACA,gBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,gBACA,eACA,iBACA,eACA,eACA,gBACA,eACA,eACA,eACA,iBACA,eACA,eACA,gBACA,eACA,eACA,gBACA,eACA,iBACA,eACA,eACA,gBACA,eACA,eACA,eACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,eACA,gBACA,gBACA,eACA,kBACA,eACA,gBACA,gBACA,eACA,eACA,eACA,kBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,gBACA,eACA,eACA,eACA,gBACA,eACA,eACA,gBACA,eACA,eACA,kBACA,eACA,eACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,eACA,eACA,gBACA,eACA,gBACA,eACA,gBACA,iBACA,eACA,oBACA,kBACA,eACA,eACA,eACA,kBACA,gBACA,eACA,gBACA,kBACA,eACA,eACA,eACA,eACA,eACA,eACA,gBACA,kBACA,iBACA,kBACA,eACA,eACA,iBACA,mBACA,gBACA,eACA,eACA,eACA,eACA,eACA,gBACA,eACA,kBACA,eACA,gBACA,gBACA,eACA,gBACA,gBACA,eACA,eACA,eACA,iBACA,gBACA,eACA,gBACA,kBACA,eACA,gBACA,eACA,eACA,gBACA,gBACA,iBACA,gBACA,eACA,eACA,iBACA,mBACA,eACA,eACA,eACA,mBACA,gBACA,eACA,mBACA,eACA,eACA,iBACA,iBACA,eACA,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I,EACA,IAIR,qDb41BO,QAuEM,2BAAAA,KAAA,qG,oBa55BU,Eb45BV,a,IACT,IAAY,W,ca/5BZ,I,EAAA,W,YAMJ,iB,Obw5Ba,mD,oBaj5BU,Ebi5BV,a,IACT,IAAY,W,cap5BZ,I,EAAA,W,YAMJ,wBb64Ba,+D,sBar4BU,Ebq4BV,a,IACT,IAAY,W,cax4BZ,I,EAAA,W,YAOJ,wBASI,wBAEqB,kD,eAYjB,WAXQ,uBAND,e,wBAgBL,SAAN,IAAM,qBACF,Iby2BK,a,mCAAA,Eav2BD,M,Ibu2BZ,a,Iav2B2B,Ebu2Bd,a,IACT,IAAY,W,kBa32BZ,E,WAKI,Y,wBbq2BK,Wan2BD,Gbm2BC,K,IAAb,iB,Ian2B2B,Ebm2Bd,a,IACT,IAAY,W,kBa32BZ,E,WAAA,oC,cAWJ,K,QbwxBO,SAAM,wBAuEA,kC,kBa91BwC,Eb81BxC,a,IACT,IAAY,W,ca/1BZ,I,EAAA,W,YAEJ,wBAKe,cACX,EACA,I,oDAMA,U,uFAaC,a,qCAFU,cACX,YACC,UACA,qBAGL,mDbuvBO,QAuEM,kG,kBaxzBO,EbwzBP,a,IACT,e,ca3zBA,I,EAAA,W,YAKJ,iB,OAKI,gBACI,I,8CAUJ,Q,gEAOM,a,iDAAN,IACY,GADZ,uGAEqC,mC,eACjC,QAAkC,WbotBnC,YAAM,MAuEA,8B,CAAb,Ia3xBgD,Eb2xBhD,EAAa,wB,IACT,IAAY,W,ca/xBZ,I,EAAA,EbgyBG,Sa5xBS,EAAM,kC,SAQlB,Y,mDADW,EAQP,I,+EAcA,IACA,GADA,kDAIR,gDbkrBO,QAuEM,4F,kBanvBO,EbmvBP,a,IACT,e,catvBA,I,EAAA,W,qBAKJ,Q,ObgvBa,oD,kBa1uBO,Eb0uBP,a,IACT,e,ca7uBA,I,EAAA,W,qBAKJ,Q,cAEe,IACI,GAAY,EAAZ,IADJ,aAEM,oBAAc,Y,sBACvB,qC,sBAGZ,iBAMQ,G,oDACQ,EAQZ,gBAZW,e,4GAuBa,MAFxB,cACI,EACA,mBAAY,MAAQ,e,+CASH,MAFrB,cACI,EACA,KAAiB,gDAGzB,iDAAqC,M,wDAEW,oC,OA8uBhD,kBAAiC,IA5uBO,+C,OA8iBxC,kBAAqC,IA5iBO,uC,OAwjB5C,kB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","file":"lexurgy.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lexurgy\"] = factory();\n\telse\n\t\troot[\"lexurgy\"] = factory();\n})(this, function() {\nreturn ","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n// This implementation of {@link TokenStream} loads tokens from a\n// {@link TokenSource} on-demand, and places the tokens in a buffer to provide\n// access to any previous token by index.\n//\n// <p>\n// This token stream ignores the value of {@link Token//getChannel}. If your\n// parser requires the token stream filter tokens to only those on a particular\n// channel, such as {@link Token//DEFAULT_CHANNEL} or\n// {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a\n// {@link CommonTokenStream}.</p>\n\nvar Token = require('./Token').Token;\nvar Lexer = require('./Lexer').Lexer;\nvar Interval = require('./IntervalSet').Interval;\n\n// this is just to keep meaningful parameter types to Parser\nfunction TokenStream() {\n\treturn this;\n}\n\nfunction BufferedTokenStream(tokenSource) {\n\n\tTokenStream.call(this);\n\t// The {@link TokenSource} from which tokens for this stream are fetched.\n\tthis.tokenSource = tokenSource;\n\n\t// A collection of all tokens fetched from the token source. The list is\n\t// considered a complete view of the input once {@link //fetchedEOF} is set\n\t// to {@code true}.\n\tthis.tokens = [];\n\n\t// The index into {@link //tokens} of the current token (next token to\n\t// {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should\n\t// be\n\t// {@link //LT LT(1)}.\n\t//\n\t// <p>This field is set to -1 when the stream is first constructed or when\n\t// {@link //setTokenSource} is called, indicating that the first token has\n\t// not yet been fetched from the token source. For additional information,\n\t// see the documentation of {@link IntStream} for a description of\n\t// Initializing Methods.</p>\n\tthis.index = -1;\n\n\t// Indicates whether the {@link Token//EOF} token has been fetched from\n\t// {@link //tokenSource} and added to {@link //tokens}. This field improves\n\t// performance for the following cases:\n\t//\n\t// <ul>\n\t// <li>{@link //consume}: The lookahead check in {@link //consume} to\n\t// prevent\n\t// consuming the EOF symbol is optimized by checking the values of\n\t// {@link //fetchedEOF} and {@link //p} instead of calling {@link\n\t// //LA}.</li>\n\t// <li>{@link //fetch}: The check to prevent adding multiple EOF symbols\n\t// into\n\t// {@link //tokens} is trivial with this field.</li>\n\t// <ul>\n\tthis.fetchedEOF = false;\n\treturn this;\n}\n\nBufferedTokenStream.prototype = Object.create(TokenStream.prototype);\nBufferedTokenStream.prototype.constructor = BufferedTokenStream;\n\nBufferedTokenStream.prototype.mark = function() {\n\treturn 0;\n};\n\nBufferedTokenStream.prototype.release = function(marker) {\n\t// no resources to release\n};\n\nBufferedTokenStream.prototype.reset = function() {\n\tthis.seek(0);\n};\n\nBufferedTokenStream.prototype.seek = function(index) {\n\tthis.lazyInit();\n\tthis.index = this.adjustSeekIndex(index);\n};\n\nBufferedTokenStream.prototype.get = function(index) {\n\tthis.lazyInit();\n\treturn this.tokens[index];\n};\n\nBufferedTokenStream.prototype.consume = function() {\n\tvar skipEofCheck = false;\n\tif (this.index >= 0) {\n\t\tif (this.fetchedEOF) {\n\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t// fetched token except the last.\n\t\t\tskipEofCheck = this.index < this.tokens.length - 1;\n\t\t} else {\n\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\tskipEofCheck = this.index < this.tokens.length;\n\t\t}\n\t} else {\n\t\t// not yet initialized\n\t\tskipEofCheck = false;\n\t}\n\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\n\t\tthrow \"cannot consume EOF\";\n\t}\n\tif (this.sync(this.index + 1)) {\n\t\tthis.index = this.adjustSeekIndex(this.index + 1);\n\t}\n};\n\n// Make sure index {@code i} in tokens has a token.\n//\n// @return {@code true} if a token is located at index {@code i}, otherwise\n// {@code false}.\n// @see //get(int i)\n// /\nBufferedTokenStream.prototype.sync = function(i) {\n\tvar n = i - this.tokens.length + 1; // how many more elements we need?\n\tif (n > 0) {\n\t\tvar fetched = this.fetch(n);\n\t\treturn fetched >= n;\n\t}\n\treturn true;\n};\n\n// Add {@code n} elements to buffer.\n//\n// @return The actual number of elements added to the buffer.\n// /\nBufferedTokenStream.prototype.fetch = function(n) {\n\tif (this.fetchedEOF) {\n\t\treturn 0;\n\t}\n\tfor (var i = 0; i < n; i++) {\n\t\tvar t = this.tokenSource.nextToken();\n\t\tt.tokenIndex = this.tokens.length;\n\t\tthis.tokens.push(t);\n\t\tif (t.type === Token.EOF) {\n\t\t\tthis.fetchedEOF = true;\n\t\t\treturn i + 1;\n\t\t}\n\t}\n\treturn n;\n};\n\n// Get all tokens from start..stop inclusively///\nBufferedTokenStream.prototype.getTokens = function(start, stop, types) {\n\tif (types === undefined) {\n\t\ttypes = null;\n\t}\n\tif (start < 0 || stop < 0) {\n\t\treturn null;\n\t}\n\tthis.lazyInit();\n\tvar subset = [];\n\tif (stop >= this.tokens.length) {\n\t\tstop = this.tokens.length - 1;\n\t}\n\tfor (var i = start; i < stop; i++) {\n\t\tvar t = this.tokens[i];\n\t\tif (t.type === Token.EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tif (types === null || types.contains(t.type)) {\n\t\t\tsubset.push(t);\n\t\t}\n\t}\n\treturn subset;\n};\n\nBufferedTokenStream.prototype.LA = function(i) {\n\treturn this.LT(i).type;\n};\n\nBufferedTokenStream.prototype.LB = function(k) {\n\tif (this.index - k < 0) {\n\t\treturn null;\n\t}\n\treturn this.tokens[this.index - k];\n};\n\nBufferedTokenStream.prototype.LT = function(k) {\n\tthis.lazyInit();\n\tif (k === 0) {\n\t\treturn null;\n\t}\n\tif (k < 0) {\n\t\treturn this.LB(-k);\n\t}\n\tvar i = this.index + k - 1;\n\tthis.sync(i);\n\tif (i >= this.tokens.length) { // return EOF token\n\t\t// EOF must be last token\n\t\treturn this.tokens[this.tokens.length - 1];\n\t}\n\treturn this.tokens[i];\n};\n\n// Allowed derived classes to modify the behavior of operations which change\n// the current stream position by adjusting the target token index of a seek\n// operation. The default implementation simply returns {@code i}. If an\n// exception is thrown in this method, the current stream index should not be\n// changed.\n//\n// <p>For example, {@link CommonTokenStream} overrides this method to ensure\n// that\n// the seek target is always an on-channel token.</p>\n//\n// @param i The target token index.\n// @return The adjusted target token index.\n\nBufferedTokenStream.prototype.adjustSeekIndex = function(i) {\n\treturn i;\n};\n\nBufferedTokenStream.prototype.lazyInit = function() {\n\tif (this.index === -1) {\n\t\tthis.setup();\n\t}\n};\n\nBufferedTokenStream.prototype.setup = function() {\n\tthis.sync(0);\n\tthis.index = this.adjustSeekIndex(0);\n};\n\n// Reset this token stream by setting its token source.///\nBufferedTokenStream.prototype.setTokenSource = function(tokenSource) {\n\tthis.tokenSource = tokenSource;\n\tthis.tokens = [];\n\tthis.index = -1;\n\tthis.fetchedEOF = false;\n};\n\n\n// Given a starting index, return the index of the next token on channel.\n// Return i if tokens[i] is on channel. Return -1 if there are no tokens\n// on channel between i and EOF.\n// /\nBufferedTokenStream.prototype.nextTokenOnChannel = function(i, channel) {\n\tthis.sync(i);\n\tif (i >= this.tokens.length) {\n\t\treturn -1;\n\t}\n\tvar token = this.tokens[i];\n\twhile (token.channel !== this.channel) {\n\t\tif (token.type === Token.EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ti += 1;\n\t\tthis.sync(i);\n\t\ttoken = this.tokens[i];\n\t}\n\treturn i;\n};\n\n// Given a starting index, return the index of the previous token on channel.\n// Return i if tokens[i] is on channel. Return -1 if there are no tokens\n// on channel between i and 0.\nBufferedTokenStream.prototype.previousTokenOnChannel = function(i, channel) {\n\twhile (i >= 0 && this.tokens[i].channel !== channel) {\n\t\ti -= 1;\n\t}\n\treturn i;\n};\n\n// Collect all tokens on specified channel to the right of\n// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n// EOF. If channel is -1, find any non default channel token.\nBufferedTokenStream.prototype.getHiddenTokensToRight = function(tokenIndex,\n\t\tchannel) {\n\tif (channel === undefined) {\n\t\tchannel = -1;\n\t}\n\tthis.lazyInit();\n\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t}\n\tvar nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\tvar from_ = tokenIndex + 1;\n\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\n\tvar to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n\treturn this.filterForChannel(from_, to, channel);\n};\n\n// Collect all tokens on specified channel to the left of\n// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n// If channel is -1, find any non default channel token.\nBufferedTokenStream.prototype.getHiddenTokensToLeft = function(tokenIndex,\n\t\tchannel) {\n\tif (channel === undefined) {\n\t\tchannel = -1;\n\t}\n\tthis.lazyInit();\n\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t}\n\tvar prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\tif (prevOnChannel === tokenIndex - 1) {\n\t\treturn null;\n\t}\n\t// if none on channel to left, prevOnChannel=-1 then from=0\n\tvar from_ = prevOnChannel + 1;\n\tvar to = tokenIndex - 1;\n\treturn this.filterForChannel(from_, to, channel);\n};\n\nBufferedTokenStream.prototype.filterForChannel = function(left, right, channel) {\n\tvar hidden = [];\n\tfor (var i = left; i < right + 1; i++) {\n\t\tvar t = this.tokens[i];\n\t\tif (channel === -1) {\n\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n\t\t\t\thidden.push(t);\n\t\t\t}\n\t\t} else if (t.channel === channel) {\n\t\t\thidden.push(t);\n\t\t}\n\t}\n\tif (hidden.length === 0) {\n\t\treturn null;\n\t}\n\treturn hidden;\n};\n\nBufferedTokenStream.prototype.getSourceName = function() {\n\treturn this.tokenSource.getSourceName();\n};\n\n// Get the text of all tokens in this buffer.///\nBufferedTokenStream.prototype.getText = function(interval) {\n\tthis.lazyInit();\n\tthis.fill();\n\tif (interval === undefined || interval === null) {\n\t\tinterval = new Interval(0, this.tokens.length - 1);\n\t}\n\tvar start = interval.start;\n\tif (start instanceof Token) {\n\t\tstart = start.tokenIndex;\n\t}\n\tvar stop = interval.stop;\n\tif (stop instanceof Token) {\n\t\tstop = stop.tokenIndex;\n\t}\n\tif (start === null || stop === null || start < 0 || stop < 0) {\n\t\treturn \"\";\n\t}\n\tif (stop >= this.tokens.length) {\n\t\tstop = this.tokens.length - 1;\n\t}\n\tvar s = \"\";\n\tfor (var i = start; i < stop + 1; i++) {\n\t\tvar t = this.tokens[i];\n\t\tif (t.type === Token.EOF) {\n\t\t\tbreak;\n\t\t}\n\t\ts = s + t.text;\n\t}\n\treturn s;\n};\n\n// Get all tokens from lexer until EOF///\nBufferedTokenStream.prototype.fill = function() {\n\tthis.lazyInit();\n\twhile (this.fetch(1000) === 1000) {\n\t\tcontinue;\n\t}\n};\n\nexports.BufferedTokenStream = BufferedTokenStream;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\nvar InputStream = require('./InputStream').InputStream;\n\nvar isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';\nvar fs = isNodeJs ? require(\"fs\") : null;\n\n// Utility functions to create InputStreams from various sources.\n//\n// All returned InputStreams support the full range of Unicode\n// up to U+10FFFF (the default behavior of InputStream only supports\n// code points up to U+FFFF).\nvar CharStreams = {\n  // Creates an InputStream from a string.\n  fromString: function(str) {\n    return new InputStream(str, true);\n  },\n\n  // Asynchronously creates an InputStream from a blob given the\n  // encoding of the bytes in that blob (defaults to 'utf8' if\n  // encoding is null).\n  //\n  // Invokes onLoad(result) on success, onError(error) on\n  // failure.\n  fromBlob: function(blob, encoding, onLoad, onError) {\n    var reader = FileReader();\n    reader.onload = function(e) {\n      var is = new InputStream(e.target.result, true);\n      onLoad(is);\n    };\n    reader.onerror = onError;\n    reader.readAsText(blob, encoding);\n  },\n\n  // Creates an InputStream from a Buffer given the\n  // encoding of the bytes in that buffer (defaults to 'utf8' if\n  // encoding is null).\n  fromBuffer: function(buffer, encoding) {\n    return new InputStream(buffer.toString(encoding), true);\n  },\n\n  // Asynchronously creates an InputStream from a file on disk given\n  // the encoding of the bytes in that file (defaults to 'utf8' if\n  // encoding is null).\n  //\n  // Invokes callback(error, result) on completion.\n  fromPath: function(path, encoding, callback) {\n    fs.readFile(path, encoding, function(err, data) {\n      var is = null;\n      if (data !== null) {\n        is = new InputStream(data, true);\n      }\n      callback(err, is);\n    });\n  },\n\n  // Synchronously creates an InputStream given a path to a file\n  // on disk and the encoding of the bytes in that file (defaults to\n  // 'utf8' if encoding is null).\n  fromPathSync: function(path, encoding) {\n    var data = fs.readFileSync(path, encoding);\n    return new InputStream(data, true);\n  }\n};\n\nexports.CharStreams = CharStreams;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n//\n// This default implementation of {@link TokenFactory} creates\n// {@link CommonToken} objects.\n//\n\nvar CommonToken = require('./Token').CommonToken;\n\nfunction TokenFactory() {\n\treturn this;\n}\n\nfunction CommonTokenFactory(copyText) {\n\tTokenFactory.call(this);\n    // Indicates whether {@link CommonToken//setText} should be called after\n    // constructing tokens to explicitly set the text. This is useful for cases\n    // where the input stream might not be able to provide arbitrary substrings\n    // of text from the input after the lexer creates a token (e.g. the\n    // implementation of {@link CharStream//getText} in\n    // {@link UnbufferedCharStream} throws an\n    // {@link UnsupportedOperationException}). Explicitly setting the token text\n    // allows {@link Token//getText} to be called at any time regardless of the\n    // input stream implementation.\n    //\n    // <p>\n    // The default value is {@code false} to avoid the performance and memory\n    // overhead of copying text for every token unless explicitly requested.</p>\n    //\n    this.copyText = copyText===undefined ? false : copyText;\n\treturn this;\n}\n\nCommonTokenFactory.prototype = Object.create(TokenFactory.prototype);\nCommonTokenFactory.prototype.constructor = CommonTokenFactory;\n\n//\n// The default {@link CommonTokenFactory} instance.\n//\n// <p>\n// This token factory does not explicitly copy token text when constructing\n// tokens.</p>\n//\nCommonTokenFactory.DEFAULT = new CommonTokenFactory();\n\nCommonTokenFactory.prototype.create = function(source, type, text, channel, start, stop, line, column) {\n    var t = new CommonToken(source, type, channel, start, stop);\n    t.line = line;\n    t.column = column;\n    if (text !==null) {\n        t.text = text;\n    } else if (this.copyText && source[1] !==null) {\n        t.text = source[1].getText(start,stop);\n    }\n    return t;\n};\n\nCommonTokenFactory.prototype.createThin = function(type, text) {\n    var t = new CommonToken(null, type);\n    t.text = text;\n    return t;\n};\n\nexports.CommonTokenFactory = CommonTokenFactory;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n//\n// This class extends {@link BufferedTokenStream} with functionality to filter\n// token streams to tokens on a particular channel (tokens where\n// {@link Token//getChannel} returns a particular value).\n//\n// <p>\n// This token stream provides access to all tokens by index or when calling\n// methods like {@link //getText}. The channel filtering is only used for code\n// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n// {@link //LB}.</p>\n//\n// <p>\n// By default, tokens are placed on the default channel\n// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n// call {@link Lexer//setChannel}.\n// </p>\n//\n// <p>\n// Note: lexer rules which use the {@code ->skip} lexer command or call\n// {@link Lexer//skip} do not produce tokens at all, so input text matched by\n// such a rule will not be available as part of the token stream, regardless of\n// channel.</p>\n///\n\nvar Token = require('./Token').Token;\nvar BufferedTokenStream = require('./BufferedTokenStream').BufferedTokenStream;\n\nfunction CommonTokenStream(lexer, channel) {\n\tBufferedTokenStream.call(this, lexer);\n    this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    return this;\n}\n\nCommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);\nCommonTokenStream.prototype.constructor = CommonTokenStream;\n\nCommonTokenStream.prototype.adjustSeekIndex = function(i) {\n    return this.nextTokenOnChannel(i, this.channel);\n};\n\nCommonTokenStream.prototype.LB = function(k) {\n    if (k===0 || this.index-k<0) {\n        return null;\n    }\n    var i = this.index;\n    var n = 1;\n    // find k good tokens looking backwards\n    while (n <= k) {\n        // skip off-channel tokens\n        i = this.previousTokenOnChannel(i - 1, this.channel);\n        n += 1;\n    }\n    if (i < 0) {\n        return null;\n    }\n    return this.tokens[i];\n};\n\nCommonTokenStream.prototype.LT = function(k) {\n    this.lazyInit();\n    if (k === 0) {\n        return null;\n    }\n    if (k < 0) {\n        return this.LB(-k);\n    }\n    var i = this.index;\n    var n = 1; // we know tokens[pos] is a good one\n    // find k good tokens\n    while (n < k) {\n        // skip off-channel tokens, but make sure to not look past EOF\n        if (this.sync(i + 1)) {\n            i = this.nextTokenOnChannel(i + 1, this.channel);\n        }\n        n += 1;\n    }\n    return this.tokens[i];\n};\n\n// Count EOF just once.///\nCommonTokenStream.prototype.getNumberOfOnChannelTokens = function() {\n    var n = 0;\n    this.fill();\n    for (var i =0; i< this.tokens.length;i++) {\n        var t = this.tokens[i];\n        if( t.channel===this.channel) {\n            n += 1;\n        }\n        if( t.type===Token.EOF) {\n            break;\n        }\n    }\n    return n;\n};\n\nexports.CommonTokenStream = CommonTokenStream;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n//\n//  This is an InputStream that is loaded from a file all at once\n//  when you construct the object.\n//\nvar InputStream = require('./InputStream').InputStream;\nvar isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';\nvar fs = isNodeJs ? require(\"fs\") : null;\n\nfunction FileStream(fileName, decodeToUnicodeCodePoints) {\n\tvar data = fs.readFileSync(fileName, \"utf8\");\n\tInputStream.call(this, data, decodeToUnicodeCodePoints);\n\tthis.fileName = fileName;\n\treturn this;\n}\n\nFileStream.prototype = Object.create(InputStream.prototype);\nFileStream.prototype.constructor = FileStream;\n\nexports.FileStream = FileStream;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\nvar Token = require('./Token').Token;\nrequire('./polyfills/codepointat');\nrequire('./polyfills/fromcodepoint');\n\n// Vacuum all input from a string and then treat it like a buffer.\n\nfunction _loadString(stream) {\n\tstream._index = 0;\n\tstream.data = [];\n\tif (stream.decodeToUnicodeCodePoints) {\n\t\tfor (var i = 0; i < stream.strdata.length; ) {\n\t\t\tvar codePoint = stream.strdata.codePointAt(i);\n\t\t\tstream.data.push(codePoint);\n\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t}\n\t} else {\n\t\tfor (var i = 0; i < stream.strdata.length; i++) {\n\t\t\tvar codeUnit = stream.strdata.charCodeAt(i);\n\t\t\tstream.data.push(codeUnit);\n\t\t}\n\t}\n\tstream._size = stream.data.length;\n}\n\n// If decodeToUnicodeCodePoints is true, the input is treated\n// as a series of Unicode code points.\n//\n// Otherwise, the input is treated as a series of 16-bit UTF-16 code\n// units.\nfunction InputStream(data, decodeToUnicodeCodePoints) {\n\tthis.name = \"<empty>\";\n\tthis.strdata = data;\n\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t_loadString(this);\n\treturn this;\n}\n\nObject.defineProperty(InputStream.prototype, \"index\", {\n\tget : function() {\n\t\treturn this._index;\n\t}\n});\n\nObject.defineProperty(InputStream.prototype, \"size\", {\n\tget : function() {\n\t\treturn this._size;\n\t}\n});\n\n// Reset the stream so that it's in the same state it was\n// when the object was created *except* the data array is not\n// touched.\n//\nInputStream.prototype.reset = function() {\n\tthis._index = 0;\n};\n\nInputStream.prototype.consume = function() {\n\tif (this._index >= this._size) {\n\t\t// assert this.LA(1) == Token.EOF\n\t\tthrow (\"cannot consume EOF\");\n\t}\n\tthis._index += 1;\n};\n\nInputStream.prototype.LA = function(offset) {\n\tif (offset === 0) {\n\t\treturn 0; // undefined\n\t}\n\tif (offset < 0) {\n\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t}\n\tvar pos = this._index + offset - 1;\n\tif (pos < 0 || pos >= this._size) { // invalid\n\t\treturn Token.EOF;\n\t}\n\treturn this.data[pos];\n};\n\nInputStream.prototype.LT = function(offset) {\n\treturn this.LA(offset);\n};\n\n// mark/release do nothing; we have entire buffer\nInputStream.prototype.mark = function() {\n\treturn -1;\n};\n\nInputStream.prototype.release = function(marker) {\n};\n\n// consume() ahead until p==_index; can't just set p=_index as we must\n// update line and column. If we seek backwards, just set p\n//\nInputStream.prototype.seek = function(_index) {\n\tif (_index <= this._index) {\n\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t// ...)\n\t\treturn;\n\t}\n\t// seek forward\n\tthis._index = Math.min(_index, this._size);\n};\n\nInputStream.prototype.getText = function(start, stop) {\n\tif (stop >= this._size) {\n\t\tstop = this._size - 1;\n\t}\n\tif (start >= this._size) {\n\t\treturn \"\";\n\t} else {\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tvar result = \"\";\n\t\t\tfor (var i = start; i <= stop; i++) {\n\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t}\n\t}\n};\n\nInputStream.prototype.toString = function() {\n\treturn this.strdata;\n};\n\nexports.InputStream = InputStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/*jslint smarttabs:true */\n\nvar Token = require('./Token').Token;\n\n/* stop is not included! */\nfunction Interval(start, stop) {\n\tthis.start = start;\n\tthis.stop = stop;\n\treturn this;\n}\n\nInterval.prototype.contains = function(item) {\n\treturn item >= this.start && item < this.stop;\n};\n\nInterval.prototype.toString = function() {\n\tif(this.start===this.stop-1) {\n\t\treturn this.start.toString();\n\t} else {\n\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t}\n};\n\n\nObject.defineProperty(Interval.prototype, \"length\", {\n\tget : function() {\n\t\treturn this.stop - this.start;\n\t}\n});\n\nfunction IntervalSet() {\n\tthis.intervals = null;\n\tthis.readOnly = false;\n}\n\nIntervalSet.prototype.first = function(v) {\n\tif (this.intervals === null || this.intervals.length===0) {\n\t\treturn Token.INVALID_TYPE;\n\t} else {\n\t\treturn this.intervals[0].start;\n\t}\n};\n\nIntervalSet.prototype.addOne = function(v) {\n\tthis.addInterval(new Interval(v, v + 1));\n};\n\nIntervalSet.prototype.addRange = function(l, h) {\n\tthis.addInterval(new Interval(l, h + 1));\n};\n\nIntervalSet.prototype.addInterval = function(v) {\n\tif (this.intervals === null) {\n\t\tthis.intervals = [];\n\t\tthis.intervals.push(v);\n\t} else {\n\t\t// find insert pos\n\t\tfor (var k = 0; k < this.intervals.length; k++) {\n\t\t\tvar i = this.intervals[k];\n\t\t\t// distinct range -> insert\n\t\t\tif (v.stop < i.start) {\n\t\t\t\tthis.intervals.splice(k, 0, v);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// contiguous range -> adjust\n\t\t\telse if (v.stop === i.start) {\n\t\t\t\tthis.intervals[k].start = v.start;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// overlapping range -> adjust and reduce\n\t\t\telse if (v.start <= i.stop) {\n\t\t\t\tthis.intervals[k] = new Interval(Math.min(i.start, v.start), Math.max(i.stop, v.stop));\n\t\t\t\tthis.reduce(k);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// greater than any existing\n\t\tthis.intervals.push(v);\n\t}\n};\n\nIntervalSet.prototype.addSet = function(other) {\n\tif (other.intervals !== null) {\n\t\tfor (var k = 0; k < other.intervals.length; k++) {\n\t\t\tvar i = other.intervals[k];\n\t\t\tthis.addInterval(new Interval(i.start, i.stop));\n\t\t}\n\t}\n\treturn this;\n};\n\nIntervalSet.prototype.reduce = function(k) {\n\t// only need to reduce if k is not the last\n\tif (k < this.intervalslength - 1) {\n\t\tvar l = this.intervals[k];\n\t\tvar r = this.intervals[k + 1];\n\t\t// if r contained in l\n\t\tif (l.stop >= r.stop) {\n\t\t\tthis.intervals.pop(k + 1);\n\t\t\tthis.reduce(k);\n\t\t} else if (l.stop >= r.start) {\n\t\t\tthis.intervals[k] = new Interval(l.start, r.stop);\n\t\t\tthis.intervals.pop(k + 1);\n\t\t}\n\t}\n};\n\nIntervalSet.prototype.complement = function(start, stop) {\n    var result = new IntervalSet();\n    result.addInterval(new Interval(start,stop+1));\n    for(var i=0; i<this.intervals.length; i++) {\n        result.removeRange(this.intervals[i]);\n    }\n    return result;\n};\n\nIntervalSet.prototype.contains = function(item) {\n\tif (this.intervals === null) {\n\t\treturn false;\n\t} else {\n\t\tfor (var k = 0; k < this.intervals.length; k++) {\n\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nObject.defineProperty(IntervalSet.prototype, \"length\", {\n\tget : function() {\n\t\tvar len = 0;\n\t\tthis.intervals.map(function(i) {len += i.length;});\n\t\treturn len;\n\t}\n});\n\nIntervalSet.prototype.removeRange = function(v) {\n    if(v.start===v.stop-1) {\n        this.removeOne(v.start);\n    } else if (this.intervals!==null) {\n        var k = 0;\n        for(var n=0; n<this.intervals.length; n++) {\n            var i = this.intervals[k];\n            // intervals are ordered\n            if (v.stop<=i.start) {\n                return;\n            }\n            // check for including range, split it\n            else if(v.start>i.start && v.stop<i.stop) {\n                this.intervals[k] = new Interval(i.start, v.start);\n                var x = new Interval(v.stop, i.stop);\n                this.intervals.splice(k, 0, x);\n                return;\n            }\n            // check for included range, remove it\n            else if(v.start<=i.start && v.stop>=i.stop) {\n                this.intervals.splice(k, 1);\n                k = k - 1; // need another pass\n            }\n            // check for lower boundary\n            else if(v.start<i.stop) {\n                this.intervals[k] = new Interval(i.start, v.start);\n            }\n            // check for upper boundary\n            else if(v.stop<i.stop) {\n                this.intervals[k] = new Interval(v.stop, i.stop);\n            }\n            k += 1;\n        }\n    }\n};\n\nIntervalSet.prototype.removeOne = function(v) {\n\tif (this.intervals !== null) {\n\t\tfor (var k = 0; k < this.intervals.length; k++) {\n\t\t\tvar i = this.intervals[k];\n\t\t\t// intervals is ordered\n\t\t\tif (v < i.start) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// check for single value range\n\t\t\telse if (v === i.start && v === i.stop - 1) {\n\t\t\t\tthis.intervals.splice(k, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// check for lower boundary\n\t\t\telse if (v === i.start) {\n\t\t\t\tthis.intervals[k] = new Interval(i.start + 1, i.stop);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// check for upper boundary\n\t\t\telse if (v === i.stop - 1) {\n\t\t\t\tthis.intervals[k] = new Interval(i.start, i.stop - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// split existing range\n\t\t\telse if (v < i.stop - 1) {\n\t\t\t\tvar x = new Interval(i.start, v);\n\t\t\t\ti.start = v + 1;\n\t\t\t\tthis.intervals.splice(k, 0, x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n};\n\nIntervalSet.prototype.toString = function(literalNames, symbolicNames, elemsAreChar) {\n\tliteralNames = literalNames || null;\n\tsymbolicNames = symbolicNames || null;\n\telemsAreChar = elemsAreChar || false;\n\tif (this.intervals === null) {\n\t\treturn \"{}\";\n\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t} else if(elemsAreChar) {\n\t\treturn this.toCharString();\n\t} else {\n\t\treturn this.toIndexString();\n\t}\n};\n\nIntervalSet.prototype.toCharString = function() {\n\tvar names = [];\n\tfor (var i = 0; i < this.intervals.length; i++) {\n\t\tvar v = this.intervals[i];\n\t\tif(v.stop===v.start+1) {\n\t\t\tif ( v.start===Token.EOF ) {\n\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(v.start) + \"'\");\n\t\t\t}\n\t\t} else {\n\t\t\tnames.push(\"'\" + String.fromCharCode(v.start) + \"'..'\" + String.fromCharCode(v.stop-1) + \"'\");\n\t\t}\n\t}\n\tif (names.length > 1) {\n\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t} else {\n\t\treturn names[0];\n\t}\n};\n\n\nIntervalSet.prototype.toIndexString = function() {\n\tvar names = [];\n\tfor (var i = 0; i < this.intervals.length; i++) {\n\t\tvar v = this.intervals[i];\n\t\tif(v.stop===v.start+1) {\n\t\t\tif ( v.start===Token.EOF ) {\n\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t} else {\n\t\t\t\tnames.push(v.start.toString());\n\t\t\t}\n\t\t} else {\n\t\t\tnames.push(v.start.toString() + \"..\" + (v.stop-1).toString());\n\t\t}\n\t}\n\tif (names.length > 1) {\n\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t} else {\n\t\treturn names[0];\n\t}\n};\n\n\nIntervalSet.prototype.toTokenString = function(literalNames, symbolicNames) {\n\tvar names = [];\n\tfor (var i = 0; i < this.intervals.length; i++) {\n\t\tvar v = this.intervals[i];\n\t\tfor (var j = v.start; j < v.stop; j++) {\n\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t}\n\t}\n\tif (names.length > 1) {\n\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t} else {\n\t\treturn names[0];\n\t}\n};\n\nIntervalSet.prototype.elementName = function(literalNames, symbolicNames, a) {\n\tif (a === Token.EOF) {\n\t\treturn \"<EOF>\";\n\t} else if (a === Token.EPSILON) {\n\t\treturn \"<EPSILON>\";\n\t} else {\n\t\treturn literalNames[a] || symbolicNames[a];\n\t}\n};\n\nexports.Interval = Interval;\nexports.IntervalSet = IntervalSet;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\nvar Set = require('./Utils').Set;\nvar BitSet = require('./Utils').BitSet;\nvar Token = require('./Token').Token;\nvar ATNConfig = require('./atn/ATNConfig').ATNConfig;\nvar Interval = require('./IntervalSet').Interval;\nvar IntervalSet = require('./IntervalSet').IntervalSet;\nvar RuleStopState = require('./atn/ATNState').RuleStopState;\nvar RuleTransition = require('./atn/Transition').RuleTransition;\nvar NotSetTransition = require('./atn/Transition').NotSetTransition;\nvar WildcardTransition = require('./atn/Transition').WildcardTransition;\nvar AbstractPredicateTransition = require('./atn/Transition').AbstractPredicateTransition;\n\nvar pc = require('./PredictionContext');\nvar predictionContextFromRuleContext = pc.predictionContextFromRuleContext;\nvar PredictionContext = pc.PredictionContext;\nvar SingletonPredictionContext = pc.SingletonPredictionContext;\n\nfunction LL1Analyzer (atn) {\n    this.atn = atn;\n}\n\n//* Special value added to the lookahead sets to indicate that we hit\n//  a predicate during analysis if {@code seeThruPreds==false}.\n///\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\n\n//*\n// Calculates the SLL(1) expected lookahead set for each outgoing transition\n// of an {@link ATNState}. The returned array has one element for each\n// outgoing transition in {@code s}. If the closure from transition\n// <em>i</em> leads to a semantic predicate before matching a symbol, the\n// element at index <em>i</em> of the result will be {@code null}.\n//\n// @param s the ATN state\n// @return the expected symbols for each outgoing transition of {@code s}.\n///\nLL1Analyzer.prototype.getDecisionLookahead = function(s) {\n    if (s === null) {\n        return null;\n    }\n    var count = s.transitions.length;\n    var look = [];\n    for(var alt=0; alt< count; alt++) {\n        look[alt] = new IntervalSet();\n        var lookBusy = new Set();\n        var seeThruPreds = false; // fail to get lookahead upon pred\n        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n              look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n        // Wipe out lookahead for this alternative if we found nothing\n        // or we had a predicate when we !seeThruPreds\n        if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n            look[alt] = null;\n        }\n    }\n    return look;\n};\n\n//*\n// Compute set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n//\n// <p>If {@code ctx} is {@code null} and the end of the rule containing\n// {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n// If {@code ctx} is not {@code null} and the end of the outermost rule is\n// reached, {@link Token//EOF} is added to the result set.</p>\n//\n// @param s the ATN state\n// @param stopState the ATN state to stop at. This can be a\n// {@link BlockEndState} to detect epsilon paths through a closure.\n// @param ctx the complete parser context, or {@code null} if the context\n// should be ignored\n//\n// @return The set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n///\nLL1Analyzer.prototype.LOOK = function(s, stopState, ctx) {\n    var r = new IntervalSet();\n    var seeThruPreds = true; // ignore preds; get all lookahead\n\tctx = ctx || null;\n    var lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n    return r;\n};\n\n//*\n// Compute set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n//\n// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n// rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n// {@code true} and {@code stopState} or the end of the outermost rule is\n// reached, {@link Token//EOF} is added to the result set.</p>\n//\n// @param s the ATN state.\n// @param stopState the ATN state to stop at. This can be a\n// {@link BlockEndState} to detect epsilon paths through a closure.\n// @param ctx The outer context, or {@code null} if the outer context should\n// not be used.\n// @param look The result lookahead set.\n// @param lookBusy A set used for preventing epsilon closures in the ATN\n// from causing a stack overflow. Outside code should pass\n// {@code new Set<ATNConfig>} for this argument.\n// @param calledRuleStack A set used for preventing left recursion in the\n// ATN from causing a stack overflow. Outside code should pass\n// {@code new BitSet()} for this argument.\n// @param seeThruPreds {@code true} to true semantic predicates as\n// implicitly {@code true} and \"see through them\", otherwise {@code false}\n// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n// result if one is encountered.\n// @param addEOF Add {@link Token//EOF} to the result if the end of the\n// outermost context is reached. This parameter has no effect if {@code ctx}\n// is {@code null}.\n///\nLL1Analyzer.prototype._LOOK = function(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n    var c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n    if (lookBusy.contains(c)) {\n        return;\n    }\n    lookBusy.add(c);\n    if (s === stopState) {\n        if (ctx ===null) {\n            look.addOne(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.addOne(Token.EOF);\n            return;\n        }\n    }\n    if (s instanceof RuleStopState ) {\n        if (ctx ===null) {\n            look.addOne(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.addOne(Token.EOF);\n            return;\n        }\n        if (ctx !== PredictionContext.EMPTY) {\n            // run thru all possible stack tops in ctx\n            for(var i=0; i<ctx.length; i++) {\n                var returnState = this.atn.states[ctx.getReturnState(i)];\n                var removed = calledRuleStack.contains(returnState.ruleIndex);\n                try {\n                    calledRuleStack.remove(returnState.ruleIndex);\n                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.add(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n    for(var j=0; j<s.transitions.length; j++) {\n        var t = s.transitions[j];\n        if (t.constructor === RuleTransition) {\n            if (calledRuleStack.contains(t.target.ruleIndex)) {\n                continue;\n            }\n            var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n            try {\n                calledRuleStack.add(t.target.ruleIndex);\n                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.remove(t.target.ruleIndex);\n            }\n        } else if (t instanceof AbstractPredicateTransition ) {\n            if (seeThruPreds) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.addOne(LL1Analyzer.HIT_PRED);\n            }\n        } else if( t.isEpsilon) {\n            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.constructor === WildcardTransition) {\n            look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n        } else {\n            var set = t.label;\n            if (set !== null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                }\n                look.addSet(set);\n            }\n        }\n    }\n};\n\nexports.LL1Analyzer = LL1Analyzer;\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// A lexer is recognizer that draws input symbols from a character stream.\n//  lexer grammars result in a subclass of this object. A Lexer object\n//  uses simplified match() and error recovery mechanisms in the interest of speed.\n\nvar Token = require('./Token').Token;\nvar Recognizer = require('./Recognizer').Recognizer;\nvar CommonTokenFactory = require('./CommonTokenFactory').CommonTokenFactory;\nvar RecognitionException  = require('./error/Errors').RecognitionException;\nvar LexerNoViableAltException = require('./error/Errors').LexerNoViableAltException;\n\nfunction TokenSource() {\n\treturn this;\n}\n\nfunction Lexer(input) {\n\tRecognizer.call(this);\n\tthis._input = input;\n\tthis._factory = CommonTokenFactory.DEFAULT;\n\tthis._tokenFactorySourcePair = [ this, input ];\n\n\tthis._interp = null; // child classes must populate this\n\n\t// The goal of all lexer rules/methods is to create a token object.\n\t// this is an instance variable as multiple rules may collaborate to\n\t// create a single token. nextToken will return this object after\n\t// matching lexer rule(s). If you subclass to allow multiple token\n\t// emissions, then set this to the last token to be matched or\n\t// something nonnull so that the auto token emit mechanism will not\n\t// emit another token.\n\tthis._token = null;\n\n\t// What character index in the stream did the current token start at?\n\t// Needed, for example, to get the text for current token. Set at\n\t// the start of nextToken.\n\tthis._tokenStartCharIndex = -1;\n\n\t// The line on which the first character of the token resides///\n\tthis._tokenStartLine = -1;\n\n\t// The character position of first character within the line///\n\tthis._tokenStartColumn = -1;\n\n\t// Once we see EOF on char stream, next token will be EOF.\n\t// If you have DONE : EOF ; then you see DONE EOF.\n\tthis._hitEOF = false;\n\n\t// The channel number for the current token///\n\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t// The token type for the current token///\n\tthis._type = Token.INVALID_TYPE;\n\n\tthis._modeStack = [];\n\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t// You can set the text for the current token to override what is in\n\t// the input char buffer. Use setText() or can set this instance var.\n\t// /\n\tthis._text = null;\n\n\treturn this;\n}\n\nLexer.prototype = Object.create(Recognizer.prototype);\nLexer.prototype.constructor = Lexer;\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\nLexer.prototype.reset = function() {\n\t// wack Lexer state variables\n\tif (this._input !== null) {\n\t\tthis._input.seek(0); // rewind the input\n\t}\n\tthis._token = null;\n\tthis._type = Token.INVALID_TYPE;\n\tthis._channel = Token.DEFAULT_CHANNEL;\n\tthis._tokenStartCharIndex = -1;\n\tthis._tokenStartColumn = -1;\n\tthis._tokenStartLine = -1;\n\tthis._text = null;\n\n\tthis._hitEOF = false;\n\tthis._mode = Lexer.DEFAULT_MODE;\n\tthis._modeStack = [];\n\n\tthis._interp.reset();\n};\n\n// Return a token from this source; i.e., match a token on the char stream.\nLexer.prototype.nextToken = function() {\n\tif (this._input === null) {\n\t\tthrow \"nextToken requires a non-null input stream.\";\n\t}\n\n\t// Mark start location in char stream so unbuffered streams are\n\t// guaranteed at least have text of current token\n\tvar tokenStartMarker = this._input.mark();\n\ttry {\n\t\twhile (true) {\n\t\t\tif (this._hitEOF) {\n\t\t\t\tthis.emitEOF();\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t\tthis._token = null;\n\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\tthis._text = null;\n\t\t\tvar continueOuter = false;\n\t\t\twhile (true) {\n\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\tvar ttype = Lexer.SKIP;\n\t\t\t\ttry {\n\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t} catch (e) {\n\t\t\t\t    if(e instanceof RecognitionException) {\n                        this.notifyListeners(e); // report error\n                        this.recover(e);\n                    } else {\n                        console.log(e.stack);\n                        throw e;\n                    }\n\t\t\t\t}\n\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t}\n\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\tthis._type = ttype;\n\t\t\t\t}\n\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (continueOuter) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this._token === null) {\n\t\t\t\tthis.emit();\n\t\t\t}\n\t\t\treturn this._token;\n\t\t}\n\t} finally {\n\t\t// make sure we release marker after match or\n\t\t// unbuffered char stream will keep buffering\n\t\tthis._input.release(tokenStartMarker);\n\t}\n};\n\n// Instruct the lexer to skip creating a token for current lexer rule\n// and look for another token. nextToken() knows to keep looking when\n// a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n// if token==null at end of any token rule, it creates one for you\n// and emits it.\n// /\nLexer.prototype.skip = function() {\n\tthis._type = Lexer.SKIP;\n};\n\nLexer.prototype.more = function() {\n\tthis._type = Lexer.MORE;\n};\n\nLexer.prototype.mode = function(m) {\n\tthis._mode = m;\n};\n\nLexer.prototype.pushMode = function(m) {\n\tif (this._interp.debug) {\n\t\tconsole.log(\"pushMode \" + m);\n\t}\n\tthis._modeStack.push(this._mode);\n\tthis.mode(m);\n};\n\nLexer.prototype.popMode = function() {\n\tif (this._modeStack.length === 0) {\n\t\tthrow \"Empty Stack\";\n\t}\n\tif (this._interp.debug) {\n\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t}\n\tthis.mode(this._modeStack.pop());\n\treturn this._mode;\n};\n\n// Set the char stream and reset the lexer\nObject.defineProperty(Lexer.prototype, \"inputStream\", {\n\tget : function() {\n\t\treturn this._input;\n\t},\n\tset : function(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n});\n\nObject.defineProperty(Lexer.prototype, \"sourceName\", {\n\tget : function sourceName() {\n\t\treturn this._input.sourceName;\n\t}\n});\n\n// By default does not support multiple emits per nextToken invocation\n// for efficiency reasons. Subclass and override this method, nextToken,\n// and getToken (to push tokens into a list and pull from that list\n// rather than a single variable as this implementation does).\n// /\nLexer.prototype.emitToken = function(token) {\n\tthis._token = token;\n};\n\n// The standard method called to automatically emit a token at the\n// outermost lexical rule. The token object should point into the\n// char buffer start..stop. If there is a text override in 'text',\n// use that to set the token's text. Override this method to emit\n// custom Token objects or provide a new factory.\n// /\nLexer.prototype.emit = function() {\n\tvar t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\tthis._tokenStartColumn);\n\tthis.emitToken(t);\n\treturn t;\n};\n\nLexer.prototype.emitEOF = function() {\n\tvar cpos = this.column;\n\tvar lpos = this.line;\n\tvar eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\tthis._input.index - 1, lpos, cpos);\n\tthis.emitToken(eof);\n\treturn eof;\n};\n\nObject.defineProperty(Lexer.prototype, \"type\", {\n\tget : function() {\n\t\treturn this.type;\n\t},\n\tset : function(type) {\n\t\tthis._type = type;\n\t}\n});\n\nObject.defineProperty(Lexer.prototype, \"line\", {\n\tget : function() {\n\t\treturn this._interp.line;\n\t},\n\tset : function(line) {\n\t\tthis._interp.line = line;\n\t}\n});\n\nObject.defineProperty(Lexer.prototype, \"column\", {\n\tget : function() {\n\t\treturn this._interp.column;\n\t},\n\tset : function(column) {\n\t\tthis._interp.column = column;\n\t}\n});\n\n\n// What is the index of the current character of lookahead?///\nLexer.prototype.getCharIndex = function() {\n\treturn this._input.index;\n};\n\n// Return the text matched so far for the current token or any text override.\n//Set the complete text of this token; it wipes any previous changes to the text.\nObject.defineProperty(Lexer.prototype, \"text\", {\n\tget : function() {\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t},\n\tset : function(text) {\n\t\tthis._text = text;\n\t}\n});\n// Return a list of all Token objects in input char stream.\n// Forces load of all tokens. Does not include EOF token.\n// /\nLexer.prototype.getAllTokens = function() {\n\tvar tokens = [];\n\tvar t = this.nextToken();\n\twhile (t.type !== Token.EOF) {\n\t\ttokens.push(t);\n\t\tt = this.nextToken();\n\t}\n\treturn tokens;\n};\n\nLexer.prototype.notifyListeners = function(e) {\n\tvar start = this._tokenStartCharIndex;\n\tvar stop = this._input.index;\n\tvar text = this._input.getText(start, stop);\n\tvar msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\tvar listener = this.getErrorListenerDispatch();\n\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\tthis._tokenStartColumn, msg, e);\n};\n\nLexer.prototype.getErrorDisplay = function(s) {\n\tvar d = [];\n\tfor (var i = 0; i < s.length; i++) {\n\t\td.push(s[i]);\n\t}\n\treturn d.join('');\n};\n\nLexer.prototype.getErrorDisplayForChar = function(c) {\n\tif (c.charCodeAt(0) === Token.EOF) {\n\t\treturn \"<EOF>\";\n\t} else if (c === '\\n') {\n\t\treturn \"\\\\n\";\n\t} else if (c === '\\t') {\n\t\treturn \"\\\\t\";\n\t} else if (c === '\\r') {\n\t\treturn \"\\\\r\";\n\t} else {\n\t\treturn c;\n\t}\n};\n\nLexer.prototype.getCharErrorDisplay = function(c) {\n\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n};\n\n// Lexers can normally match any char in it's vocabulary after matching\n// a token, so do the easy thing and just kill a character and hope\n// it all works out. You can instead use the rule invocation stack\n// to do sophisticated error recovery if you are in a fragment rule.\n// /\nLexer.prototype.recover = function(re) {\n\tif (this._input.LA(1) !== Token.EOF) {\n\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t// skip a char and try again\n\t\t\tthis._interp.consume(this._input);\n\t\t} else {\n\t\t\t// TODO: Do we lose character or line position information?\n\t\t\tthis._input.consume();\n\t\t}\n\t}\n};\n\nexports.Lexer = Lexer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar Token = require('./Token').Token;\nvar ParseTreeListener = require('./tree/Tree').ParseTreeListener;\nvar Recognizer = require('./Recognizer').Recognizer;\nvar DefaultErrorStrategy = require('./error/ErrorStrategy').DefaultErrorStrategy;\nvar ATNDeserializer = require('./atn/ATNDeserializer').ATNDeserializer;\nvar ATNDeserializationOptions = require('./atn/ATNDeserializationOptions').ATNDeserializationOptions;\nvar TerminalNode = require('./tree/Tree').TerminalNode;\nvar ErrorNode = require('./tree/Tree').ErrorNode;\n\nfunction TraceListener(parser) {\n\tParseTreeListener.call(this);\n    this.parser = parser;\n\treturn this;\n}\n\nTraceListener.prototype = Object.create(ParseTreeListener.prototype);\nTraceListener.prototype.constructor = TraceListener;\n\nTraceListener.prototype.enterEveryRule = function(ctx) {\n\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n};\n\nTraceListener.prototype.visitTerminal = function( node) {\n\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n};\n\nTraceListener.prototype.exitEveryRule = function(ctx) {\n\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n};\n\n// this is all the parsing support code essentially; most of it is error\n// recovery stuff.//\nfunction Parser(input) {\n\tRecognizer.call(this);\n\t// The input stream.\n\tthis._input = null;\n\t// The error handling strategy for the parser. The default value is a new\n\t// instance of {@link DefaultErrorStrategy}.\n\tthis._errHandler = new DefaultErrorStrategy();\n\tthis._precedenceStack = [];\n\tthis._precedenceStack.push(0);\n\t// The {@link ParserRuleContext} object for the currently executing rule.\n\t// this is always non-null during the parsing process.\n\tthis._ctx = null;\n\t// Specifies whether or not the parser should construct a parse tree during\n\t// the parsing process. The default value is {@code true}.\n\tthis.buildParseTrees = true;\n\t// When {@link //setTrace}{@code (true)} is called, a reference to the\n\t// {@link TraceListener} is stored here so it can be easily removed in a\n\t// later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t// implemented as a parser listener so this field is not directly used by\n\t// other parser methods.\n\tthis._tracer = null;\n\t// The list of {@link ParseTreeListener} listeners registered to receive\n\t// events during the parse.\n\tthis._parseListeners = null;\n\t// The number of syntax errors reported during parsing. this value is\n\t// incremented each time {@link //notifyErrorListeners} is called.\n\tthis._syntaxErrors = 0;\n\tthis.setInputStream(input);\n\treturn this;\n}\n\nParser.prototype = Object.create(Recognizer.prototype);\nParser.prototype.contructor = Parser;\n\n// this field maps from the serialized ATN string to the deserialized {@link\n// ATN} with\n// bypass alternatives.\n//\n// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n//\nParser.bypassAltsAtnCache = {};\n\n// reset the parser's state//\nParser.prototype.reset = function() {\n\tif (this._input !== null) {\n\t\tthis._input.seek(0);\n\t}\n\tthis._errHandler.reset(this);\n\tthis._ctx = null;\n\tthis._syntaxErrors = 0;\n\tthis.setTrace(false);\n\tthis._precedenceStack = [];\n\tthis._precedenceStack.push(0);\n\tif (this._interp !== null) {\n\t\tthis._interp.reset();\n\t}\n};\n\n// Match current input symbol against {@code ttype}. If the symbol type\n// matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n// called to complete the match process.\n//\n// <p>If the symbol type does not match,\n// {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n// strategy to attempt recovery. If {@link //getBuildParseTree} is\n// {@code true} and the token index of the symbol returned by\n// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n//\n// @param ttype the token type to match\n// @return the matched symbol\n// @throws RecognitionException if the current input symbol did not match\n// {@code ttype} and the error strategy could not recover from the\n// mismatched symbol\n\nParser.prototype.match = function(ttype) {\n\tvar t = this.getCurrentToken();\n\tif (t.type === ttype) {\n\t\tthis._errHandler.reportMatch(this);\n\t\tthis.consume();\n\t} else {\n\t\tt = this._errHandler.recoverInline(this);\n\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t// we must have conjured up a new token during single token\n\t\t\t// insertion\n\t\t\t// if it's not the current symbol\n\t\t\tthis._ctx.addErrorNode(t);\n\t\t}\n\t}\n\treturn t;\n};\n// Match current input symbol as a wildcard. If the symbol type matches\n// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n// and {@link //consume} are called to complete the match process.\n//\n// <p>If the symbol type does not match,\n// {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n// strategy to attempt recovery. If {@link //getBuildParseTree} is\n// {@code true} and the token index of the symbol returned by\n// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n//\n// @return the matched symbol\n// @throws RecognitionException if the current input symbol did not match\n// a wildcard and the error strategy could not recover from the mismatched\n// symbol\n\nParser.prototype.matchWildcard = function() {\n\tvar t = this.getCurrentToken();\n\tif (t.type > 0) {\n\t\tthis._errHandler.reportMatch(this);\n\t\tthis.consume();\n\t} else {\n\t\tt = this._errHandler.recoverInline(this);\n\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t// we must have conjured up a new token during single token\n\t\t\t// insertion\n\t\t\t// if it's not the current symbol\n\t\t\tthis._ctx.addErrorNode(t);\n\t\t}\n\t}\n\treturn t;\n};\n\nParser.prototype.getParseListeners = function() {\n\treturn this._parseListeners || [];\n};\n\n// Registers {@code listener} to receive events during the parsing process.\n//\n// <p>To support output-preserving grammar transformations (including but not\n// limited to left-recursion removal, automated left-factoring, and\n// optimized code generation), calls to listener methods during the parse\n// may differ substantially from calls made by\n// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n// particular, rule entry and exit events may occur in a different order\n// during the parse than after the parser. In addition, calls to certain\n// rule entry methods may be omitted.</p>\n//\n// <p>With the following specific exceptions, calls to listener events are\n// <em>deterministic</em>, i.e. for identical input the calls to listener\n// methods will be the same.</p>\n//\n// <ul>\n// <li>Alterations to the grammar used to generate code may change the\n// behavior of the listener calls.</li>\n// <li>Alterations to the command line options passed to ANTLR 4 when\n// generating the parser may change the behavior of the listener calls.</li>\n// <li>Changing the version of the ANTLR Tool used to generate the parser\n// may change the behavior of the listener calls.</li>\n// </ul>\n//\n// @param listener the listener to add\n//\n// @throws NullPointerException if {@code} listener is {@code null}\n//\nParser.prototype.addParseListener = function(listener) {\n\tif (listener === null) {\n\t\tthrow \"listener\";\n\t}\n\tif (this._parseListeners === null) {\n\t\tthis._parseListeners = [];\n\t}\n\tthis._parseListeners.push(listener);\n};\n\n//\n// Remove {@code listener} from the list of parse listeners.\n//\n// <p>If {@code listener} is {@code null} or has not been added as a parse\n// listener, this method does nothing.</p>\n// @param listener the listener to remove\n//\nParser.prototype.removeParseListener = function(listener) {\n\tif (this._parseListeners !== null) {\n\t\tvar idx = this._parseListeners.indexOf(listener);\n\t\tif (idx >= 0) {\n\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t}\n\t\tif (this._parseListeners.length === 0) {\n\t\t\tthis._parseListeners = null;\n\t\t}\n\t}\n};\n\n// Remove all parse listeners.\nParser.prototype.removeParseListeners = function() {\n\tthis._parseListeners = null;\n};\n\n// Notify any parse listeners of an enter rule event.\nParser.prototype.triggerEnterRuleEvent = function() {\n\tif (this._parseListeners !== null) {\n        var ctx = this._ctx;\n\t\tthis._parseListeners.map(function(listener) {\n\t\t\tlistener.enterEveryRule(ctx);\n\t\t\tctx.enterRule(listener);\n\t\t});\n\t}\n};\n\n//\n// Notify any parse listeners of an exit rule event.\n//\n// @see //addParseListener\n//\nParser.prototype.triggerExitRuleEvent = function() {\n\tif (this._parseListeners !== null) {\n\t\t// reverse order walk of listeners\n        var ctx = this._ctx;\n\t\tthis._parseListeners.slice(0).reverse().map(function(listener) {\n\t\t\tctx.exitRule(listener);\n\t\t\tlistener.exitEveryRule(ctx);\n\t\t});\n\t}\n};\n\nParser.prototype.getTokenFactory = function() {\n\treturn this._input.tokenSource._factory;\n};\n\n// Tell our token source and error strategy about a new way to create tokens.//\nParser.prototype.setTokenFactory = function(factory) {\n\tthis._input.tokenSource._factory = factory;\n};\n\n// The ATN with bypass alternatives is expensive to create so we create it\n// lazily.\n//\n// @throws UnsupportedOperationException if the current parser does not\n// implement the {@link //getSerializedATN()} method.\n//\nParser.prototype.getATNWithBypassAlts = function() {\n\tvar serializedAtn = this.getSerializedATN();\n\tif (serializedAtn === null) {\n\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t}\n\tvar result = this.bypassAltsAtnCache[serializedAtn];\n\tif (result === null) {\n\t\tvar deserializationOptions = new ATNDeserializationOptions();\n\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t.deserialize(serializedAtn);\n\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t}\n\treturn result;\n};\n\n// The preferred method of getting a tree pattern. For example, here's a\n// sample use:\n//\n// <pre>\n// ParseTree t = parser.expr();\n// ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n// MyParser.RULE_expr);\n// ParseTreeMatch m = p.match(t);\n// String id = m.get(\"ID\");\n// </pre>\n\nvar Lexer = require('./Lexer').Lexer;\n\nParser.prototype.compileParseTreePattern = function(pattern, patternRuleIndex, lexer) {\n\tlexer = lexer || null;\n\tif (lexer === null) {\n\t\tif (this.getTokenStream() !== null) {\n\t\t\tvar tokenSource = this.getTokenStream().tokenSource;\n\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\tlexer = tokenSource;\n\t\t\t}\n\t\t}\n\t}\n\tif (lexer === null) {\n\t\tthrow \"Parser can't discover a lexer to use\";\n\t}\n\tvar m = new ParseTreePatternMatcher(lexer, this);\n\treturn m.compile(pattern, patternRuleIndex);\n};\n\nParser.prototype.getInputStream = function() {\n\treturn this.getTokenStream();\n};\n\nParser.prototype.setInputStream = function(input) {\n\tthis.setTokenStream(input);\n};\n\nParser.prototype.getTokenStream = function() {\n\treturn this._input;\n};\n\n// Set the token stream and reset the parser.//\nParser.prototype.setTokenStream = function(input) {\n\tthis._input = null;\n\tthis.reset();\n\tthis._input = input;\n};\n\n// Match needs to return the current input symbol, which gets put\n// into the label for the associated token ref; e.g., x=ID.\n//\nParser.prototype.getCurrentToken = function() {\n\treturn this._input.LT(1);\n};\n\nParser.prototype.notifyErrorListeners = function(msg, offendingToken, err) {\n\toffendingToken = offendingToken || null;\n\terr = err || null;\n\tif (offendingToken === null) {\n\t\toffendingToken = this.getCurrentToken();\n\t}\n\tthis._syntaxErrors += 1;\n\tvar line = offendingToken.line;\n\tvar column = offendingToken.column;\n\tvar listener = this.getErrorListenerDispatch();\n\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n};\n\n//\n// Consume and return the {@linkplain //getCurrentToken current symbol}.\n//\n// <p>E.g., given the following input with {@code A} being the current\n// lookahead symbol, this function moves the cursor to {@code B} and returns\n// {@code A}.</p>\n//\n// <pre>\n// A B\n// ^\n// </pre>\n//\n// If the parser is not in error recovery mode, the consumed symbol is added\n// to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n// {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n// If the parser <em>is</em> in error recovery mode, the consumed symbol is\n// added to the parse tree using\n// {@link ParserRuleContext//addErrorNode(Token)}, and\n// {@link ParseTreeListener//visitErrorNode} is called on any parse\n// listeners.\n//\nParser.prototype.consume = function() {\n\tvar o = this.getCurrentToken();\n\tif (o.type !== Token.EOF) {\n\t\tthis.getInputStream().consume();\n\t}\n\tvar hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\tif (this.buildParseTrees || hasListener) {\n\t\tvar node;\n\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t} else {\n\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t}\n        node.invokingState = this.state;\n\t\tif (hasListener) {\n\t\t\tthis._parseListeners.map(function(listener) {\n\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn o;\n};\n\nParser.prototype.addContextToParseTree = function() {\n\t// add current context to parent if we have a parent\n\tif (this._ctx.parentCtx !== null) {\n\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t}\n};\n\n// Always called by generated parsers upon entry to a rule. Access field\n// {@link //_ctx} get the current context.\n\nParser.prototype.enterRule = function(localctx, state, ruleIndex) {\n\tthis.state = state;\n\tthis._ctx = localctx;\n\tthis._ctx.start = this._input.LT(1);\n\tif (this.buildParseTrees) {\n\t\tthis.addContextToParseTree();\n\t}\n\tif (this._parseListeners !== null) {\n\t\tthis.triggerEnterRuleEvent();\n\t}\n};\n\nParser.prototype.exitRule = function() {\n\tthis._ctx.stop = this._input.LT(-1);\n\t// trigger event on _ctx, before it reverts to parent\n\tif (this._parseListeners !== null) {\n\t\tthis.triggerExitRuleEvent();\n\t}\n\tthis.state = this._ctx.invokingState;\n\tthis._ctx = this._ctx.parentCtx;\n};\n\nParser.prototype.enterOuterAlt = function(localctx, altNum) {\n   \tlocalctx.setAltNumber(altNum);\n\t// if we have new localctx, make sure we replace existing ctx\n\t// that is previous child of parse tree\n\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t}\n\t}\n\tthis._ctx = localctx;\n};\n\n// Get the precedence level for the top-most precedence rule.\n//\n// @return The precedence level for the top-most precedence rule, or -1 if\n// the parser context is not nested within a precedence rule.\n\nParser.prototype.getPrecedence = function() {\n\tif (this._precedenceStack.length === 0) {\n\t\treturn -1;\n\t} else {\n\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t}\n};\n\nParser.prototype.enterRecursionRule = function(localctx, state, ruleIndex,\n\t\tprecedence) {\n\tthis.state = state;\n\tthis._precedenceStack.push(precedence);\n\tthis._ctx = localctx;\n\tthis._ctx.start = this._input.LT(1);\n\tif (this._parseListeners !== null) {\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for\n\t\t\t\t\t\t\t\t\t\t// left-recursive rules\n\t}\n};\n\n//\n// Like {@link //enterRule} but for recursive rules.\n\nParser.prototype.pushNewRecursionContext = function(localctx, state, ruleIndex) {\n\tvar previous = this._ctx;\n\tprevious.parentCtx = localctx;\n\tprevious.invokingState = state;\n\tprevious.stop = this._input.LT(-1);\n\n\tthis._ctx = localctx;\n\tthis._ctx.start = previous.start;\n\tif (this.buildParseTrees) {\n\t\tthis._ctx.addChild(previous);\n\t}\n\tif (this._parseListeners !== null) {\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for\n\t\t\t\t\t\t\t\t\t\t// left-recursive rules\n\t}\n};\n\nParser.prototype.unrollRecursionContexts = function(parentCtx) {\n\tthis._precedenceStack.pop();\n\tthis._ctx.stop = this._input.LT(-1);\n\tvar retCtx = this._ctx; // save current ctx (return value)\n\t// unroll so _ctx is as it was before call to recursive method\n\tif (this._parseListeners !== null) {\n\t\twhile (this._ctx !== parentCtx) {\n\t\t\tthis.triggerExitRuleEvent();\n\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t}\n\t} else {\n\t\tthis._ctx = parentCtx;\n\t}\n\t// hook into tree\n\tretCtx.parentCtx = parentCtx;\n\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t// add return ctx into invoking rule's tree\n\t\tparentCtx.addChild(retCtx);\n\t}\n};\n\nParser.prototype.getInvokingContext = function(ruleIndex) {\n\tvar ctx = this._ctx;\n\twhile (ctx !== null) {\n\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\treturn ctx;\n\t\t}\n\t\tctx = ctx.parentCtx;\n\t}\n\treturn null;\n};\n\nParser.prototype.precpred = function(localctx, precedence) {\n\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n};\n\nParser.prototype.inContext = function(context) {\n\t// TODO: useful in parser?\n\treturn false;\n};\n\n//\n// Checks whether or not {@code symbol} can follow the current state in the\n// ATN. The behavior of this method is equivalent to the following, but is\n// implemented such that the complete context-sensitive follow set does not\n// need to be explicitly constructed.\n//\n// <pre>\n// return getExpectedTokens().contains(symbol);\n// </pre>\n//\n// @param symbol the symbol type to check\n// @return {@code true} if {@code symbol} can follow the current state in\n// the ATN, otherwise {@code false}.\n\nParser.prototype.isExpectedToken = function(symbol) {\n\tvar atn = this._interp.atn;\n\tvar ctx = this._ctx;\n\tvar s = atn.states[this.state];\n\tvar following = atn.nextTokens(s);\n\tif (following.contains(symbol)) {\n\t\treturn true;\n\t}\n\tif (!following.contains(Token.EPSILON)) {\n\t\treturn false;\n\t}\n\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\tvar invokingState = atn.states[ctx.invokingState];\n\t\tvar rt = invokingState.transitions[0];\n\t\tfollowing = atn.nextTokens(rt.followState);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tctx = ctx.parentCtx;\n\t}\n\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n// Computes the set of input symbols which could follow the current parser\n// state and context, as given by {@link //getState} and {@link //getContext},\n// respectively.\n//\n// @see ATN//getExpectedTokens(int, RuleContext)\n//\nParser.prototype.getExpectedTokens = function() {\n\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n};\n\nParser.prototype.getExpectedTokensWithinCurrentRule = function() {\n\tvar atn = this._interp.atn;\n\tvar s = atn.states[this.state];\n\treturn atn.nextTokens(s);\n};\n\n// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.//\nParser.prototype.getRuleIndex = function(ruleName) {\n\tvar ruleIndex = this.getRuleIndexMap()[ruleName];\n\tif (ruleIndex !== null) {\n\t\treturn ruleIndex;\n\t} else {\n\t\treturn -1;\n\t}\n};\n\n// Return List&lt;String&gt; of the rule names in your parser instance\n// leading up to a call to the current rule. You could override if\n// you want more details such as the file/line info of where\n// in the ATN a rule is invoked.\n//\n// this is very useful for error messages.\n//\nParser.prototype.getRuleInvocationStack = function(p) {\n\tp = p || null;\n\tif (p === null) {\n\t\tp = this._ctx;\n\t}\n\tvar stack = [];\n\twhile (p !== null) {\n\t\t// compute what follows who invoked us\n\t\tvar ruleIndex = p.ruleIndex;\n\t\tif (ruleIndex < 0) {\n\t\t\tstack.push(\"n/a\");\n\t\t} else {\n\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t}\n\t\tp = p.parentCtx;\n\t}\n\treturn stack;\n};\n\n// For debugging and other purposes.//\nParser.prototype.getDFAStrings = function() {\n\treturn this._interp.decisionToDFA.toString();\n};\n// For debugging and other purposes.//\nParser.prototype.dumpDFA = function() {\n\tvar seenOne = false;\n\tfor (var i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\tvar dfa = this._interp.decisionToDFA[i];\n\t\tif (dfa.states.length > 0) {\n\t\t\tif (seenOne) {\n\t\t\t\tconsole.log();\n\t\t\t}\n\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\tseenOne = true;\n\t\t}\n\t}\n};\n\n/*\n\"\t\t\tprinter = function() {\\r\\n\" +\n\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\"\t\t\t};\\r\\n\" +\n*/\n\nParser.prototype.getSourceName = function() {\n\treturn this._input.sourceName;\n};\n\n// During a parse is sometimes useful to listen in on the rule entry and exit\n// events as well as token matches. this is for quick and dirty debugging.\n//\nParser.prototype.setTrace = function(trace) {\n\tif (!trace) {\n\t\tthis.removeParseListener(this._tracer);\n\t\tthis._tracer = null;\n\t} else {\n\t\tif (this._tracer !== null) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t}\n\t\tthis._tracer = new TraceListener(this);\n\t\tthis.addParseListener(this._tracer);\n\t}\n};\n\nexports.Parser = Parser;","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n//* A rule invocation record for parsing.\n//\n//  Contains all of the information about the current rule not stored in the\n//  RuleContext. It handles parse tree children list, Any ATN state\n//  tracing, and the default values available for rule indications:\n//  start, stop, rule index, current alt number, current\n//  ATN state.\n//\n//  Subclasses made for each rule and grammar track the parameters,\n//  return values, locals, and labels specific to that rule. These\n//  are the objects that are returned from rules.\n//\n//  Note text is not an actual field of a rule return value; it is computed\n//  from start and stop using the input stream's toString() method.  I\n//  could add a ctor to this so that we can pass in and store the input\n//  stream, but I'm not sure we want to do that.  It would seem to be undefined\n//  to get the .text property anyway if the rule matches tokens from multiple\n//  input streams.\n//\n//  I do not use getters for fields of objects that are used simply to\n//  group values such as this aggregate.  The getters/setters are there to\n//  satisfy the superclass interface.\n\nvar RuleContext = require('./RuleContext').RuleContext;\nvar Tree = require('./tree/Tree');\nvar INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nvar TerminalNode = Tree.TerminalNode;\nvar TerminalNodeImpl = Tree.TerminalNodeImpl;\nvar ErrorNodeImpl = Tree.ErrorNodeImpl;\nvar Interval = require(\"./IntervalSet\").Interval;\n\nfunction ParserRuleContext(parent, invokingStateNumber) {\n\tparent = parent || null;\n\tinvokingStateNumber = invokingStateNumber || null;\n\tRuleContext.call(this, parent, invokingStateNumber);\n\tthis.ruleIndex = -1;\n    // * If we are debugging or building a parse tree for a visitor,\n    // we need to track all of the tokens and rule invocations associated\n    // with this rule's context. This is empty for parsing w/o tree constr.\n    // operation because we don't the need to track the details about\n    // how we parse this rule.\n    // /\n    this.children = null;\n    this.start = null;\n    this.stop = null;\n    // The exception that forced this rule to return. If the rule successfully\n    // completed, this is {@code null}.\n    this.exception = null;\n}\n\nParserRuleContext.prototype = Object.create(RuleContext.prototype);\nParserRuleContext.prototype.constructor = ParserRuleContext;\n\n// * COPY a ctx (I'm deliberately not using copy constructor)///\nParserRuleContext.prototype.copyFrom = function(ctx) {\n    // from RuleContext\n    this.parentCtx = ctx.parentCtx;\n    this.invokingState = ctx.invokingState;\n    this.children = null;\n    this.start = ctx.start;\n    this.stop = ctx.stop;\n    // copy any error nodes to alt label node\n    if(ctx.children) {\n        this.children = [];\n        // reset parent pointer for any error nodes\n    \tctx.children.map(function(child) {\n    \t\tif (child instanceof ErrorNodeImpl) {\n                this.children.push(child);\n                child.parentCtx = this;\n            }\n\t\t}, this);\n\t}\n};\n\n// Double dispatch methods for listeners\nParserRuleContext.prototype.enterRule = function(listener) {\n};\n\nParserRuleContext.prototype.exitRule = function(listener) {\n};\n\n// * Does not set parent link; other add methods do that///\nParserRuleContext.prototype.addChild = function(child) {\n    if (this.children === null) {\n        this.children = [];\n    }\n    this.children.push(child);\n    return child;\n};\n\n// * Used by enterOuterAlt to toss out a RuleContext previously added as\n// we entered a rule. If we have // label, we will need to remove\n// generic ruleContext object.\n// /\nParserRuleContext.prototype.removeLastChild = function() {\n    if (this.children !== null) {\n        this.children.pop();\n    }\n};\n\nParserRuleContext.prototype.addTokenNode = function(token) {\n    var node = new TerminalNodeImpl(token);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n};\n\nParserRuleContext.prototype.addErrorNode = function(badToken) {\n    var node = new ErrorNodeImpl(badToken);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n};\n\nParserRuleContext.prototype.getChild = function(i, type) {\n\ttype = type || null;\n\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\treturn null;\n\t}\n\tif (type === null) {\n\t\treturn this.children[i];\n\t} else {\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif(child instanceof type) {\n\t\t\t\tif(i===0) {\n\t\t\t\t\treturn child;\n\t\t\t\t} else {\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n    }\n};\n\n\nParserRuleContext.prototype.getToken = function(ttype, i) {\n\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\treturn null;\n\t}\n\tfor(var j=0; j<this.children.length; j++) {\n\t\tvar child = this.children[j];\n\t\tif (child instanceof TerminalNode) {\n\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\tif(i===0) {\n\t\t\t\t\treturn child;\n\t\t\t\t} else {\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t}\n        }\n\t}\n    return null;\n};\n\nParserRuleContext.prototype.getTokens = function(ttype ) {\n    if (this.children=== null) {\n        return [];\n    } else {\n\t\tvar tokens = [];\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\ttokens.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n    }\n};\n\nParserRuleContext.prototype.getTypedRuleContext = function(ctxType, i) {\n    return this.getChild(i, ctxType);\n};\n\nParserRuleContext.prototype.getTypedRuleContexts = function(ctxType) {\n    if (this.children=== null) {\n        return [];\n    } else {\n\t\tvar contexts = [];\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif (child instanceof ctxType) {\n\t\t\t\tcontexts.push(child);\n\t\t\t}\n\t\t}\n\t\treturn contexts;\n\t}\n};\n\nParserRuleContext.prototype.getChildCount = function() {\n\tif (this.children=== null) {\n\t\treturn 0;\n\t} else {\n\t\treturn this.children.length;\n\t}\n};\n\nParserRuleContext.prototype.getSourceInterval = function() {\n    if( this.start === null || this.stop === null) {\n        return INVALID_INTERVAL;\n    } else {\n        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n    }\n};\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nfunction InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n\tParserRuleContext.call(parent, invokingStateNumber);\n    this.ruleIndex = ruleIndex;\n    return this;\n}\n\nInterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);\nInterpreterRuleContext.prototype.constructor = InterpreterRuleContext;\n\nexports.ParserRuleContext = ParserRuleContext;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\nvar RuleContext = require('./RuleContext').RuleContext;\nvar Hash = require('./Utils').Hash;\n\nfunction PredictionContext(cachedHashCode) {\n\tthis.cachedHashCode = cachedHashCode;\n}\n\n// Represents {@code $} in local context prediction, which means wildcard.\n// {@code//+x =//}.\n// /\nPredictionContext.EMPTY = null;\n\n// Represents {@code $} in an array in full context mode, when {@code $}\n// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n// {@code $} = {@link //EMPTY_RETURN_STATE}.\n// /\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n// Stores the computed hash code of this {@link PredictionContext}. The hash\n// code is computed in parts to match the following reference algorithm.\n//\n// <pre>\n// private int referenceHashCode() {\n// int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n// //INITIAL_HASH});\n//\n// for (int i = 0; i &lt; {@link //size()}; i++) {\n// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n// getParent}(i));\n// }\n//\n// for (int i = 0; i &lt; {@link //size()}; i++) {\n// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n// //getReturnState getReturnState}(i));\n// }\n//\n// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n// //size()});\n// return hash;\n// }\n// </pre>\n// /\n\n// This means only the {@link //EMPTY} context is in set.\nPredictionContext.prototype.isEmpty = function() {\n\treturn this === PredictionContext.EMPTY;\n};\n\nPredictionContext.prototype.hasEmptyPath = function() {\n\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n};\n\nPredictionContext.prototype.hashCode = function() {\n\treturn this.cachedHashCode;\n};\n\n\nPredictionContext.prototype.updateHashCode = function(hash) {\n    hash.update(this.cachedHashCode);\n};\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n// Used to cache {@link PredictionContext} objects. Its used for the shared\n// context cash associated with contexts in DFA states. This cache\n// can be used for both lexers and parsers.\n\nfunction PredictionContextCache() {\n\tthis.cache = {};\n\treturn this;\n}\n\n// Add a context to the cache and return it. If the context already exists,\n// return that one instead and do not add a new context to the cache.\n// Protect shared cache from unsafe thread access.\n//\nPredictionContextCache.prototype.add = function(ctx) {\n\tif (ctx === PredictionContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\tvar existing = this.cache[ctx] || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\tthis.cache[ctx] = ctx;\n\treturn ctx;\n};\n\nPredictionContextCache.prototype.get = function(ctx) {\n\treturn this.cache[ctx] || null;\n};\n\nObject.defineProperty(PredictionContextCache.prototype, \"length\", {\n\tget : function() {\n\t\treturn this.cache.length;\n\t}\n});\n\nfunction SingletonPredictionContext(parent, returnState) {\n\tvar hashCode = 0;\n\tif(parent !== null) {\n\t\tvar hash = new Hash();\n\t\thash.update(parent, returnState);\n        hashCode = hash.finish();\n\t}\n\tPredictionContext.call(this, hashCode);\n\tthis.parentCtx = parent;\n\tthis.returnState = returnState;\n}\n\nSingletonPredictionContext.prototype = Object.create(PredictionContext.prototype);\nSingletonPredictionContext.prototype.contructor = SingletonPredictionContext;\n\nSingletonPredictionContext.create = function(parent, returnState) {\n\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t// someone can pass in the bits of an array ctx that mean $\n\t\treturn PredictionContext.EMPTY;\n\t} else {\n\t\treturn new SingletonPredictionContext(parent, returnState);\n\t}\n};\n\nObject.defineProperty(SingletonPredictionContext.prototype, \"length\", {\n\tget : function() {\n\t\treturn 1;\n\t}\n});\n\nSingletonPredictionContext.prototype.getParent = function(index) {\n\treturn this.parentCtx;\n};\n\nSingletonPredictionContext.prototype.getReturnState = function(index) {\n\treturn this.returnState;\n};\n\nSingletonPredictionContext.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\treturn false;\n\t} else if (this.hashCode() !== other.hashCode()) {\n\t\treturn false; // can't be same if hash is different\n\t} else {\n\t\tif(this.returnState !== other.returnState)\n            return false;\n        else if(this.parentCtx==null)\n            return other.parentCtx==null\n\t\telse\n            return this.parentCtx.equals(other.parentCtx);\n\t}\n};\n\nSingletonPredictionContext.prototype.toString = function() {\n\tvar up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\tif (up.length === 0) {\n\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\treturn \"$\";\n\t\t} else {\n\t\t\treturn \"\" + this.returnState;\n\t\t}\n\t} else {\n\t\treturn \"\" + this.returnState + \" \" + up;\n\t}\n};\n\nfunction EmptyPredictionContext() {\n\tSingletonPredictionContext.call(this, null, PredictionContext.EMPTY_RETURN_STATE);\n\treturn this;\n}\n\nEmptyPredictionContext.prototype = Object.create(SingletonPredictionContext.prototype);\nEmptyPredictionContext.prototype.constructor = EmptyPredictionContext;\n\nEmptyPredictionContext.prototype.isEmpty = function() {\n\treturn true;\n};\n\nEmptyPredictionContext.prototype.getParent = function(index) {\n\treturn null;\n};\n\nEmptyPredictionContext.prototype.getReturnState = function(index) {\n\treturn this.returnState;\n};\n\nEmptyPredictionContext.prototype.equals = function(other) {\n\treturn this === other;\n};\n\nEmptyPredictionContext.prototype.toString = function() {\n\treturn \"$\";\n};\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nfunction ArrayPredictionContext(parents, returnStates) {\n\t// Parent can be null only if full ctx mode and we make an array\n\t// from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t// null parent and\n\t// returnState == {@link //EMPTY_RETURN_STATE}.\n\tvar h = new Hash();\n\th.update(parents, returnStates);\n\tvar hashCode = h.finish();\n\tPredictionContext.call(this, hashCode);\n\tthis.parents = parents;\n\tthis.returnStates = returnStates;\n\treturn this;\n}\n\nArrayPredictionContext.prototype = Object.create(PredictionContext.prototype);\nArrayPredictionContext.prototype.constructor = ArrayPredictionContext;\n\nArrayPredictionContext.prototype.isEmpty = function() {\n\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t// don't need to verify that size==1\n\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n};\n\nObject.defineProperty(ArrayPredictionContext.prototype, \"length\", {\n\tget : function() {\n\t\treturn this.returnStates.length;\n\t}\n});\n\nArrayPredictionContext.prototype.getParent = function(index) {\n\treturn this.parents[index];\n};\n\nArrayPredictionContext.prototype.getReturnState = function(index) {\n\treturn this.returnStates[index];\n};\n\nArrayPredictionContext.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\treturn false;\n\t} else if (this.hashCode() !== other.hashCode()) {\n\t\treturn false; // can't be same if hash is different\n\t} else {\n\t\treturn this.returnStates === other.returnStates &&\n\t\t\t\tthis.parents === other.parents;\n\t}\n};\n\nArrayPredictionContext.prototype.toString = function() {\n\tif (this.isEmpty()) {\n\t\treturn \"[]\";\n\t} else {\n\t\tvar s = \"[\";\n\t\tfor (var i = 0; i < this.returnStates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\ts = s + \"$\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = s + this.returnStates[i];\n\t\t\tif (this.parents[i] !== null) {\n\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t} else {\n\t\t\t\ts = s + \"null\";\n\t\t\t}\n\t\t}\n\t\treturn s + \"]\";\n\t}\n};\n\n// Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n// Return {@link //EMPTY} if {@code outerContext} is empty or null.\n// /\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tvar parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tvar state = atn.states[outerContext.invokingState];\n\tvar transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tvar s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n//\n// Merge two {@link SingletonPredictionContext} instances.\n//\n// <p>Stack tops equal, parents merge is same; return left graph.<br>\n// <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n// type=\"image/svg+xml\"/></p>\n//\n// <p>Same stack top, parents differ; merge parents giving array node, then\n// remainders of those graphs. A new root node is created to point to the\n// merged parents.<br>\n// <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n// type=\"image/svg+xml\"/></p>\n//\n// <p>Different stack tops pointing to same parent. Make array node for the\n// root where both element in the root point to the same (original)\n// parent.<br>\n// <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n// type=\"image/svg+xml\"/></p>\n//\n// <p>Different stack tops pointing to different parents. Make array node for\n// the root where each element points to the corresponding original\n// parent.<br>\n// <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n// type=\"image/svg+xml\"/></p>\n//\n// @param a the first {@link SingletonPredictionContext}\n// @param b the second {@link SingletonPredictionContext}\n// @param rootIsWildcard {@code true} if this is a local-context merge,\n// otherwise false to indicate a full-context merge\n// @param mergeCache\n// /\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tvar previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tvar rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tvar parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tvar spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tvar singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tvar payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tvar parents = [ singleParent, singleParent ];\n\t\t\tvar apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tvar payloads = [ a.returnState, b.returnState ];\n\t\tvar parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tvar a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n//\n// Handle case where at least one of {@code a} or {@code b} is\n// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n// to represent {@link //EMPTY}.\n//\n// <h2>Local-Context Merges</h2>\n//\n// <p>These local-context merge operations are used when {@code rootIsWildcard}\n// is true.</p>\n//\n// <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n// <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n// {@code //EMPTY}; return left graph.<br>\n// <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>Special case of last merge if local context.<br>\n// <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n//\n// <h2>Full-Context Merges</h2>\n//\n// <p>These full-context merge operations are used when {@code rootIsWildcard}\n// is false.</p>\n//\n// <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n// null parent).<br>\n// <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n//\n// @param a the first {@link SingletonPredictionContext}\n// @param b the second {@link SingletonPredictionContext}\n// @param rootIsWildcard {@code true} if this is a local-context merge,\n// otherwise false to indicate a full-context merge\n// /\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tvar payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tvar parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tvar payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tvar parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n//\n// Merge two {@link ArrayPredictionContext} instances.\n//\n// <p>Different tops, different parents.<br>\n// <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>Shared top, same parents.<br>\n// <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>Shared top, different parents.<br>\n// <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n//\n// <p>Shared top, all shared parents.<br>\n// <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n// type=\"image/svg+xml\"/></p>\n//\n// <p>Equal tops, merge parents and reduce top to\n// {@link SingletonPredictionContext}.<br>\n// <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n// /\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tvar previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tvar i = 0; // walks a\n\tvar j = 0; // walks b\n\tvar k = 0; // walks target M array\n\n\tvar mergedReturnStates = [];\n\tvar mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tvar a_parent = a.parents[i];\n\t\tvar b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tvar payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tvar bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tvar ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tvar mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedParents[k] = mergedParent;\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (var p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (var p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tvar a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tvar M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n//\n// Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n// ones.\n// /\nfunction combineCommonParents(parents) {\n\tvar uniqueParents = {};\n\n\tfor (var p = 0; p < parents.length; p++) {\n\t\tvar parent = parents[p];\n\t\tif (!(parent in uniqueParents)) {\n\t\t\tuniqueParents[parent] = parent;\n\t\t}\n\t}\n\tfor (var q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents[parents[q]];\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tvar existing = visited[context] || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited[context] = existing;\n\t\treturn existing;\n\t}\n\tvar changed = false;\n\tvar parents = [];\n\tfor (var i = 0; i < parents.length; i++) {\n\t\tvar parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (var j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited[context] = context;\n\t\treturn context;\n\t}\n\tvar updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited[updated] = updated;\n\tvisited[context] = updated;\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = {};\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited[context] !== null) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited[context] = context;\n\t\tnodes.push(context);\n\t\tfor (var i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nexports.merge = merge;\nexports.PredictionContext = PredictionContext;\nexports.PredictionContextCache = PredictionContextCache;\nexports.SingletonPredictionContext = SingletonPredictionContext;\nexports.predictionContextFromRuleContext = predictionContextFromRuleContext;\nexports.getCachedPredictionContext = getCachedPredictionContext;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\nvar Token = require('./Token').Token;\nvar ConsoleErrorListener = require('./error/ErrorListener').ConsoleErrorListener;\nvar ProxyErrorListener = require('./error/ErrorListener').ProxyErrorListener;\n\nfunction Recognizer() {\n    this._listeners = [ ConsoleErrorListener.INSTANCE ];\n    this._interp = null;\n    this._stateNumber = -1;\n    return this;\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\n\nRecognizer.prototype.checkVersion = function(toolVersion) {\n    var runtimeVersion = \"4.7.2\";\n    if (runtimeVersion!==toolVersion) {\n        console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n    }\n};\n\nRecognizer.prototype.addErrorListener = function(listener) {\n    this._listeners.push(listener);\n};\n\nRecognizer.prototype.removeErrorListeners = function() {\n    this._listeners = [];\n};\n\nRecognizer.prototype.getTokenTypeMap = function() {\n    var tokenNames = this.getTokenNames();\n    if (tokenNames===null) {\n        throw(\"The current recognizer does not provide a list of token names.\");\n    }\n    var result = this.tokenTypeMapCache[tokenNames];\n    if(result===undefined) {\n        result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n        result.EOF = Token.EOF;\n        this.tokenTypeMapCache[tokenNames] = result;\n    }\n    return result;\n};\n\n// Get a map from rule names to rule indexes.\n//\n// <p>Used for XPath and tree pattern compilation.</p>\n//\nRecognizer.prototype.getRuleIndexMap = function() {\n    var ruleNames = this.ruleNames;\n    if (ruleNames===null) {\n        throw(\"The current recognizer does not provide a list of rule names.\");\n    }\n    var result = this.ruleIndexMapCache[ruleNames];\n    if(result===undefined) {\n        result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n        this.ruleIndexMapCache[ruleNames] = result;\n    }\n    return result;\n};\n\nRecognizer.prototype.getTokenType = function(tokenName) {\n    var ttype = this.getTokenTypeMap()[tokenName];\n    if (ttype !==undefined) {\n        return ttype;\n    } else {\n        return Token.INVALID_TYPE;\n    }\n};\n\n\n// What is the error header, normally line/character position information?//\nRecognizer.prototype.getErrorHeader = function(e) {\n    var line = e.getOffendingToken().line;\n    var column = e.getOffendingToken().column;\n    return \"line \" + line + \":\" + column;\n};\n\n\n// How should a token be displayed in an error message? The default\n//  is to display just the text, but during development you might\n//  want to have a lot of information spit out.  Override in that case\n//  to use t.toString() (which, for CommonToken, dumps everything about\n//  the token). This is better than forcing you to override a method in\n//  your token objects because you don't have to go modify your lexer\n//  so that it creates a new Java type.\n//\n// @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n// implementations of {@link ANTLRErrorStrategy} may provide a similar\n// feature when necessary. For example, see\n// {@link DefaultErrorStrategy//getTokenErrorDisplay}.\n//\nRecognizer.prototype.getTokenErrorDisplay = function(t) {\n    if (t===null) {\n        return \"<no token>\";\n    }\n    var s = t.text;\n    if (s===null) {\n        if (t.type===Token.EOF) {\n            s = \"<EOF>\";\n        } else {\n            s = \"<\" + t.type + \">\";\n        }\n    }\n    s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n    return \"'\" + s + \"'\";\n};\n\nRecognizer.prototype.getErrorListenerDispatch = function() {\n    return new ProxyErrorListener(this._listeners);\n};\n\n// subclass needs to override these if there are sempreds or actions\n// that the ATN interp needs to execute\nRecognizer.prototype.sempred = function(localctx, ruleIndex, actionIndex) {\n    return true;\n};\n\nRecognizer.prototype.precpred = function(localctx , precedence) {\n    return true;\n};\n\n//Indicate that the recognizer has changed internal state that is\n//consistent with the ATN state passed in.  This way we always know\n//where we are in the ATN as the parser goes along. The rule\n//context objects form a stack that lets us see the stack of\n//invoking rules. Combine this and we have complete ATN\n//configuration information.\n\nObject.defineProperty(Recognizer.prototype, \"state\", {\n\tget : function() {\n\t\treturn this._stateNumber;\n\t},\n\tset : function(state) {\n\t\tthis._stateNumber = state;\n\t}\n});\n\n\nexports.Recognizer = Recognizer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n//  A rule context is a record of a single rule invocation. It knows\n//  which context invoked it, if any. If there is no parent context, then\n//  naturally the invoking state is not valid.  The parent link\n//  provides a chain upwards from the current rule invocation to the root\n//  of the invocation tree, forming a stack. We actually carry no\n//  information about the rule associated with this context (except\n//  when parsing). We keep only the state number of the invoking state from\n//  the ATN submachine that invoked this. Contrast this with the s\n//  pointer inside ParserRuleContext that tracks the current state\n//  being \"executed\" for the current rule.\n//\n//  The parent contexts are useful for computing lookahead sets and\n//  getting error information.\n//\n//  These objects are used during parsing and prediction.\n//  For the special case of parsers, we use the subclass\n//  ParserRuleContext.\n//\n//  @see ParserRuleContext\n///\n\nvar RuleNode = require('./tree/Tree').RuleNode;\nvar INVALID_INTERVAL = require('./tree/Tree').INVALID_INTERVAL;\nvar INVALID_ALT_NUMBER = require('./atn/ATN').INVALID_ALT_NUMBER;\n\nfunction RuleContext(parent, invokingState) {\n\tRuleNode.call(this);\n\t// What context invoked this rule?\n\tthis.parentCtx = parent || null;\n\t// What state invoked the rule associated with this context?\n\t// The \"return address\" is the followState of invokingState\n\t// If parent is null, this should be -1.\n\tthis.invokingState = invokingState || -1;\n\treturn this;\n}\n\nRuleContext.prototype = Object.create(RuleNode.prototype);\nRuleContext.prototype.constructor = RuleContext;\n\nRuleContext.prototype.depth = function() {\n\tvar n = 0;\n\tvar p = this;\n\twhile (p !== null) {\n\t\tp = p.parentCtx;\n\t\tn += 1;\n\t}\n\treturn n;\n};\n\n// A context is empty if there is no invoking state; meaning nobody call\n// current context.\nRuleContext.prototype.isEmpty = function() {\n\treturn this.invokingState === -1;\n};\n\n// satisfy the ParseTree / SyntaxTree interface\n\nRuleContext.prototype.getSourceInterval = function() {\n\treturn INVALID_INTERVAL;\n};\n\nRuleContext.prototype.getRuleContext = function() {\n\treturn this;\n};\n\nRuleContext.prototype.getPayload = function() {\n\treturn this;\n};\n\n// Return the combined text of all child nodes. This method only considers\n// tokens which have been added to the parse tree.\n// <p>\n// Since tokens on hidden channels (e.g. whitespace or comments) are not\n// added to the parse trees, they will not appear in the output of this\n// method.\n// /\nRuleContext.prototype.getText = function() {\n\tif (this.getChildCount() === 0) {\n\t\treturn \"\";\n\t} else {\n\t\treturn this.children.map(function(child) {\n\t\t\treturn child.getText();\n\t\t}).join(\"\");\n\t}\n};\n\n// For rule associated with this parse tree internal node, return\n// the outer alternative number used to match the input. Default\n// implementation does not compute nor store this alt num. Create\n// a subclass of ParserRuleContext with backing field and set\n// option contextSuperClass.\n// to set it.\nRuleContext.prototype.getAltNumber = function() { return INVALID_ALT_NUMBER; }\n\n// Set the outer alternative number for this context node. Default\n// implementation does nothing to avoid backing field overhead for\n// trees that don't need it.  Create\n// a subclass of ParserRuleContext with backing field and set\n// option contextSuperClass.\nRuleContext.prototype.setAltNumber = function(altNumber) { }\n\nRuleContext.prototype.getChild = function(i) {\n\treturn null;\n};\n\nRuleContext.prototype.getChildCount = function() {\n\treturn 0;\n};\n\nRuleContext.prototype.accept = function(visitor) {\n\treturn visitor.visitChildren(this);\n};\n\n//need to manage circular dependencies, so export now\nexports.RuleContext = RuleContext;\nvar Trees = require('./tree/Trees').Trees;\n\n\n// Print out a whole tree, not just a node, in LISP format\n// (root child1 .. childN). Print just a node if this is a leaf.\n//\n\nRuleContext.prototype.toStringTree = function(ruleNames, recog) {\n\treturn Trees.toStringTree(this, ruleNames, recog);\n};\n\nRuleContext.prototype.toString = function(ruleNames, stop) {\n\truleNames = ruleNames || null;\n\tstop = stop || null;\n\tvar p = this;\n\tvar s = \"[\";\n\twhile (p !== null && p !== stop) {\n\t\tif (ruleNames === null) {\n\t\t\tif (!p.isEmpty()) {\n\t\t\t\ts += p.invokingState;\n\t\t\t}\n\t\t} else {\n\t\t\tvar ri = p.ruleIndex;\n\t\t\tvar ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t: \"\" + ri;\n\t\t\ts += ruleName;\n\t\t}\n\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\ts += \" \";\n\t\t}\n\t\tp = p.parentCtx;\n\t}\n\ts += \"]\";\n\treturn s;\n};\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n// A token has properties: text, type, line, character position in the line\n// (so we can ignore tabs), token channel, index, and source from which\n// we obtained this token.\n\nfunction Token() {\n\tthis.source = null;\n\tthis.type = null; // token type of the token\n\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\tthis.start = null; // optional; return -1 if not implemented.\n\tthis.stop = null; // optional; return -1 if not implemented.\n\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\tthis.line = null; // line=1..n of the 1st character\n\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\tthis._text = null; // text of the token.\n\treturn this;\n}\n\nToken.INVALID_TYPE = 0;\n\n// During lookahead operations, this \"token\" signifies we hit rule end ATN state\n// and did not follow it despite needing to.\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n// All tokens go to the parser (unless skip() is called in that rule)\n// on a particular \"channel\". The parser tunes to a particular channel\n// so that whitespace etc... can go to the parser on a \"hidden\" channel.\n\nToken.DEFAULT_CHANNEL = 0;\n\n// Anything on different channel than DEFAULT_CHANNEL is not parsed\n// by parser.\n\nToken.HIDDEN_CHANNEL = 1;\n\n// Explicitly set the text for this token. If {code text} is not\n// {@code null}, then {@link //getText} will return this value rather than\n// extracting the text from the input.\n//\n// @param text The explicit text of the token, or {@code null} if the text\n// should be obtained from the input along with the start and stop indexes\n// of the token.\n\nObject.defineProperty(Token.prototype, \"text\", {\n\tget : function() {\n\t\treturn this._text;\n\t},\n\tset : function(text) {\n\t\tthis._text = text;\n\t}\n});\n\nToken.prototype.getTokenSource = function() {\n\treturn this.source[0];\n};\n\nToken.prototype.getInputStream = function() {\n\treturn this.source[1];\n};\n\nfunction CommonToken(source, type, channel, start, stop) {\n\tToken.call(this);\n\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\tthis.type = type !== undefined ? type : null;\n\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\tthis.start = start !== undefined ? start : -1;\n\tthis.stop = stop !== undefined ? stop : -1;\n\tthis.tokenIndex = -1;\n\tif (this.source[0] !== null) {\n\t\tthis.line = source[0].line;\n\t\tthis.column = source[0].column;\n\t} else {\n\t\tthis.column = -1;\n\t}\n\treturn this;\n}\n\nCommonToken.prototype = Object.create(Token.prototype);\nCommonToken.prototype.constructor = CommonToken;\n\n// An empty {@link Pair} which is used as the default value of\n// {@link //source} for tokens that do not have a source.\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\n// Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n//\n// <p>\n// If {@code oldToken} is also a {@link CommonToken} instance, the newly\n// constructed token will share a reference to the {@link //text} field and\n// the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n// be assigned the result of calling {@link //getText}, and {@link //source}\n// will be constructed from the result of {@link Token//getTokenSource} and\n// {@link Token//getInputStream}.</p>\n//\n// @param oldToken The token to copy.\n//\nCommonToken.prototype.clone = function() {\n\tvar t = new CommonToken(this.source, this.type, this.channel, this.start,\n\t\t\tthis.stop);\n\tt.tokenIndex = this.tokenIndex;\n\tt.line = this.line;\n\tt.column = this.column;\n\tt.text = this.text;\n\treturn t;\n};\n\nObject.defineProperty(CommonToken.prototype, \"text\", {\n\tget : function() {\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tvar input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t},\n\tset : function(text) {\n\t\tthis._text = text;\n\t}\n});\n\nCommonToken.prototype.toString = function() {\n\tvar txt = this.text;\n\tif (txt !== null) {\n\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t} else {\n\t\ttxt = \"<no text>\";\n\t}\n\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\tthis.line + \":\" + this.column + \"]\";\n};\n\nexports.Token = Token;\nexports.CommonToken = CommonToken;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction arrayToString(a) {\n    return \"[\" + a.join(\", \") + \"]\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i,\n        key = this.toString();\n\n    remainder = key.length & 3; // key.length % 4\n    bytes = key.length - remainder;\n    h1 = String.prototype.seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n    return a.equals(b);\n}\n\nfunction standardHashCodeFunction(a) {\n    return a.hashCode();\n}\n\nfunction Set(hashFunction, equalsFunction) {\n    this.data = {};\n    this.hashFunction = hashFunction || standardHashCodeFunction;\n    this.equalsFunction = equalsFunction || standardEqualsFunction;\n    return this;\n}\n\nObject.defineProperty(Set.prototype, \"length\", {\n    get: function () {\n        var l = 0;\n        for (var key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l + this.data[key].length;\n            }\n        }\n        return l;\n    }\n});\n\nSet.prototype.add = function (value) {\n    var hash = this.hashFunction(value);\n    var key = \"hash_\" + hash;\n    if (key in this.data) {\n        var values = this.data[key];\n        for (var i = 0; i < values.length; i++) {\n            if (this.equalsFunction(value, values[i])) {\n                return values[i];\n            }\n        }\n        values.push(value);\n        return value;\n    } else {\n        this.data[key] = [value];\n        return value;\n    }\n};\n\nSet.prototype.contains = function (value) {\n    return this.get(value) != null;\n};\n\nSet.prototype.get = function (value) {\n    var hash = this.hashFunction(value);\n    var key = \"hash_\" + hash;\n    if (key in this.data) {\n        var values = this.data[key];\n        for (var i = 0; i < values.length; i++) {\n            if (this.equalsFunction(value, values[i])) {\n                return values[i];\n            }\n        }\n    }\n    return null;\n};\n\nSet.prototype.values = function () {\n    var l = [];\n    for (var key in this.data) {\n        if (key.indexOf(\"hash_\") === 0) {\n            l = l.concat(this.data[key]);\n        }\n    }\n    return l;\n};\n\nSet.prototype.toString = function () {\n    return arrayToString(this.values());\n};\n\nfunction BitSet() {\n    this.data = [];\n    return this;\n}\n\nBitSet.prototype.add = function (value) {\n    this.data[value] = true;\n};\n\nBitSet.prototype.or = function (set) {\n    var bits = this;\n    Object.keys(set.data).map(function (alt) {\n        bits.add(alt);\n    });\n};\n\nBitSet.prototype.remove = function (value) {\n    delete this.data[value];\n};\n\nBitSet.prototype.contains = function (value) {\n    return this.data[value] === true;\n};\n\nBitSet.prototype.values = function () {\n    return Object.keys(this.data);\n};\n\nBitSet.prototype.minValue = function () {\n    return Math.min.apply(null, this.values());\n};\n\nBitSet.prototype.hashCode = function () {\n    var hash = new Hash();\n    hash.update(this.values());\n    return hash.finish();\n};\n\nBitSet.prototype.equals = function (other) {\n    if (!(other instanceof BitSet)) {\n        return false;\n    }\n    return this.hashCode() === other.hashCode();\n};\n\nObject.defineProperty(BitSet.prototype, \"length\", {\n    get: function () {\n        return this.values().length;\n    }\n});\n\nBitSet.prototype.toString = function () {\n    return \"{\" + this.values().join(\", \") + \"}\";\n};\n\nfunction Map(hashFunction, equalsFunction) {\n    this.data = {};\n    this.hashFunction = hashFunction || standardHashCodeFunction;\n    this.equalsFunction = equalsFunction || standardEqualsFunction;\n    return this;\n}\n\nObject.defineProperty(Map.prototype, \"length\", {\n    get: function () {\n        var l = 0;\n        for (var hashKey in this.data) {\n            if (hashKey.indexOf(\"hash_\") === 0) {\n                l = l + this.data[hashKey].length;\n            }\n        }\n        return l;\n    }\n});\n\nMap.prototype.put = function (key, value) {\n    var hashKey = \"hash_\" + this.hashFunction(key);\n    if (hashKey in this.data) {\n        var entries = this.data[hashKey];\n        for (var i = 0; i < entries.length; i++) {\n            var entry = entries[i];\n            if (this.equalsFunction(key, entry.key)) {\n                var oldValue = entry.value;\n                entry.value = value;\n                return oldValue;\n            }\n        }\n        entries.push({key:key, value:value});\n        return value;\n    } else {\n        this.data[hashKey] = [{key:key, value:value}];\n        return value;\n    }\n};\n\nMap.prototype.containsKey = function (key) {\n    var hashKey = \"hash_\" + this.hashFunction(key);\n    if(hashKey in this.data) {\n        var entries = this.data[hashKey];\n        for (var i = 0; i < entries.length; i++) {\n            var entry = entries[i];\n            if (this.equalsFunction(key, entry.key))\n                return true;\n        }\n    }\n    return false;\n};\n\nMap.prototype.get = function (key) {\n    var hashKey = \"hash_\" + this.hashFunction(key);\n    if(hashKey in this.data) {\n        var entries = this.data[hashKey];\n        for (var i = 0; i < entries.length; i++) {\n            var entry = entries[i];\n            if (this.equalsFunction(key, entry.key))\n                return entry.value;\n        }\n    }\n    return null;\n};\n\nMap.prototype.entries = function () {\n    var l = [];\n    for (var key in this.data) {\n        if (key.indexOf(\"hash_\") === 0) {\n            l = l.concat(this.data[key]);\n        }\n    }\n    return l;\n};\n\n\nMap.prototype.getKeys = function () {\n    return this.entries().map(function(e) {\n        return e.key;\n    });\n};\n\n\nMap.prototype.getValues = function () {\n    return this.entries().map(function(e) {\n            return e.value;\n    });\n};\n\n\nMap.prototype.toString = function () {\n    var ss = this.entries().map(function(entry) {\n        return '{' + entry.key + ':' + entry.value + '}';\n    });\n    return '[' + ss.join(\", \") + ']';\n};\n\n\nfunction AltDict() {\n    this.data = {};\n    return this;\n}\n\n\nAltDict.prototype.get = function (key) {\n    key = \"k-\" + key;\n    if (key in this.data) {\n        return this.data[key];\n    } else {\n        return null;\n    }\n};\n\nAltDict.prototype.put = function (key, value) {\n    key = \"k-\" + key;\n    this.data[key] = value;\n};\n\nAltDict.prototype.values = function () {\n    var data = this.data;\n    var keys = Object.keys(this.data);\n    return keys.map(function (key) {\n        return data[key];\n    });\n};\n\nfunction DoubleDict() {\n    return this;\n}\n\nfunction Hash() {\n    this.count = 0;\n    this.hash = 0;\n    return this;\n}\n\nHash.prototype.update = function () {\n    for(var i=0;i<arguments.length;i++) {\n        var value = arguments[i];\n        if (value == null)\n            continue;\n        if(Array.isArray(value))\n            this.update.apply(value);\n        else {\n            var k = 0;\n            switch (typeof(value)) {\n                case 'undefined':\n                case 'function':\n                    continue;\n                case 'number':\n                case 'boolean':\n                    k = value;\n                    break;\n                case 'string':\n                    k = value.hashCode();\n                    break;\n                default:\n                    value.updateHashCode(this);\n                    continue;\n            }\n            k = k * 0xCC9E2D51;\n            k = (k << 15) | (k >>> (32 - 15));\n            k = k * 0x1B873593;\n            this.count = this.count + 1;\n            var hash = this.hash ^ k;\n            hash = (hash << 13) | (hash >>> (32 - 13));\n            hash = hash * 5 + 0xE6546B64;\n            this.hash = hash;\n        }\n    }\n}\n\nHash.prototype.finish = function () {\n    var hash = this.hash ^ (this.count * 4);\n    hash = hash ^ (hash >>> 16);\n    hash = hash * 0x85EBCA6B;\n    hash = hash ^ (hash >>> 13);\n    hash = hash * 0xC2B2AE35;\n    hash = hash ^ (hash >>> 16);\n    return hash;\n}\n\nfunction hashStuff() {\n    var hash = new Hash();\n    hash.update.apply(arguments);\n    return hash.finish();\n}\n\nDoubleDict.prototype.get = function (a, b) {\n    var d = this[a] || null;\n    return d === null ? null : (d[b] || null);\n};\n\nDoubleDict.prototype.set = function (a, b, o) {\n    var d = this[a] || null;\n    if (d === null) {\n        d = {};\n        this[a] = d;\n    }\n    d[b] = o;\n};\n\n\nfunction escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\")\n         .replace(/\\n/g, \"\\\\n\")\n         .replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n        s = s.replace(/ /g, \"\\u00B7\");\n    }\n    return s;\n}\n\nfunction titleCase(str) {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n};\n\nfunction equalArrays(a, b)\n{\n    if (!Array.isArray(a) || !Array.isArray(b))\n        return false;\n    if (a == b)\n        return true;\n    if (a.length != b.length)\n        return false;\n    for (var i = 0; i < a.length; i++) {\n        if (a[i] == b[i])\n            continue;\n        if (!a[i].equals(b[i]))\n            return false;\n    }\n    return true;\n};\n\nexports.Hash = Hash;\nexports.Set = Set;\nexports.Map = Map;\nexports.BitSet = BitSet;\nexports.AltDict = AltDict;\nexports.DoubleDict = DoubleDict;\nexports.hashStuff = hashStuff;\nexports.escapeWhitespace = escapeWhitespace;\nexports.arrayToString = arrayToString;\nexports.titleCase = titleCase;\nexports.equalArrays = equalArrays;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar LL1Analyzer = require('./../LL1Analyzer').LL1Analyzer;\nvar IntervalSet = require('./../IntervalSet').IntervalSet;\n\nfunction ATN(grammarType , maxTokenType) {\n\n    // Used for runtime deserialization of ATNs from strings///\n    // The type of the ATN.\n    this.grammarType = grammarType;\n    // The maximum value for any symbol recognized by a transition in the ATN.\n    this.maxTokenType = maxTokenType;\n    this.states = [];\n    // Each subrule/rule is a decision point and we must track them so we\n    //  can go back later and build DFA predictors for them.  This includes\n    //  all the rules, subrules, optional blocks, ()+, ()* etc...\n    this.decisionToState = [];\n    // Maps from rule index to starting state number.\n    this.ruleToStartState = [];\n    // Maps from rule index to stop state number.\n    this.ruleToStopState = null;\n    this.modeNameToStartState = {};\n    // For lexer ATNs, this maps the rule index to the resulting token type.\n    // For parser ATNs, this maps the rule index to the generated bypass token\n    // type if the\n    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n    // deserialization option was specified; otherwise, this is {@code null}.\n    this.ruleToTokenType = null;\n    // For lexer ATNs, this is an array of {@link LexerAction} objects which may\n    // be referenced by action transitions in the ATN.\n    this.lexerActions = null;\n    this.modeToStartState = [];\n\n    return this;\n}\n\n// Compute the set of valid tokens that can occur starting in state {@code s}.\n//  If {@code ctx} is null, the set of tokens will not include what can follow\n//  the rule surrounding {@code s}. In other words, the set will be\n//  restricted to tokens reachable staying within {@code s}'s rule.\nATN.prototype.nextTokensInContext = function(s, ctx) {\n    var anal = new LL1Analyzer(this);\n    return anal.LOOK(s, null, ctx);\n};\n\n// Compute the set of valid tokens that can occur starting in {@code s} and\n// staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n// rule.\nATN.prototype.nextTokensNoContext = function(s) {\n    if (s.nextTokenWithinRule !== null ) {\n        return s.nextTokenWithinRule;\n    }\n    s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n    s.nextTokenWithinRule.readOnly = true;\n    return s.nextTokenWithinRule;\n};\n\nATN.prototype.nextTokens = function(s, ctx) {\n    if ( ctx===undefined ) {\n        return this.nextTokensNoContext(s);\n    } else {\n        return this.nextTokensInContext(s, ctx);\n    }\n};\n\nATN.prototype.addState = function( state) {\n    if ( state !== null ) {\n        state.atn = this;\n        state.stateNumber = this.states.length;\n    }\n    this.states.push(state);\n};\n\nATN.prototype.removeState = function( state) {\n    this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n};\n\nATN.prototype.defineDecisionState = function( s) {\n    this.decisionToState.push(s);\n    s.decision = this.decisionToState.length-1;\n    return s.decision;\n};\n\nATN.prototype.getDecisionState = function( decision) {\n    if (this.decisionToState.length===0) {\n        return null;\n    } else {\n        return this.decisionToState[decision];\n    }\n};\n\n// Computes the set of input symbols which could follow ATN state number\n// {@code stateNumber} in the specified full {@code context}. This method\n// considers the complete parser context, but does not evaluate semantic\n// predicates (i.e. all predicates encountered during the calculation are\n// assumed true). If a path in the ATN exists from the starting state to the\n// {@link RuleStopState} of the outermost context without matching any\n// symbols, {@link Token//EOF} is added to the returned set.\n//\n// <p>If {@code context} is {@code null}, it is treated as\n// {@link ParserRuleContext//EMPTY}.</p>\n//\n// @param stateNumber the ATN state number\n// @param context the full parse context\n// @return The set of potentially valid input symbols which could follow the\n// specified state in the specified context.\n// @throws IllegalArgumentException if the ATN does not contain a state with\n// number {@code stateNumber}\nvar Token = require('./../Token').Token;\n\nATN.prototype.getExpectedTokens = function( stateNumber, ctx ) {\n    if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n        throw(\"Invalid state number.\");\n    }\n    var s = this.states[stateNumber];\n    var following = this.nextTokens(s);\n    if (!following.contains(Token.EPSILON)) {\n        return following;\n    }\n    var expected = new IntervalSet();\n    expected.addSet(following);\n    expected.removeOne(Token.EPSILON);\n    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n        var invokingState = this.states[ctx.invokingState];\n        var rt = invokingState.transitions[0];\n        following = this.nextTokens(rt.followState);\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        ctx = ctx.parentCtx;\n    }\n    if (following.contains(Token.EPSILON)) {\n        expected.addOne(Token.EOF);\n    }\n    return expected;\n};\n\nATN.INVALID_ALT_NUMBER = 0;\n\nexports.ATN = ATN;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// A tuple: (ATN state, predicted alt, syntactic, semantic context).\n//  The syntactic context is a graph-structured stack node whose\n//  path(s) to the root is the rule invocation(s)\n//  chain used to arrive at the state.  The semantic context is\n//  the tree of semantic predicates encountered before reaching\n//  an ATN state.\n///\n\nvar DecisionState = require('./ATNState').DecisionState;\nvar SemanticContext = require('./SemanticContext').SemanticContext;\nvar Hash = require(\"../Utils\").Hash;\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tvar result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tvar props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nfunction ATNConfig(params, config) {\n\tthis.checkContext(params, config);\n\tparams = checkParams(params);\n\tconfig = checkParams(config, true);\n    // The ATN state associated with this configuration///\n    this.state = params.state!==null ? params.state : config.state;\n    // What alt (or lexer rule) is predicted by this configuration///\n    this.alt = params.alt!==null ? params.alt : config.alt;\n    // The stack of invoking states leading to the rule/states associated\n    //  with this config.  We track only those contexts pushed during\n    //  execution of the ATN simulator.\n    this.context = params.context!==null ? params.context : config.context;\n    this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n        (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n    // We cannot execute predicates dependent upon local context unless\n    // we know for sure we are in the correct context. Because there is\n    // no way to do this efficiently, we simply cannot evaluate\n    // dependent predicates unless we are in the rule that initially\n    // invokes the ATN simulator.\n    //\n    // closure() tracks the depth of how far we dip into the\n    // outer context: depth &gt; 0.  Note that it may not be totally\n    // accurate depth since I don't ever decrement. TODO: make it a boolean then\n    this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    return this;\n}\n\nATNConfig.prototype.checkContext = function(params, config) {\n\tif((params.context===null || params.context===undefined) &&\n\t\t\t(config===null || config.context===null || config.context===undefined)) {\n\t\tthis.context = null;\n\t}\n};\n\n\nATNConfig.prototype.hashCode = function() {\n    var hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n};\n\n\nATNConfig.prototype.updateHashCode = function(hash) {\n    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n};\n\n// An ATN configuration is equal to another if both have\n//  the same state, they predict the same alternative, and\n//  syntactic/semantic contexts are the same.\n\nATNConfig.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof ATNConfig)) {\n        return false;\n    } else {\n        return this.state.stateNumber===other.state.stateNumber &&\n            this.alt===other.alt &&\n            (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n            this.semanticContext.equals(other.semanticContext) &&\n            this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n    }\n};\n\n\nATNConfig.prototype.hashCodeForConfigSet = function() {\n    var hash = new Hash();\n    hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n    return hash.finish();\n};\n\n\nATNConfig.prototype.equalsForConfigSet = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof ATNConfig)) {\n        return false;\n    } else {\n        return this.state.stateNumber===other.state.stateNumber &&\n            this.alt===other.alt &&\n            this.semanticContext.equals(other.semanticContext);\n    }\n};\n\n\nATNConfig.prototype.toString = function() {\n    return \"(\" + this.state + \",\" + this.alt +\n        (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n        (this.semanticContext !== SemanticContext.NONE ?\n                (\",\" + this.semanticContext.toString())\n                : \"\") +\n        (this.reachesIntoOuterContext>0 ?\n                (\",up=\" + this.reachesIntoOuterContext)\n                : \"\") + \")\";\n};\n\n\nfunction LexerATNConfig(params, config) {\n\tATNConfig.call(this, params, config);\n\n    // This is the backing field for {@link //getLexerActionExecutor}.\n\tvar lexerActionExecutor = params.lexerActionExecutor || null;\n    this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n    this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n    return this;\n}\n\nLexerATNConfig.prototype = Object.create(ATNConfig.prototype);\nLexerATNConfig.prototype.constructor = LexerATNConfig;\n\nLexerATNConfig.prototype.updateHashCode = function(hash) {\n    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n};\n\nLexerATNConfig.prototype.equals = function(other) {\n    return this === other ||\n            (other instanceof LexerATNConfig &&\n            this.passedThroughNonGreedyDecision == other.passedThroughNonGreedyDecision &&\n            (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n            ATNConfig.prototype.equals.call(this, other));\n};\n\nLexerATNConfig.prototype.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n\nLexerATNConfig.prototype.equalsForConfigSet = LexerATNConfig.prototype.equals;\n\n\nLexerATNConfig.prototype.checkNonGreedyDecision = function(source, target) {\n    return source.passedThroughNonGreedyDecision ||\n        (target instanceof DecisionState) && target.nonGreedy;\n};\n\nexports.ATNConfig = ATNConfig;\nexports.LexerATNConfig = LexerATNConfig;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n//\n// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n// info about the set, with support for combining similar configurations using a\n// graph-structured stack.\n///\n\nvar ATN = require('./ATN').ATN;\nvar Utils = require('./../Utils');\nvar Hash = Utils.Hash;\nvar Set = Utils.Set;\nvar SemanticContext = require('./SemanticContext').SemanticContext;\nvar merge = require('./../PredictionContext').merge;\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n\nfunction ATNConfigSet(fullCtx) {\n\t//\n\t// The reason that we need this is because we don't want the hash map to use\n\t// the standard hash code and equals. We need all configurations with the\n\t// same\n\t// {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t// doubles\n\t// the number of objects associated with ATNConfigs. The other solution is\n\t// to\n\t// use a hash table that lets us specify the equals/hashcode operation.\n\t// All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t// when we go readonly as this set becomes a DFA state.\n\tthis.configLookup = new Set(hashATNConfig, equalATNConfigs);\n\t// Indicates that this configuration set is part of a full context\n\t// LL prediction. It will be used to determine how to merge $. With SLL\n\t// it's a wildcard whereas it is not for LL context merge.\n\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t// Indicates that the set of configurations is read-only. Do not\n\t// allow any code to manipulate the set; DFA states will point at\n\t// the sets and they must not change. This does not protect the other\n\t// fields; in particular, conflictingAlts is set after\n\t// we've made this readonly.\n\tthis.readOnly = false;\n\t// Track the elements as they are added to the set; supports get(i)///\n\tthis.configs = [];\n\n\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t// together, saves recomputation\n\t// TODO: can we track conflicts as they are added to save scanning configs\n\t// later?\n\tthis.uniqueAlt = 0;\n\tthis.conflictingAlts = null;\n\n\t// Used in parser and lexer. In lexer, it indicates we hit a pred\n\t// while computing a closure operation. Don't make a DFA state from this.\n\tthis.hasSemanticContext = false;\n\tthis.dipsIntoOuterContext = false;\n\n\tthis.cachedHashCode = -1;\n\n\treturn this;\n}\n\n// Adding a new config means merging contexts with existing configs for\n// {@code (s, i, pi, _)}, where {@code s} is the\n// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n// {@code pi} is the {@link ATNConfig//semanticContext}. We use\n// {@code (s,i,pi)} as key.\n//\n// <p>This method updates {@link //dipsIntoOuterContext} and\n// {@link //hasSemanticContext} when necessary.</p>\n// /\nATNConfigSet.prototype.add = function(config, mergeCache) {\n\tif (mergeCache === undefined) {\n\t\tmergeCache = null;\n\t}\n\tif (this.readOnly) {\n\t\tthrow \"This set is readonly\";\n\t}\n\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\tthis.hasSemanticContext = true;\n\t}\n\tif (config.reachesIntoOuterContext > 0) {\n\t\tthis.dipsIntoOuterContext = true;\n\t}\n\tvar existing = this.configLookup.add(config);\n\tif (existing === config) {\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configs.push(config); // track order here\n\t\treturn true;\n\t}\n\t// a previous (s,i,pi,_), merge with it and save result\n\tvar rootIsWildcard = !this.fullCtx;\n\tvar merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t// no need to check for existing.context, config.context in cache\n\t// since only way to create new graphs is \"call rule\" and here. We\n\t// cache at both places.\n\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t// make sure to preserve the precedence filter suppression during the merge\n\tif (config.precedenceFilterSuppressed) {\n\t\texisting.precedenceFilterSuppressed = true;\n\t}\n\texisting.context = merged; // replace context; no need to alt mapping\n\treturn true;\n};\n\nATNConfigSet.prototype.getStates = function() {\n\tvar states = new Set();\n\tfor (var i = 0; i < this.configs.length; i++) {\n\t\tstates.add(this.configs[i].state);\n\t}\n\treturn states;\n};\n\nATNConfigSet.prototype.getPredicates = function() {\n\tvar preds = [];\n\tfor (var i = 0; i < this.configs.length; i++) {\n\t\tvar c = this.configs[i].semanticContext;\n\t\tif (c !== SemanticContext.NONE) {\n\t\t\tpreds.push(c.semanticContext);\n\t\t}\n\t}\n\treturn preds;\n};\n\nObject.defineProperty(ATNConfigSet.prototype, \"items\", {\n\tget : function() {\n\t\treturn this.configs;\n\t}\n});\n\nATNConfigSet.prototype.optimizeConfigs = function(interpreter) {\n\tif (this.readOnly) {\n\t\tthrow \"This set is readonly\";\n\t}\n\tif (this.configLookup.length === 0) {\n\t\treturn;\n\t}\n\tfor (var i = 0; i < this.configs.length; i++) {\n\t\tvar config = this.configs[i];\n\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t}\n};\n\nATNConfigSet.prototype.addAll = function(coll) {\n\tfor (var i = 0; i < coll.length; i++) {\n\t\tthis.add(coll[i]);\n\t}\n\treturn false;\n};\n\nATNConfigSet.prototype.equals = function(other) {\n\treturn this === other ||\n\t\t(other instanceof ATNConfigSet &&\n\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\tthis.fullCtx === other.fullCtx &&\n\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n};\n\nATNConfigSet.prototype.hashCode = function() {\n    var hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n};\n\n\nATNConfigSet.prototype.updateHashCode = function(hash) {\n\tif (this.readOnly) {\n\t\tif (this.cachedHashCode === -1) {\n            var hash = new Hash();\n            hash.update(this.configs);\n\t\t\tthis.cachedHashCode = hash.finish();\n\t\t}\n        hash.update(this.cachedHashCode);\n\t} else {\n        hash.update(this.configs);\n\t}\n};\n\n\nObject.defineProperty(ATNConfigSet.prototype, \"length\", {\n\tget : function() {\n\t\treturn this.configs.length;\n\t}\n});\n\nATNConfigSet.prototype.isEmpty = function() {\n\treturn this.configs.length === 0;\n};\n\nATNConfigSet.prototype.contains = function(item) {\n\tif (this.configLookup === null) {\n\t\tthrow \"This method is not implemented for readonly sets.\";\n\t}\n\treturn this.configLookup.contains(item);\n};\n\nATNConfigSet.prototype.containsFast = function(item) {\n\tif (this.configLookup === null) {\n\t\tthrow \"This method is not implemented for readonly sets.\";\n\t}\n\treturn this.configLookup.containsFast(item);\n};\n\nATNConfigSet.prototype.clear = function() {\n\tif (this.readOnly) {\n\t\tthrow \"This set is readonly\";\n\t}\n\tthis.configs = [];\n\tthis.cachedHashCode = -1;\n\tthis.configLookup = new Set();\n};\n\nATNConfigSet.prototype.setReadonly = function(readOnly) {\n\tthis.readOnly = readOnly;\n\tif (readOnly) {\n\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t}\n};\n\nATNConfigSet.prototype.toString = function() {\n\treturn Utils.arrayToString(this.configs) +\n\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n};\n\nfunction OrderedATNConfigSet() {\n\tATNConfigSet.call(this);\n\tthis.configLookup = new Set();\n\treturn this;\n}\n\nOrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);\nOrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;\n\nexports.ATNConfigSet = ATNConfigSet;\nexports.OrderedATNConfigSet = OrderedATNConfigSet;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction ATNDeserializationOptions(copyFrom) {\n\tif(copyFrom===undefined) {\n\t\tcopyFrom = null;\n\t}\n\tthis.readOnly = false;\n    this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;\n    this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;\n\n    return this;\n}\n\nATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\nATNDeserializationOptions.defaultOptions.readOnly = true;\n\n//    def __setattr__(self, key, value):\n//        if key!=\"readOnly\" and self.readOnly:\n//            raise Exception(\"The object is read only.\")\n//        super(type(self), self).__setattr__(key,value)\n\nexports.ATNDeserializationOptions = ATNDeserializationOptions;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar Token = require('./../Token').Token;\nvar ATN = require('./ATN').ATN;\nvar ATNType = require('./ATNType').ATNType;\nvar ATNStates = require('./ATNState');\nvar ATNState = ATNStates.ATNState;\nvar BasicState = ATNStates.BasicState;\nvar DecisionState = ATNStates.DecisionState;\nvar BlockStartState = ATNStates.BlockStartState;\nvar BlockEndState = ATNStates.BlockEndState;\nvar LoopEndState = ATNStates.LoopEndState;\nvar RuleStartState = ATNStates.RuleStartState;\nvar RuleStopState = ATNStates.RuleStopState;\nvar TokensStartState = ATNStates.TokensStartState;\nvar PlusLoopbackState = ATNStates.PlusLoopbackState;\nvar StarLoopbackState = ATNStates.StarLoopbackState;\nvar StarLoopEntryState = ATNStates.StarLoopEntryState;\nvar PlusBlockStartState = ATNStates.PlusBlockStartState;\nvar StarBlockStartState = ATNStates.StarBlockStartState;\nvar BasicBlockStartState = ATNStates.BasicBlockStartState;\nvar Transitions = require('./Transition');\nvar Transition = Transitions.Transition;\nvar AtomTransition = Transitions.AtomTransition;\nvar SetTransition = Transitions.SetTransition;\nvar NotSetTransition = Transitions.NotSetTransition;\nvar RuleTransition = Transitions.RuleTransition;\nvar RangeTransition = Transitions.RangeTransition;\nvar ActionTransition = Transitions.ActionTransition;\nvar EpsilonTransition = Transitions.EpsilonTransition;\nvar WildcardTransition = Transitions.WildcardTransition;\nvar PredicateTransition = Transitions.PredicateTransition;\nvar PrecedencePredicateTransition = Transitions.PrecedencePredicateTransition;\nvar IntervalSet = require('./../IntervalSet').IntervalSet;\nvar Interval = require('./../IntervalSet').Interval;\nvar ATNDeserializationOptions = require('./ATNDeserializationOptions').ATNDeserializationOptions;\nvar LexerActions = require('./LexerAction');\nvar LexerActionType = LexerActions.LexerActionType;\nvar LexerSkipAction = LexerActions.LexerSkipAction;\nvar LexerChannelAction = LexerActions.LexerChannelAction;\nvar LexerCustomAction = LexerActions.LexerCustomAction;\nvar LexerMoreAction = LexerActions.LexerMoreAction;\nvar LexerTypeAction = LexerActions.LexerTypeAction;\nvar LexerPushModeAction = LexerActions.LexerPushModeAction;\nvar LexerPopModeAction = LexerActions.LexerPopModeAction;\nvar LexerModeAction = LexerActions.LexerModeAction;\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nvar BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nvar ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nvar SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nvar SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nvar SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tvar tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nfunction ATNDeserializer (options) {\n\n    if ( options=== undefined || options === null ) {\n        options = ATNDeserializationOptions.defaultOptions;\n    }\n    this.deserializationOptions = options;\n    this.stateFactories = null;\n    this.actionFactories = null;\n\n    return this;\n}\n\n// Determines if a particular serialized representation of an ATN supports\n// a particular feature, identified by the {@link UUID} used for serializing\n// the ATN at the time the feature was first introduced.\n//\n// @param feature The {@link UUID} marking the first time the feature was\n// supported in the serialized ATN.\n// @param actualUuid The {@link UUID} of the actual serialized ATN which is\n// currently being deserialized.\n// @return {@code true} if the {@code actualUuid} value represents a\n// serialized ATN at or after the feature identified by {@code feature} was\n// introduced; otherwise, {@code false}.\n\nATNDeserializer.prototype.isFeatureSupported = function(feature, actualUuid) {\n    var idx1 = SUPPORTED_UUIDS.indexOf(feature);\n    if (idx1<0) {\n        return false;\n    }\n    var idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n    return idx2 >= idx1;\n};\n\nATNDeserializer.prototype.deserialize = function(data) {\n    this.reset(data);\n    this.checkVersion();\n    this.checkUUID();\n    var atn = this.readATN();\n    this.readStates(atn);\n    this.readRules(atn);\n    this.readModes(atn);\n    var sets = [];\n    // First, deserialize sets with 16-bit arguments <= U+FFFF.\n    this.readSets(atn, sets, this.readInt.bind(this));\n    // Next, if the ATN was serialized with the Unicode SMP feature,\n    // deserialize sets with 32-bit arguments <= U+10FFFF.\n    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n        this.readSets(atn, sets, this.readInt32.bind(this));\n    }\n    this.readEdges(atn, sets);\n    this.readDecisions(atn);\n    this.readLexerActions(atn);\n    this.markPrecedenceDecisions(atn);\n    this.verifyATN(atn);\n    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n        this.generateRuleBypassTransitions(atn);\n        // re-verify after modification\n        this.verifyATN(atn);\n    }\n    return atn;\n};\n\nATNDeserializer.prototype.reset = function(data) {\n\tvar adjust = function(c) {\n        var v = c.charCodeAt(0);\n        return v>1  ? v-2 : v + 65533;\n\t};\n    var temp = data.split(\"\").map(adjust);\n    // don't adjust the first value since that's the version number\n    temp[0] = data.charCodeAt(0);\n    this.data = temp;\n    this.pos = 0;\n};\n\nATNDeserializer.prototype.checkVersion = function() {\n    var version = this.readInt();\n    if ( version !== SERIALIZED_VERSION ) {\n        throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n    }\n};\n\nATNDeserializer.prototype.checkUUID = function() {\n    var uuid = this.readUUID();\n    if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n        throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                        \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n    }\n    this.uuid = uuid;\n};\n\nATNDeserializer.prototype.readATN = function() {\n    var grammarType = this.readInt();\n    var maxTokenType = this.readInt();\n    return new ATN(grammarType, maxTokenType);\n};\n\nATNDeserializer.prototype.readStates = function(atn) {\n\tvar j, pair, stateNumber;\n    var loopBackStateNumbers = [];\n    var endStateNumbers = [];\n    var nstates = this.readInt();\n    for(var i=0; i<nstates; i++) {\n        var stype = this.readInt();\n        // ignore bad type of states\n        if (stype===ATNState.INVALID_TYPE) {\n            atn.addState(null);\n            continue;\n        }\n        var ruleIndex = this.readInt();\n        if (ruleIndex === 0xFFFF) {\n            ruleIndex = -1;\n        }\n        var s = this.stateFactory(stype, ruleIndex);\n        if (stype === ATNState.LOOP_END) { // special case\n            var loopBackStateNumber = this.readInt();\n            loopBackStateNumbers.push([s, loopBackStateNumber]);\n        } else if(s instanceof BlockStartState) {\n            var endStateNumber = this.readInt();\n            endStateNumbers.push([s, endStateNumber]);\n        }\n        atn.addState(s);\n    }\n    // delay the assignment of loop back and end states until we know all the\n\t// state instances have been initialized\n    for (j=0; j<loopBackStateNumbers.length; j++) {\n        pair = loopBackStateNumbers[j];\n        pair[0].loopBackState = atn.states[pair[1]];\n    }\n\n    for (j=0; j<endStateNumbers.length; j++) {\n        pair = endStateNumbers[j];\n        pair[0].endState = atn.states[pair[1]];\n    }\n\n    var numNonGreedyStates = this.readInt();\n    for (j=0; j<numNonGreedyStates; j++) {\n        stateNumber = this.readInt();\n        atn.states[stateNumber].nonGreedy = true;\n    }\n\n    var numPrecedenceStates = this.readInt();\n    for (j=0; j<numPrecedenceStates; j++) {\n        stateNumber = this.readInt();\n        atn.states[stateNumber].isPrecedenceRule = true;\n    }\n};\n\nATNDeserializer.prototype.readRules = function(atn) {\n    var i;\n    var nrules = this.readInt();\n    if (atn.grammarType === ATNType.LEXER ) {\n        atn.ruleToTokenType = initArray(nrules, 0);\n    }\n    atn.ruleToStartState = initArray(nrules, 0);\n    for (i=0; i<nrules; i++) {\n        var s = this.readInt();\n        var startState = atn.states[s];\n        atn.ruleToStartState[i] = startState;\n        if ( atn.grammarType === ATNType.LEXER ) {\n            var tokenType = this.readInt();\n            if (tokenType === 0xFFFF) {\n                tokenType = Token.EOF;\n            }\n            atn.ruleToTokenType[i] = tokenType;\n        }\n    }\n    atn.ruleToStopState = initArray(nrules, 0);\n    for (i=0; i<atn.states.length; i++) {\n        var state = atn.states[i];\n        if (!(state instanceof RuleStopState)) {\n            continue;\n        }\n        atn.ruleToStopState[state.ruleIndex] = state;\n        atn.ruleToStartState[state.ruleIndex].stopState = state;\n    }\n};\n\nATNDeserializer.prototype.readModes = function(atn) {\n    var nmodes = this.readInt();\n    for (var i=0; i<nmodes; i++) {\n        var s = this.readInt();\n        atn.modeToStartState.push(atn.states[s]);\n    }\n};\n\nATNDeserializer.prototype.readSets = function(atn, sets, readUnicode) {\n    var m = this.readInt();\n    for (var i=0; i<m; i++) {\n        var iset = new IntervalSet();\n        sets.push(iset);\n        var n = this.readInt();\n        var containsEof = this.readInt();\n        if (containsEof!==0) {\n            iset.addOne(-1);\n        }\n        for (var j=0; j<n; j++) {\n            var i1 = readUnicode();\n            var i2 = readUnicode();\n            iset.addRange(i1, i2);\n        }\n    }\n};\n\nATNDeserializer.prototype.readEdges = function(atn, sets) {\n\tvar i, j, state, trans, target;\n    var nedges = this.readInt();\n    for (i=0; i<nedges; i++) {\n        var src = this.readInt();\n        var trg = this.readInt();\n        var ttype = this.readInt();\n        var arg1 = this.readInt();\n        var arg2 = this.readInt();\n        var arg3 = this.readInt();\n        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n        var srcState = atn.states[src];\n        srcState.addTransition(trans);\n    }\n    // edges for rule stop states can be derived, so they aren't serialized\n    for (i=0; i<atn.states.length; i++) {\n        state = atn.states[i];\n        for (j=0; j<state.transitions.length; j++) {\n            var t = state.transitions[j];\n            if (!(t instanceof RuleTransition)) {\n                continue;\n            }\n\t\t\tvar outermostPrecedenceReturn = -1;\n\t\t\tif (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n\t\t\t\tif (t.precedence === 0) {\n\t\t\t\t\toutermostPrecedenceReturn = t.target.ruleIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n        }\n    }\n\n    for (i=0; i<atn.states.length; i++) {\n        state = atn.states[i];\n        if (state instanceof BlockStartState) {\n            // we need to know the end state to set its start state\n            if (state.endState === null) {\n                throw (\"IllegalState\");\n            }\n            // block end states can only be associated to a single block start\n\t\t\t// state\n            if ( state.endState.startState !== null) {\n                throw (\"IllegalState\");\n            }\n            state.endState.startState = state;\n        }\n        if (state instanceof PlusLoopbackState) {\n            for (j=0; j<state.transitions.length; j++) {\n                target = state.transitions[j].target;\n                if (target instanceof PlusBlockStartState) {\n                    target.loopBackState = state;\n                }\n            }\n        } else if (state instanceof StarLoopbackState) {\n            for (j=0; j<state.transitions.length; j++) {\n                target = state.transitions[j].target;\n                if (target instanceof StarLoopEntryState) {\n                    target.loopBackState = state;\n                }\n            }\n        }\n    }\n};\n\nATNDeserializer.prototype.readDecisions = function(atn) {\n    var ndecisions = this.readInt();\n    for (var i=0; i<ndecisions; i++) {\n        var s = this.readInt();\n        var decState = atn.states[s];\n        atn.decisionToState.push(decState);\n        decState.decision = i;\n    }\n};\n\nATNDeserializer.prototype.readLexerActions = function(atn) {\n    if (atn.grammarType === ATNType.LEXER) {\n        var count = this.readInt();\n        atn.lexerActions = initArray(count, null);\n        for (var i=0; i<count; i++) {\n            var actionType = this.readInt();\n            var data1 = this.readInt();\n            if (data1 === 0xFFFF) {\n                data1 = -1;\n            }\n            var data2 = this.readInt();\n            if (data2 === 0xFFFF) {\n                data2 = -1;\n            }\n            var lexerAction = this.lexerActionFactory(actionType, data1, data2);\n            atn.lexerActions[i] = lexerAction;\n        }\n    }\n};\n\nATNDeserializer.prototype.generateRuleBypassTransitions = function(atn) {\n\tvar i;\n    var count = atn.ruleToStartState.length;\n    for(i=0; i<count; i++) {\n        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n    }\n    for(i=0; i<count; i++) {\n        this.generateRuleBypassTransition(atn, i);\n    }\n};\n\nATNDeserializer.prototype.generateRuleBypassTransition = function(atn, idx) {\n\tvar i, state;\n    var bypassStart = new BasicBlockStartState();\n    bypassStart.ruleIndex = idx;\n    atn.addState(bypassStart);\n\n    var bypassStop = new BlockEndState();\n    bypassStop.ruleIndex = idx;\n    atn.addState(bypassStop);\n\n    bypassStart.endState = bypassStop;\n    atn.defineDecisionState(bypassStart);\n\n    bypassStop.startState = bypassStart;\n\n    var excludeTransition = null;\n    var endState = null;\n\n    if (atn.ruleToStartState[idx].isPrecedenceRule) {\n        // wrap from the beginning of the rule to the StarLoopEntryState\n        endState = null;\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (this.stateIsEndStateFor(state, idx)) {\n                endState = state;\n                excludeTransition = state.loopBackState.transitions[0];\n                break;\n            }\n        }\n        if (excludeTransition === null) {\n            throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n        }\n    } else {\n        endState = atn.ruleToStopState[idx];\n    }\n\n    // all non-excluded transitions that currently target end state need to\n\t// target blockEnd instead\n    for(i=0; i<atn.states.length; i++) {\n        state = atn.states[i];\n        for(var j=0; j<state.transitions.length; j++) {\n            var transition = state.transitions[j];\n            if (transition === excludeTransition) {\n                continue;\n            }\n            if (transition.target === endState) {\n                transition.target = bypassStop;\n            }\n        }\n    }\n\n    // all transitions leaving the rule start state need to leave blockStart\n\t// instead\n    var ruleToStartState = atn.ruleToStartState[idx];\n    var count = ruleToStartState.transitions.length;\n    while ( count > 0) {\n        bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n    }\n    // link the new states\n    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n    bypassStop.addTransition(new EpsilonTransition(endState));\n\n    var matchState = new BasicState();\n    atn.addState(matchState);\n    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n    bypassStart.addTransition(new EpsilonTransition(matchState));\n};\n\nATNDeserializer.prototype.stateIsEndStateFor = function(state, idx) {\n    if ( state.ruleIndex !== idx) {\n        return null;\n    }\n    if (!( state instanceof StarLoopEntryState)) {\n        return null;\n    }\n    var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n    if (!( maybeLoopEndState instanceof LoopEndState)) {\n        return null;\n    }\n    if (maybeLoopEndState.epsilonOnlyTransitions &&\n        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n        return state;\n    } else {\n        return null;\n    }\n};\n\n//\n// Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n// the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n// correct value.\n//\n// @param atn The ATN.\n//\nATNDeserializer.prototype.markPrecedenceDecisions = function(atn) {\n\tfor(var i=0; i<atn.states.length; i++) {\n\t\tvar state = atn.states[i];\n\t\tif (!( state instanceof StarLoopEntryState)) {\n            continue;\n        }\n        // We analyze the ATN to determine if this ATN decision state is the\n        // decision for the closure block that determines whether a\n        // precedence rule should continue or complete.\n        //\n        if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n            var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n            if (maybeLoopEndState instanceof LoopEndState) {\n                if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                    state.isPrecedenceDecision = true;\n                }\n            }\n        }\n\t}\n};\n\nATNDeserializer.prototype.verifyATN = function(atn) {\n    if (!this.deserializationOptions.verifyATN) {\n        return;\n    }\n    // verify assumptions\n\tfor(var i=0; i<atn.states.length; i++) {\n        var state = atn.states[i];\n        if (state === null) {\n            continue;\n        }\n        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n        if (state instanceof PlusBlockStartState) {\n            this.checkCondition(state.loopBackState !== null);\n        } else  if (state instanceof StarLoopEntryState) {\n            this.checkCondition(state.loopBackState !== null);\n            this.checkCondition(state.transitions.length === 2);\n            if (state.transitions[0].target instanceof StarBlockStartState) {\n                this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                this.checkCondition(!state.nonGreedy);\n            } else if (state.transitions[0].target instanceof LoopEndState) {\n                this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                this.checkCondition(state.nonGreedy);\n            } else {\n                throw(\"IllegalState\");\n            }\n        } else if (state instanceof StarLoopbackState) {\n            this.checkCondition(state.transitions.length === 1);\n            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n        } else if (state instanceof LoopEndState) {\n            this.checkCondition(state.loopBackState !== null);\n        } else if (state instanceof RuleStartState) {\n            this.checkCondition(state.stopState !== null);\n        } else if (state instanceof BlockStartState) {\n            this.checkCondition(state.endState !== null);\n        } else if (state instanceof BlockEndState) {\n            this.checkCondition(state.startState !== null);\n        } else if (state instanceof DecisionState) {\n            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n        } else {\n            this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n        }\n\t}\n};\n\nATNDeserializer.prototype.checkCondition = function(condition, message) {\n    if (!condition) {\n        if (message === undefined || message===null) {\n            message = \"IllegalState\";\n        }\n        throw (message);\n    }\n};\n\nATNDeserializer.prototype.readInt = function() {\n    return this.data[this.pos++];\n};\n\nATNDeserializer.prototype.readInt32 = function() {\n    var low = this.readInt();\n    var high = this.readInt();\n    return low | (high << 16);\n};\n\nATNDeserializer.prototype.readLong = function() {\n    var low = this.readInt32();\n    var high = this.readInt32();\n    return (low & 0x00000000FFFFFFFF) | (high << 32);\n};\n\nfunction createByteToHex() {\n\tvar bth = [];\n\tfor (var i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nvar byteToHex = createByteToHex();\n\nATNDeserializer.prototype.readUUID = function() {\n\tvar bb = [];\n\tfor(var i=7;i>=0;i--) {\n\t\tvar int = this.readInt();\n\t\t/* jshint bitwise: false */\n\t\tbb[(2*i)+1] = int & 0xFF;\n\t\tbb[2*i] = (int >> 8) & 0xFF;\n\t}\n    return byteToHex[bb[0]] + byteToHex[bb[1]] +\n    byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n    byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n    byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n    byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n    byteToHex[bb[10]] + byteToHex[bb[11]] +\n    byteToHex[bb[12]] + byteToHex[bb[13]] +\n    byteToHex[bb[14]] + byteToHex[bb[15]];\n};\n\nATNDeserializer.prototype.edgeFactory = function(atn, type, src, trg, arg1, arg2, arg3, sets) {\n    var target = atn.states[trg];\n    switch(type) {\n    case Transition.EPSILON:\n        return new EpsilonTransition(target);\n    case Transition.RANGE:\n        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n    case Transition.RULE:\n        return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n    case Transition.PREDICATE:\n        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n    case Transition.PRECEDENCE:\n        return new PrecedencePredicateTransition(target, arg1);\n    case Transition.ATOM:\n        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n    case Transition.ACTION:\n        return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n    case Transition.SET:\n        return new SetTransition(target, sets[arg1]);\n    case Transition.NOT_SET:\n        return new NotSetTransition(target, sets[arg1]);\n    case Transition.WILDCARD:\n        return new WildcardTransition(target);\n    default:\n        throw \"The specified transition type: \" + type + \" is not valid.\";\n    }\n};\n\nATNDeserializer.prototype.stateFactory = function(type, ruleIndex) {\n    if (this.stateFactories === null) {\n        var sf = [];\n        sf[ATNState.INVALID_TYPE] = null;\n        sf[ATNState.BASIC] = function() { return new BasicState(); };\n        sf[ATNState.RULE_START] = function() { return new RuleStartState(); };\n        sf[ATNState.BLOCK_START] = function() { return new BasicBlockStartState(); };\n        sf[ATNState.PLUS_BLOCK_START] = function() { return new PlusBlockStartState(); };\n        sf[ATNState.STAR_BLOCK_START] = function() { return new StarBlockStartState(); };\n        sf[ATNState.TOKEN_START] = function() { return new TokensStartState(); };\n        sf[ATNState.RULE_STOP] = function() { return new RuleStopState(); };\n        sf[ATNState.BLOCK_END] = function() { return new BlockEndState(); };\n        sf[ATNState.STAR_LOOP_BACK] = function() { return new StarLoopbackState(); };\n        sf[ATNState.STAR_LOOP_ENTRY] = function() { return new StarLoopEntryState(); };\n        sf[ATNState.PLUS_LOOP_BACK] = function() { return new PlusLoopbackState(); };\n        sf[ATNState.LOOP_END] = function() { return new LoopEndState(); };\n        this.stateFactories = sf;\n    }\n    if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n        throw(\"The specified state type \" + type + \" is not valid.\");\n    } else {\n        var s = this.stateFactories[type]();\n        if (s!==null) {\n            s.ruleIndex = ruleIndex;\n            return s;\n        }\n    }\n};\n\nATNDeserializer.prototype.lexerActionFactory = function(type, data1, data2) {\n    if (this.actionFactories === null) {\n        var af = [];\n        af[LexerActionType.CHANNEL] = function(data1, data2) { return new LexerChannelAction(data1); };\n        af[LexerActionType.CUSTOM] = function(data1, data2) { return new LexerCustomAction(data1, data2); };\n        af[LexerActionType.MODE] = function(data1, data2) { return new LexerModeAction(data1); };\n        af[LexerActionType.MORE] = function(data1, data2) { return LexerMoreAction.INSTANCE; };\n        af[LexerActionType.POP_MODE] = function(data1, data2) { return LexerPopModeAction.INSTANCE; };\n        af[LexerActionType.PUSH_MODE] = function(data1, data2) { return new LexerPushModeAction(data1); };\n        af[LexerActionType.SKIP] = function(data1, data2) { return LexerSkipAction.INSTANCE; };\n        af[LexerActionType.TYPE] = function(data1, data2) { return new LexerTypeAction(data1); };\n        this.actionFactories = af;\n    }\n    if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n        throw(\"The specified lexer action type \" + type + \" is not valid.\");\n    } else {\n        return this.actionFactories[type](data1, data2);\n    }\n};\n\n\nexports.ATNDeserializer = ATNDeserializer;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\nvar DFAState = require('./../dfa/DFAState').DFAState;\nvar ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;\nvar getCachedPredictionContext = require('./../PredictionContext').getCachedPredictionContext;\n\nfunction ATNSimulator(atn, sharedContextCache) {\n\n    // The context cache maps all PredictionContext objects that are ==\n    //  to a single cached copy. This cache is shared across all contexts\n    //  in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n    //  to use only cached nodes/graphs in addDFAState(). We don't want to\n    //  fill this during closure() since there are lots of contexts that\n    //  pop up but are not used ever again. It also greatly slows down closure().\n    //\n    //  <p>This cache makes a huge difference in memory and a little bit in speed.\n    //  For the Java grammar on java.*, it dropped the memory requirements\n    //  at the end from 25M to 16M. We don't store any of the full context\n    //  graphs in the DFA because they are limited to local context only,\n    //  but apparently there's a lot of repetition there as well. We optimize\n    //  the config contexts before storing the config set in the DFA states\n    //  by literally rebuilding them with cached subgraphs only.</p>\n    //\n    //  <p>I tried a cache for use during closure operations, that was\n    //  whacked after each adaptivePredict(). It cost a little bit\n    //  more time I think and doesn't save on the overall footprint\n    //  so it's not worth the complexity.</p>\n    ///\n    this.atn = atn;\n    this.sharedContextCache = sharedContextCache;\n    return this;\n}\n\n// Must distinguish between missing edge and edge we know leads nowhere///\nATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());\n\n\nATNSimulator.prototype.getCachedContext = function(context) {\n    if (this.sharedContextCache ===null) {\n        return context;\n    }\n    var visited = {};\n    return getCachedPredictionContext(context, this.sharedContextCache, visited);\n};\n\nexports.ATNSimulator = ATNSimulator;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n// The following images show the relation of states and\n// {@link ATNState//transitions} for various grammar constructs.\n//\n// <ul>\n//\n// <li>Solid edges marked with an &//0949; indicate a required\n// {@link EpsilonTransition}.</li>\n//\n// <li>Dashed edges indicate locations where any transition derived from\n// {@link Transition} might appear.</li>\n//\n// <li>Dashed nodes are place holders for either a sequence of linked\n// {@link BasicState} states or the inclusion of a block representing a nested\n// construct in one of the forms below.</li>\n//\n// <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n// any number of alternatives (one or more). Nodes without the {@code ...} only\n// support the exact number of alternatives shown in the diagram.</li>\n//\n// </ul>\n//\n// <h2>Basic Blocks</h2>\n//\n// <h3>Rule</h3>\n//\n// <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n//\n// <h3>Block of 1 or more alternatives</h3>\n//\n// <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n//\n// <h2>Greedy Loops</h2>\n//\n// <h3>Greedy Closure: {@code (...)*}</h3>\n//\n// <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n//\n// <h3>Greedy Positive Closure: {@code (...)+}</h3>\n//\n// <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n//\n// <h3>Greedy Optional: {@code (...)?}</h3>\n//\n// <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n//\n// <h2>Non-Greedy Loops</h2>\n//\n// <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n//\n// <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n//\n// <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n//\n// <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n//\n// <h3>Non-Greedy Optional: {@code (...)??}</h3>\n//\n// <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n//\n\nvar INITIAL_NUM_TRANSITIONS = 4;\n\nfunction ATNState() {\n    // Which ATN are we in?\n    this.atn = null;\n    this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n    this.stateType = null;\n    this.ruleIndex = 0; // at runtime, we don't have Rule objects\n    this.epsilonOnlyTransitions = false;\n    // Track the transitions emanating from this ATN state.\n    this.transitions = [];\n    // Used to cache lookahead during parsing, not used during construction\n    this.nextTokenWithinRule = null;\n    return this;\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\nATNState.prototype.toString = function() {\n\treturn this.stateNumber;\n};\n\nATNState.prototype.equals = function(other) {\n    if (other instanceof ATNState) {\n        return this.stateNumber===other.stateNumber;\n    } else {\n        return false;\n    }\n};\n\nATNState.prototype.isNonGreedyExitState = function() {\n    return false;\n};\n\n\nATNState.prototype.addTransition = function(trans, index) {\n\tif(index===undefined) {\n\t\tindex = -1;\n\t}\n    if (this.transitions.length===0) {\n        this.epsilonOnlyTransitions = trans.isEpsilon;\n    } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n        this.epsilonOnlyTransitions = false;\n    }\n    if (index===-1) {\n        this.transitions.push(trans);\n    } else {\n        this.transitions.splice(index, 1, trans);\n    }\n};\n\nfunction BasicState() {\n\tATNState.call(this);\n    this.stateType = ATNState.BASIC;\n    return this;\n}\n\nBasicState.prototype = Object.create(ATNState.prototype);\nBasicState.prototype.constructor = BasicState;\n\n\nfunction DecisionState() {\n\tATNState.call(this);\n    this.decision = -1;\n    this.nonGreedy = false;\n    return this;\n}\n\nDecisionState.prototype = Object.create(ATNState.prototype);\nDecisionState.prototype.constructor = DecisionState;\n\n\n//  The start of a regular {@code (...)} block.\nfunction BlockStartState() {\n\tDecisionState.call(this);\n\tthis.endState = null;\n\treturn this;\n}\n\nBlockStartState.prototype = Object.create(DecisionState.prototype);\nBlockStartState.prototype.constructor = BlockStartState;\n\n\nfunction BasicBlockStartState() {\n\tBlockStartState.call(this);\n\tthis.stateType = ATNState.BLOCK_START;\n\treturn this;\n}\n\nBasicBlockStartState.prototype = Object.create(BlockStartState.prototype);\nBasicBlockStartState.prototype.constructor = BasicBlockStartState;\n\n\n// Terminal node of a simple {@code (a|b|c)} block.\nfunction BlockEndState() {\n\tATNState.call(this);\n\tthis.stateType = ATNState.BLOCK_END;\n    this.startState = null;\n    return this;\n}\n\nBlockEndState.prototype = Object.create(ATNState.prototype);\nBlockEndState.prototype.constructor = BlockEndState;\n\n\n// The last node in the ATN for a rule, unless that rule is the start symbol.\n//  In that case, there is one transition to EOF. Later, we might encode\n//  references to all calls to this rule to compute FOLLOW sets for\n//  error handling.\n//\nfunction RuleStopState() {\n\tATNState.call(this);\n    this.stateType = ATNState.RULE_STOP;\n    return this;\n}\n\nRuleStopState.prototype = Object.create(ATNState.prototype);\nRuleStopState.prototype.constructor = RuleStopState;\n\nfunction RuleStartState() {\n\tATNState.call(this);\n\tthis.stateType = ATNState.RULE_START;\n\tthis.stopState = null;\n\tthis.isPrecedenceRule = false;\n\treturn this;\n}\n\nRuleStartState.prototype = Object.create(ATNState.prototype);\nRuleStartState.prototype.constructor = RuleStartState;\n\n// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n//  one to the loop back to start of the block and one to exit.\n//\nfunction PlusLoopbackState() {\n\tDecisionState.call(this);\n\tthis.stateType = ATNState.PLUS_LOOP_BACK;\n\treturn this;\n}\n\nPlusLoopbackState.prototype = Object.create(DecisionState.prototype);\nPlusLoopbackState.prototype.constructor = PlusLoopbackState;\n\n\n// Start of {@code (A|B|...)+} loop. Technically a decision state, but\n//  we don't use for code generation; somebody might need it, so I'm defining\n//  it for completeness. In reality, the {@link PlusLoopbackState} node is the\n//  real decision-making note for {@code A+}.\n//\nfunction PlusBlockStartState() {\n\tBlockStartState.call(this);\n\tthis.stateType = ATNState.PLUS_BLOCK_START;\n    this.loopBackState = null;\n    return this;\n}\n\nPlusBlockStartState.prototype = Object.create(BlockStartState.prototype);\nPlusBlockStartState.prototype.constructor = PlusBlockStartState;\n\n// The block that begins a closure loop.\nfunction StarBlockStartState() {\n\tBlockStartState.call(this);\n\tthis.stateType = ATNState.STAR_BLOCK_START;\n\treturn this;\n}\n\nStarBlockStartState.prototype = Object.create(BlockStartState.prototype);\nStarBlockStartState.prototype.constructor = StarBlockStartState;\n\n\nfunction StarLoopbackState() {\n\tATNState.call(this);\n\tthis.stateType = ATNState.STAR_LOOP_BACK;\n\treturn this;\n}\n\nStarLoopbackState.prototype = Object.create(ATNState.prototype);\nStarLoopbackState.prototype.constructor = StarLoopbackState;\n\n\nfunction StarLoopEntryState() {\n\tDecisionState.call(this);\n\tthis.stateType = ATNState.STAR_LOOP_ENTRY;\n    this.loopBackState = null;\n    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n    this.isPrecedenceDecision = null;\n    return this;\n}\n\nStarLoopEntryState.prototype = Object.create(DecisionState.prototype);\nStarLoopEntryState.prototype.constructor = StarLoopEntryState;\n\n\n// Mark the end of a * or + loop.\nfunction LoopEndState() {\n\tATNState.call(this);\n\tthis.stateType = ATNState.LOOP_END;\n\tthis.loopBackState = null;\n\treturn this;\n}\n\nLoopEndState.prototype = Object.create(ATNState.prototype);\nLoopEndState.prototype.constructor = LoopEndState;\n\n\n// The Tokens rule start state linking to each lexer rule start state */\nfunction TokensStartState() {\n\tDecisionState.call(this);\n\tthis.stateType = ATNState.TOKEN_START;\n\treturn this;\n}\n\nTokensStartState.prototype = Object.create(DecisionState.prototype);\nTokensStartState.prototype.constructor = TokensStartState;\n\nexports.ATNState = ATNState;\nexports.BasicState = BasicState;\nexports.DecisionState = DecisionState;\nexports.BlockStartState = BlockStartState;\nexports.BlockEndState = BlockEndState;\nexports.LoopEndState = LoopEndState;\nexports.RuleStartState = RuleStartState;\nexports.RuleStopState = RuleStopState;\nexports.TokensStartState = TokensStartState;\nexports.PlusLoopbackState = PlusLoopbackState;\nexports.StarLoopbackState = StarLoopbackState;\nexports.StarLoopEntryState = StarLoopEntryState;\nexports.PlusBlockStartState = PlusBlockStartState;\nexports.StarBlockStartState = StarBlockStartState;\nexports.BasicBlockStartState = BasicBlockStartState;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// Represents the type of recognizer an ATN applies to.\n\nfunction ATNType() {\n\n}\n\nATNType.LEXER = 0;\nATNType.PARSER = 1;\n\nexports.ATNType = ATNType;\n\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// When we hit an accept state in either the DFA or the ATN, we\n//  have to notify the character stream to start buffering characters\n//  via {@link IntStream//mark} and record the current state. The current sim state\n//  includes the current index into the input, the current line,\n//  and current character position in that line. Note that the Lexer is\n//  tracking the starting line and characterization of the token. These\n//  variables track the \"state\" of the simulator when it hits an accept state.\n//\n//  <p>We track these variables separately for the DFA and ATN simulation\n//  because the DFA simulation often has to fail over to the ATN\n//  simulation. If the ATN simulation fails, we need the DFA to fall\n//  back to its previously accepted state, if any. If the ATN succeeds,\n//  then the ATN does the accept and the DFA simulator that invoked it\n//  can simply return the predicted token type.</p>\n///\n\nvar Token = require('./../Token').Token;\nvar Lexer = require('./../Lexer').Lexer;\nvar ATN = require('./ATN').ATN;\nvar ATNSimulator = require('./ATNSimulator').ATNSimulator;\nvar DFAState = require('./../dfa/DFAState').DFAState;\nvar ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;\nvar OrderedATNConfigSet = require('./ATNConfigSet').OrderedATNConfigSet;\nvar PredictionContext = require('./../PredictionContext').PredictionContext;\nvar SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;\nvar RuleStopState = require('./ATNState').RuleStopState;\nvar LexerATNConfig = require('./ATNConfig').LexerATNConfig;\nvar Transition = require('./Transition').Transition;\nvar LexerActionExecutor = require('./LexerActionExecutor').LexerActionExecutor;\nvar LexerNoViableAltException = require('./../error/Errors').LexerNoViableAltException;\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nfunction SimState() {\n\tresetSimState(this);\n\treturn this;\n}\n\nSimState.prototype.reset = function() {\n\tresetSimState(this);\n};\n\nfunction LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {\n\tATNSimulator.call(this, atn, sharedContextCache);\n\tthis.decisionToDFA = decisionToDFA;\n\tthis.recog = recog;\n\t// The current token's starting index into the character stream.\n\t// Shared across DFA to ATN simulation in case the ATN fails and the\n\t// DFA did not have a previous accept state. In this case, we use the\n\t// ATN-generated exception object.\n\tthis.startIndex = -1;\n\t// line number 1..n within the input///\n\tthis.line = 1;\n\t// The index of the character relative to the beginning of the line\n\t// 0..n-1///\n\tthis.column = 0;\n\tthis.mode = Lexer.DEFAULT_MODE;\n\t// Used during DFA/ATN exec to record the most recent accept configuration\n\t// info\n\tthis.prevAccept = new SimState();\n\t// done\n\treturn this;\n}\n\nLexerATNSimulator.prototype = Object.create(ATNSimulator.prototype);\nLexerATNSimulator.prototype.constructor = LexerATNSimulator;\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nLexerATNSimulator.prototype.copyState = function(simulator) {\n\tthis.column = simulator.column;\n\tthis.line = simulator.line;\n\tthis.mode = simulator.mode;\n\tthis.startIndex = simulator.startIndex;\n};\n\nLexerATNSimulator.prototype.match = function(input, mode) {\n\tthis.match_calls += 1;\n\tthis.mode = mode;\n\tvar mark = input.mark();\n\ttry {\n\t\tthis.startIndex = input.index;\n\t\tthis.prevAccept.reset();\n\t\tvar dfa = this.decisionToDFA[mode];\n\t\tif (dfa.s0 === null) {\n\t\t\treturn this.matchATN(input);\n\t\t} else {\n\t\t\treturn this.execATN(input, dfa.s0);\n\t\t}\n\t} finally {\n\t\tinput.release(mark);\n\t}\n};\n\nLexerATNSimulator.prototype.reset = function() {\n\tthis.prevAccept.reset();\n\tthis.startIndex = -1;\n\tthis.line = 1;\n\tthis.column = 0;\n\tthis.mode = Lexer.DEFAULT_MODE;\n};\n\nLexerATNSimulator.prototype.matchATN = function(input) {\n\tvar startState = this.atn.modeToStartState[this.mode];\n\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t}\n\tvar old_mode = this.mode;\n\tvar s0_closure = this.computeStartState(input, startState);\n\tvar suppressEdge = s0_closure.hasSemanticContext;\n\ts0_closure.hasSemanticContext = false;\n\n\tvar next = this.addDFAState(s0_closure);\n\tif (!suppressEdge) {\n\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t}\n\n\tvar predict = this.execATN(input, next);\n\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t}\n\treturn predict;\n};\n\nLexerATNSimulator.prototype.execATN = function(input, ds0) {\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t}\n\tif (ds0.isAcceptState) {\n\t\t// allow zero-length tokens\n\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t}\n\tvar t = input.LA(1);\n\tvar s = ds0; // s is current/from DFA state\n\n\twhile (true) { // while more work\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t}\n\n\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t// If the previous target was already part of the DFA, we might\n\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t// it means that semantic predicates didn't prevent us from\n\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t// it's configuration set; there's no point in re-computing it.\n\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t// computing reach/closure sets. Technically, once we know that\n\t\t// we have a previously added DFA state, we could jump over to\n\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t// a lot and making things more complicated algorithmically.\n\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t// A character will take us back to an existing DFA state\n\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t// print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\tvar target = this.getExistingTargetState(s, t);\n\t\t// print(\"Existing:\" + str(target))\n\t\tif (target === null) {\n\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t// print(\"Computed:\" + str(target))\n\t\t}\n\t\tif (target === ATNSimulator.ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\t// If this is a consumable input element, make sure to consume before\n\t\t// capturing the accept state so the input index, line, and char\n\t\t// position accurately reflect the state of the interpreter at the\n\t\t// end of the token.\n\t\tif (t !== Token.EOF) {\n\t\t\tthis.consume(input);\n\t\t}\n\t\tif (target.isAcceptState) {\n\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\tif (t === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt = input.LA(1);\n\t\ts = target; // flip; current DFA target becomes new src/from state\n\t}\n\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n};\n\n// Get an existing target state for an edge in the DFA. If the target state\n// for the edge has not yet been computed or is otherwise not available,\n// this method returns {@code null}.\n//\n// @param s The current DFA state\n// @param t The next input symbol\n// @return The existing target DFA state for the given input symbol\n// {@code t}, or {@code null} if the target state for this edge is not\n// already cached\nLexerATNSimulator.prototype.getExistingTargetState = function(s, t) {\n\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\treturn null;\n\t}\n\n\tvar target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\tif(target===undefined) {\n\t\ttarget = null;\n\t}\n\tif (LexerATNSimulator.debug && target !== null) {\n\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t}\n\treturn target;\n};\n\n// Compute a target state for an edge in the DFA, and attempt to add the\n// computed state and corresponding edge to the DFA.\n//\n// @param input The input stream\n// @param s The current DFA state\n// @param t The next input symbol\n//\n// @return The computed target DFA state for the given input symbol\n// {@code t}. If {@code t} does not lead to a valid DFA state, this method\n// returns {@link //ERROR}.\nLexerATNSimulator.prototype.computeTargetState = function(input, s, t) {\n\tvar reach = new OrderedATNConfigSet();\n\t// if we don't find an existing DFA state\n\t// Fill reach starting from closure, following t transitions\n\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\tif (!reach.hasSemanticContext) {\n\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t// cause a failover from DFA later.\n\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t}\n\t\t// stop when we can't match any more char\n\t\treturn ATNSimulator.ERROR;\n\t}\n\t// Add an edge from s to target DFA found/created for reach\n\treturn this.addDFAEdge(s, t, null, reach);\n};\n\nLexerATNSimulator.prototype.failOrAccept = function(prevAccept, input, reach, t) {\n\tif (this.prevAccept.dfaState !== null) {\n\t\tvar lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\treturn prevAccept.dfaState.prediction;\n\t} else {\n\t\t// if no accept and EOF is first char, return EOF\n\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\treturn Token.EOF;\n\t\t}\n\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t}\n};\n\n// Given a starting configuration set, figure out all ATN configurations\n// we can reach upon input {@code t}. Parameter {@code reach} is a return\n// parameter.\nLexerATNSimulator.prototype.getReachableConfigSet = function(input, closure,\n\t\treach, t) {\n\t// this is used to skip processing for configs which have a lower priority\n\t// than a config that already reached an accept state for the same rule\n\tvar skipAlt = ATN.INVALID_ALT_NUMBER;\n\tfor (var i = 0; i < closure.items.length; i++) {\n\t\tvar cfg = closure.items[i];\n\t\tvar currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t.toString(this.recog, true));\n\t\t}\n\t\tfor (var j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\tvar trans = cfg.state.transitions[j]; // for each transition\n\t\t\tvar target = this.getReachableTarget(trans, t);\n\t\t\tif (target !== null) {\n\t\t\t\tvar lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t}\n\t\t\t\tvar treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\tvar config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nLexerATNSimulator.prototype.accept = function(input, lexerActionExecutor,\n\t\tstartIndex, index, line, charPos) {\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t}\n\t// seek to after last char in token\n\tinput.seek(index);\n\tthis.line = line;\n\tthis.column = charPos;\n\tif (lexerActionExecutor !== null && this.recog !== null) {\n\t\tlexerActionExecutor.execute(this.recog, input, startIndex);\n\t}\n};\n\nLexerATNSimulator.prototype.getReachableTarget = function(trans, t) {\n\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\treturn trans.target;\n\t} else {\n\t\treturn null;\n\t}\n};\n\nLexerATNSimulator.prototype.computeStartState = function(input, p) {\n\tvar initialContext = PredictionContext.EMPTY;\n\tvar configs = new OrderedATNConfigSet();\n\tfor (var i = 0; i < p.transitions.length; i++) {\n\t\tvar target = p.transitions[i].target;\n        var cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\tthis.closure(input, cfg, configs, false, false, false);\n\t}\n\treturn configs;\n};\n\n// Since the alternatives within any lexer decision are ordered by\n// preference, this method stops pursuing the closure as soon as an accept\n// state is reached. After the first accept state is reached by depth-first\n// search from {@code config}, all other (potentially reachable) states for\n// this rule would have a lower priority.\n//\n// @return {@code true} if an accept state is reached, otherwise\n// {@code false}.\nLexerATNSimulator.prototype.closure = function(input, config, configs,\n\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\tvar cfg = null;\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t}\n\tif (config.state instanceof RuleStopState) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tif (this.recog !== null) {\n\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t} else {\n\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t}\n\t\t}\n\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t}\n\t\t}\n\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\tfor (var i = 0; i < config.context.length; i++) {\n\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\tvar newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\tvar returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\t// optimization\n\tif (!config.state.epsilonOnlyTransitions) {\n\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\tconfigs.add(config);\n\t\t}\n\t}\n\tfor (var j = 0; j < config.state.transitions.length; j++) {\n\t\tvar trans = config.state.transitions[j];\n\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\tif (cfg !== null) {\n\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t}\n\t}\n\treturn currentAltReachedAcceptState;\n};\n\n// side-effect: can alter configs.hasSemanticContext\nLexerATNSimulator.prototype.getEpsilonTarget = function(input, config, trans,\n\t\tconfigs, speculative, treatEofAsEpsilon) {\n\tvar cfg = null;\n\tif (trans.serializationType === Transition.RULE) {\n\t\tvar newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t// Track traversing semantic predicates. If we traverse,\n\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t// because the DFA would not test the predicate again in the\n\t\t// future. Rather than creating collections of semantic predicates\n\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t// semantically it's not used that often. One of the key elements to\n\t\t// this predicate mechanism is not adding DFA states that see\n\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t// should create the start state for rule 'a' (to save start state\n\t\t// competition), but should not create target of ID state. The\n\t\t// collection of ATN states the following ID references includes\n\t\t// states reached by traversing predicates. Since this is when we\n\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t}\n\t\tconfigs.hasSemanticContext = true;\n\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t}\n\t} else if (trans.serializationType === Transition.ACTION) {\n\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t//\n\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t// actions may be executed during the recursive call. The\n\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t// split into two contexts - one with just the empty path\n\t\t\t// and another with everything but the empty path.\n\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t// additional modifications are needed before we can support\n\t\t\t// the split operation.\n\t\t\tvar lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t} else {\n\t\t\t// ignore actions in referenced rules\n\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t}\n\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\tif (treatEofAsEpsilon) {\n\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t}\n\t\t}\n\t}\n\treturn cfg;\n};\n\n// Evaluate a predicate specified in the lexer.\n//\n// <p>If {@code speculative} is {@code true}, this method was called before\n// {@link //consume} for the matched character. This method should call\n// {@link //consume} before evaluating the predicate to ensure position\n// sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n// and {@link Lexer//getcolumn}, properly reflect the current\n// lexer state. This method should restore {@code input} and the simulator\n// to the original state before returning (i.e. undo the actions made by the\n// call to {@link //consume}.</p>\n//\n// @param input The input stream.\n// @param ruleIndex The rule containing the predicate.\n// @param predIndex The index of the predicate within the rule.\n// @param speculative {@code true} if the current index in {@code input} is\n// one character before the predicate's location.\n//\n// @return {@code true} if the specified predicate evaluates to\n// {@code true}.\n// /\nLexerATNSimulator.prototype.evaluatePredicate = function(input, ruleIndex,\n\t\tpredIndex, speculative) {\n\t// assume true if no recognizer was provided\n\tif (this.recog === null) {\n\t\treturn true;\n\t}\n\tif (!speculative) {\n\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t}\n\tvar savedcolumn = this.column;\n\tvar savedLine = this.line;\n\tvar index = input.index;\n\tvar marker = input.mark();\n\ttry {\n\t\tthis.consume(input);\n\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t} finally {\n\t\tthis.column = savedcolumn;\n\t\tthis.line = savedLine;\n\t\tinput.seek(index);\n\t\tinput.release(marker);\n\t}\n};\n\nLexerATNSimulator.prototype.captureSimState = function(settings, input, dfaState) {\n\tsettings.index = input.index;\n\tsettings.line = this.line;\n\tsettings.column = this.column;\n\tsettings.dfaState = dfaState;\n};\n\nLexerATNSimulator.prototype.addDFAEdge = function(from_, tk, to, cfgs) {\n\tif (to === undefined) {\n\t\tto = null;\n\t}\n\tif (cfgs === undefined) {\n\t\tcfgs = null;\n\t}\n\tif (to === null && cfgs !== null) {\n\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t// following the predicate evaluation step.\n\t\t//\n\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t// state, we can continue in pure DFA mode from there.\n\t\t// /\n\t\tvar suppressEdge = cfgs.hasSemanticContext;\n\t\tcfgs.hasSemanticContext = false;\n\n\t\tto = this.addDFAState(cfgs);\n\n\t\tif (suppressEdge) {\n\t\t\treturn to;\n\t\t}\n\t}\n\t// add the edge\n\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t// Only track edges within the DFA bounds\n\t\treturn to;\n\t}\n\tif (LexerATNSimulator.debug) {\n\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t}\n\tif (from_.edges === null) {\n\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\tfrom_.edges = [];\n\t}\n\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\treturn to;\n};\n\n// Add a new DFA state if there isn't one with this set of\n// configurations already. This method also detects the first\n// configuration containing an ATN rule stop state. Later, when\n// traversing the DFA, we will know which rule to accept.\nLexerATNSimulator.prototype.addDFAState = function(configs) {\n\tvar proposed = new DFAState(null, configs);\n\tvar firstConfigWithRuleStopState = null;\n\tfor (var i = 0; i < configs.items.length; i++) {\n\t\tvar cfg = configs.items[i];\n\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (firstConfigWithRuleStopState !== null) {\n\t\tproposed.isAcceptState = true;\n\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t}\n\tvar dfa = this.decisionToDFA[this.mode];\n\tvar existing = dfa.states.get(proposed);\n\tif (existing!==null) {\n\t\treturn existing;\n\t}\n\tvar newState = proposed;\n\tnewState.stateNumber = dfa.states.length;\n\tconfigs.setReadonly(true);\n\tnewState.configs = configs;\n\tdfa.states.add(newState);\n\treturn newState;\n};\n\nLexerATNSimulator.prototype.getDFA = function(mode) {\n\treturn this.decisionToDFA[mode];\n};\n\n// Get the text matched so far for the current token.\nLexerATNSimulator.prototype.getText = function(input) {\n\t// index is first lookahead char, don't include.\n\treturn input.getText(this.startIndex, input.index - 1);\n};\n\nLexerATNSimulator.prototype.consume = function(input) {\n\tvar curChar = input.LA(1);\n\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\tthis.line += 1;\n\t\tthis.column = 0;\n\t} else {\n\t\tthis.column += 1;\n\t}\n\tinput.consume();\n};\n\nLexerATNSimulator.prototype.getTokenName = function(tt) {\n\tif (tt === -1) {\n\t\treturn \"EOF\";\n\t} else {\n\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t}\n};\n\nexports.LexerATNSimulator = LexerATNSimulator;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n //\n\nfunction LexerActionType() {\n}\n\nLexerActionType.CHANNEL = 0;     //The type of a {@link LexerChannelAction} action.\nLexerActionType.CUSTOM = 1;      //The type of a {@link LexerCustomAction} action.\nLexerActionType.MODE = 2;        //The type of a {@link LexerModeAction} action.\nLexerActionType.MORE = 3;        //The type of a {@link LexerMoreAction} action.\nLexerActionType.POP_MODE = 4;    //The type of a {@link LexerPopModeAction} action.\nLexerActionType.PUSH_MODE = 5;   //The type of a {@link LexerPushModeAction} action.\nLexerActionType.SKIP = 6;        //The type of a {@link LexerSkipAction} action.\nLexerActionType.TYPE = 7;        //The type of a {@link LexerTypeAction} action.\n\nfunction LexerAction(action) {\n    this.actionType = action;\n    this.isPositionDependent = false;\n    return this;\n}\n\nLexerAction.prototype.hashCode = function() {\n    var hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish()\n};\n\nLexerAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType);\n};\n\nLexerAction.prototype.equals = function(other) {\n    return this === other;\n};\n\n\n\n//\n// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n//\n// <p>The {@code skip} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\nfunction LexerSkipAction() {\n\tLexerAction.call(this, LexerActionType.SKIP);\n\treturn this;\n}\n\nLexerSkipAction.prototype = Object.create(LexerAction.prototype);\nLexerSkipAction.prototype.constructor = LexerSkipAction;\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\nLexerSkipAction.prototype.execute = function(lexer) {\n    lexer.skip();\n};\n\nLexerSkipAction.prototype.toString = function() {\n\treturn \"skip\";\n};\n\n//  Implements the {@code type} lexer action by calling {@link Lexer//setType}\n// with the assigned type.\nfunction LexerTypeAction(type) {\n\tLexerAction.call(this, LexerActionType.TYPE);\n\tthis.type = type;\n\treturn this;\n}\n\nLexerTypeAction.prototype = Object.create(LexerAction.prototype);\nLexerTypeAction.prototype.constructor = LexerTypeAction;\n\nLexerTypeAction.prototype.execute = function(lexer) {\n    lexer.type = this.type;\n};\n\nLexerTypeAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.type);\n};\n\n\nLexerTypeAction.prototype.equals = function(other) {\n    if(this === other) {\n        return true;\n    } else if (! (other instanceof LexerTypeAction)) {\n        return false;\n    } else {\n        return this.type === other.type;\n    }\n};\n\nLexerTypeAction.prototype.toString = function() {\n    return \"type(\" + this.type + \")\";\n};\n\n// Implements the {@code pushMode} lexer action by calling\n// {@link Lexer//pushMode} with the assigned mode.\nfunction LexerPushModeAction(mode) {\n\tLexerAction.call(this, LexerActionType.PUSH_MODE);\n    this.mode = mode;\n    return this;\n}\n\nLexerPushModeAction.prototype = Object.create(LexerAction.prototype);\nLexerPushModeAction.prototype.constructor = LexerPushModeAction;\n\n// <p>This action is implemented by calling {@link Lexer//pushMode} with the\n// value provided by {@link //getMode}.</p>\nLexerPushModeAction.prototype.execute = function(lexer) {\n    lexer.pushMode(this.mode);\n};\n\nLexerPushModeAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.mode);\n};\n\nLexerPushModeAction.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof LexerPushModeAction)) {\n        return false;\n    } else {\n        return this.mode === other.mode;\n    }\n};\n\nLexerPushModeAction.prototype.toString = function() {\n\treturn \"pushMode(\" + this.mode + \")\";\n};\n\n\n// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n//\n// <p>The {@code popMode} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\nfunction LexerPopModeAction() {\n\tLexerAction.call(this,LexerActionType.POP_MODE);\n\treturn this;\n}\n\nLexerPopModeAction.prototype = Object.create(LexerAction.prototype);\nLexerPopModeAction.prototype.constructor = LexerPopModeAction;\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n// <p>This action is implemented by calling {@link Lexer//popMode}.</p>\nLexerPopModeAction.prototype.execute = function(lexer) {\n    lexer.popMode();\n};\n\nLexerPopModeAction.prototype.toString = function() {\n\treturn \"popMode\";\n};\n\n// Implements the {@code more} lexer action by calling {@link Lexer//more}.\n//\n// <p>The {@code more} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\nfunction LexerMoreAction() {\n\tLexerAction.call(this, LexerActionType.MORE);\n\treturn this;\n}\n\nLexerMoreAction.prototype = Object.create(LexerAction.prototype);\nLexerMoreAction.prototype.constructor = LexerMoreAction;\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n// <p>This action is implemented by calling {@link Lexer//popMode}.</p>\nLexerMoreAction.prototype.execute = function(lexer) {\n    lexer.more();\n};\n\nLexerMoreAction.prototype.toString = function() {\n    return \"more\";\n};\n\n\n// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n// the assigned mode.\nfunction LexerModeAction(mode) {\n\tLexerAction.call(this, LexerActionType.MODE);\n    this.mode = mode;\n    return this;\n}\n\nLexerModeAction.prototype = Object.create(LexerAction.prototype);\nLexerModeAction.prototype.constructor = LexerModeAction;\n\n// <p>This action is implemented by calling {@link Lexer//mode} with the\n// value provided by {@link //getMode}.</p>\nLexerModeAction.prototype.execute = function(lexer) {\n    lexer.mode(this.mode);\n};\n\nLexerModeAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.mode);\n};\n\nLexerModeAction.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof LexerModeAction)) {\n        return false;\n    } else {\n        return this.mode === other.mode;\n    }\n};\n\nLexerModeAction.prototype.toString = function() {\n    return \"mode(\" + this.mode + \")\";\n};\n\n// Executes a custom lexer action by calling {@link Recognizer//action} with the\n// rule and action indexes assigned to the custom action. The implementation of\n// a custom action is added to the generated code for the lexer in an override\n// of {@link Recognizer//action} when the grammar is compiled.\n//\n// <p>This class may represent embedded actions created with the <code>{...}</code>\n// syntax in ANTLR 4, as well as actions created for lexer commands where the\n// command argument could not be evaluated when the grammar was compiled.</p>\n\n\n    // Constructs a custom lexer action with the specified rule and action\n    // indexes.\n    //\n    // @param ruleIndex The rule index to use for calls to\n    // {@link Recognizer//action}.\n    // @param actionIndex The action index to use for calls to\n    // {@link Recognizer//action}.\n\nfunction LexerCustomAction(ruleIndex, actionIndex) {\n\tLexerAction.call(this, LexerActionType.CUSTOM);\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex;\n    this.isPositionDependent = true;\n    return this;\n}\n\nLexerCustomAction.prototype = Object.create(LexerAction.prototype);\nLexerCustomAction.prototype.constructor = LexerCustomAction;\n\n// <p>Custom actions are implemented by calling {@link Lexer//action} with the\n// appropriate rule and action indexes.</p>\nLexerCustomAction.prototype.execute = function(lexer) {\n    lexer.action(null, this.ruleIndex, this.actionIndex);\n};\n\nLexerCustomAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n};\n\nLexerCustomAction.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof LexerCustomAction)) {\n        return false;\n    } else {\n        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n    }\n};\n\n// Implements the {@code channel} lexer action by calling\n// {@link Lexer//setChannel} with the assigned channel.\n// Constructs a new {@code channel} action with the specified channel value.\n// @param channel The channel value to pass to {@link Lexer//setChannel}.\nfunction LexerChannelAction(channel) {\n\tLexerAction.call(this, LexerActionType.CHANNEL);\n    this.channel = channel;\n    return this;\n}\n\nLexerChannelAction.prototype = Object.create(LexerAction.prototype);\nLexerChannelAction.prototype.constructor = LexerChannelAction;\n\n// <p>This action is implemented by calling {@link Lexer//setChannel} with the\n// value provided by {@link //getChannel}.</p>\nLexerChannelAction.prototype.execute = function(lexer) {\n    lexer._channel = this.channel;\n};\n\nLexerChannelAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.channel);\n};\n\nLexerChannelAction.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof LexerChannelAction)) {\n        return false;\n    } else {\n        return this.channel === other.channel;\n    }\n};\n\nLexerChannelAction.prototype.toString = function() {\n    return \"channel(\" + this.channel + \")\";\n};\n\n// This implementation of {@link LexerAction} is used for tracking input offsets\n// for position-dependent actions within a {@link LexerActionExecutor}.\n//\n// <p>This action is not serialized as part of the ATN, and is only required for\n// position-dependent lexer actions which appear at a location other than the\n// end of a rule. For more information about DFA optimizations employed for\n// lexer actions, see {@link LexerActionExecutor//append} and\n// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n\n// Constructs a new indexed custom action by associating a character offset\n// with a {@link LexerAction}.\n//\n// <p>Note: This class is only required for lexer actions for which\n// {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n//\n// @param offset The offset into the input {@link CharStream}, relative to\n// the token start index, at which the specified lexer action should be\n// executed.\n// @param action The lexer action to execute at a particular offset in the\n// input {@link CharStream}.\nfunction LexerIndexedCustomAction(offset, action) {\n\tLexerAction.call(this, action.actionType);\n    this.offset = offset;\n    this.action = action;\n    this.isPositionDependent = true;\n    return this;\n}\n\nLexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);\nLexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction;\n\n// <p>This method calls {@link //execute} on the result of {@link //getAction}\n// using the provided {@code lexer}.</p>\nLexerIndexedCustomAction.prototype.execute = function(lexer) {\n    // assume the input stream position was properly set by the calling code\n    this.action.execute(lexer);\n};\n\nLexerIndexedCustomAction.prototype.updateHashCode = function(hash) {\n    hash.update(this.actionType, this.offset, this.action);\n};\n\nLexerIndexedCustomAction.prototype.equals = function(other) {\n    if (this === other) {\n        return true;\n    } else if (! (other instanceof LexerIndexedCustomAction)) {\n        return false;\n    } else {\n        return this.offset === other.offset && this.action === other.action;\n    }\n};\n\n\nexports.LexerActionType = LexerActionType;\nexports.LexerSkipAction = LexerSkipAction;\nexports.LexerChannelAction = LexerChannelAction;\nexports.LexerCustomAction = LexerCustomAction;\nexports.LexerIndexedCustomAction = LexerIndexedCustomAction;\nexports.LexerMoreAction = LexerMoreAction;\nexports.LexerTypeAction = LexerTypeAction;\nexports.LexerPushModeAction = LexerPushModeAction;\nexports.LexerPopModeAction = LexerPopModeAction;\nexports.LexerModeAction = LexerModeAction;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// Represents an executor for a sequence of lexer actions which traversed during\n// the matching operation of a lexer rule (token).\n//\n// <p>The executor tracks position information for position-dependent lexer actions\n// efficiently, ensuring that actions appearing only at the end of the rule do\n// not cause bloating of the {@link DFA} created for the lexer.</p>\n\nvar hashStuff = require(\"../Utils\").hashStuff;\nvar LexerIndexedCustomAction = require('./LexerAction').LexerIndexedCustomAction;\n\nfunction LexerActionExecutor(lexerActions) {\n\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t// Caches the result of {@link //hashCode} since the hash code is an element\n\t// of the performance-critical {@link LexerATNConfig//hashCode} operation.\n\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t// lexerActions]))\n\treturn this;\n}\n\n// Creates a {@link LexerActionExecutor} which executes the actions for\n// the input {@code lexerActionExecutor} followed by a specified\n// {@code lexerAction}.\n//\n// @param lexerActionExecutor The executor for actions already traversed by\n// the lexer while matching a token within a particular\n// {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n// though it were an empty executor.\n// @param lexerAction The lexer action to execute after the actions\n// specified in {@code lexerActionExecutor}.\n//\n// @return A {@link LexerActionExecutor} for executing the combine actions\n// of {@code lexerActionExecutor} and {@code lexerAction}.\nLexerActionExecutor.append = function(lexerActionExecutor, lexerAction) {\n\tif (lexerActionExecutor === null) {\n\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t}\n\tvar lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\treturn new LexerActionExecutor(lexerActions);\n};\n\n// Creates a {@link LexerActionExecutor} which encodes the current offset\n// for position-dependent lexer actions.\n//\n// <p>Normally, when the executor encounters lexer actions where\n// {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n// {@link IntStream//seek} on the input {@link CharStream} to set the input\n// position to the <em>end</em> of the current token. This behavior provides\n// for efficient DFA representation of lexer actions which appear at the end\n// of a lexer rule, even when the lexer rule matches a variable number of\n// characters.</p>\n//\n// <p>Prior to traversing a match transition in the ATN, the current offset\n// from the token start index is assigned to all position-dependent lexer\n// actions which have not already been assigned a fixed offset. By storing\n// the offsets relative to the token start index, the DFA representation of\n// lexer actions which appear in the middle of tokens remains efficient due\n// to sharing among tokens of the same length, regardless of their absolute\n// position in the input stream.</p>\n//\n// <p>If the current executor already has offsets assigned to all\n// position-dependent lexer actions, the method returns {@code this}.</p>\n//\n// @param offset The current offset to assign to all position-dependent\n// lexer actions which do not already have offsets assigned.\n//\n// @return A {@link LexerActionExecutor} which stores input stream offsets\n// for all position-dependent lexer actions.\n// /\nLexerActionExecutor.prototype.fixOffsetBeforeMatch = function(offset) {\n\tvar updatedLexerActions = null;\n\tfor (var i = 0; i < this.lexerActions.length; i++) {\n\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\tif (updatedLexerActions === null) {\n\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t}\n\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\tthis.lexerActions[i]);\n\t\t}\n\t}\n\tif (updatedLexerActions === null) {\n\t\treturn this;\n\t} else {\n\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t}\n};\n\n// Execute the actions encapsulated by this executor within the context of a\n// particular {@link Lexer}.\n//\n// <p>This method calls {@link IntStream//seek} to set the position of the\n// {@code input} {@link CharStream} prior to calling\n// {@link LexerAction//execute} on a position-dependent action. Before the\n// method returns, the input position will be restored to the same position\n// it was in when the method was invoked.</p>\n//\n// @param lexer The lexer instance.\n// @param input The input stream which is the source for the current token.\n// When this method is called, the current {@link IntStream//index} for\n// {@code input} should be the start of the following token, i.e. 1\n// character past the end of the current token.\n// @param startIndex The token start index. This value may be passed to\n// {@link IntStream//seek} to set the {@code input} position to the beginning\n// of the token.\n// /\nLexerActionExecutor.prototype.execute = function(lexer, input, startIndex) {\n\tvar requiresSeek = false;\n\tvar stopIndex = input.index;\n\ttry {\n\t\tfor (var i = 0; i < this.lexerActions.length; i++) {\n\t\t\tvar lexerAction = this.lexerActions[i];\n\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\tvar offset = lexerAction.offset;\n\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t\trequiresSeek = false;\n\t\t\t}\n\t\t\tlexerAction.execute(lexer);\n\t\t}\n\t} finally {\n\t\tif (requiresSeek) {\n\t\t\tinput.seek(stopIndex);\n\t\t}\n\t}\n};\n\nLexerActionExecutor.prototype.hashCode = function() {\n\treturn this.cachedHashCode;\n};\n\nLexerActionExecutor.prototype.updateHashCode = function(hash) {\n    hash.update(this.cachedHashCode);\n};\n\n\nLexerActionExecutor.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\treturn false;\n\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\treturn false;\n\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\treturn false;\n\t} else {\n\t\tvar numActions = this.lexerActions.length\n\t\tfor (var idx = 0; idx < numActions; ++idx) {\n\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nexports.LexerActionExecutor = LexerActionExecutor;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n//\n// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n//\n// <p>\n// The basic complexity of the adaptive strategy makes it harder to understand.\n// We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n// requests go through the DFA first. If they reach a state without an edge for\n// the current symbol, the algorithm fails over to the ATN simulation to\n// complete the DFA path for the current input (until it finds a conflict state\n// or uniquely predicting state).</p>\n//\n// <p>\n// All of that is done without using the outer context because we want to create\n// a DFA that is not dependent upon the rule invocation stack when we do a\n// prediction. One DFA works in all contexts. We avoid using context not\n// necessarily because it's slower, although it can be, but because of the DFA\n// caching problem. The closure routine only considers the rule invocation stack\n// created during prediction beginning in the decision rule. For example, if\n// prediction occurs without invoking another rule's ATN, there are no context\n// stacks in the configurations. When lack of context leads to a conflict, we\n// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n// strategy (versus full LL(*)).</p>\n//\n// <p>\n// When SLL yields a configuration set with conflict, we rewind the input and\n// retry the ATN simulation, this time using full outer context without adding\n// to the DFA. Configuration context stacks will be the full invocation stacks\n// from the start rule. If we get a conflict using full context, then we can\n// definitively say we have a true ambiguity for that input sequence. If we\n// don't get a conflict, it implies that the decision is sensitive to the outer\n// context. (It is not context-sensitive in the sense of context-sensitive\n// grammars.)</p>\n//\n// <p>\n// The next time we reach this DFA state with an SLL conflict, through DFA\n// simulation, we will again retry the ATN simulation using full context mode.\n// This is slow because we can't save the results and have to \"interpret\" the\n// ATN each time we get that input.</p>\n//\n// <p>\n// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n//\n// <p>\n// We could cache results from full context to predicted alternative easily and\n// that saves a lot of time but doesn't work in presence of predicates. The set\n// of visible predicates from the ATN start state changes depending on the\n// context, because closure can fall off the end of a rule. I tried to cache\n// tuples (stack context, semantic context, predicted alt) but it was slower\n// than interpreting and much more complicated. Also required a huge amount of\n// memory. The goal is not to create the world's fastest parser anyway. I'd like\n// to keep this algorithm simple. By launching multiple threads, we can improve\n// the speed of parsing across a large number of files.</p>\n//\n// <p>\n// There is no strict ordering between the amount of input used by SLL vs LL,\n// which makes it really hard to build a cache for full context. Let's say that\n// we have input A B C that leads to an SLL conflict with full context X. That\n// implies that using X we might only use A B but we could also use A B C D to\n// resolve conflict. Input A B C D could predict alternative 1 in one position\n// in the input and A B C E could predict alternative 2 in another position in\n// input. The conflicting SLL configurations could still be non-unique in the\n// full context prediction, which would lead us to requiring more input than the\n// original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n// input\tused during the previous prediction. That amounts to a cache that maps\n// X to a specific DFA for that context.</p>\n//\n// <p>\n// Something should be done for left-recursive expression predictions. They are\n// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n// with full LL thing Sam does.</p>\n//\n// <p>\n// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n//\n// <p>\n// We avoid doing full context retry when the outer context is empty, we did not\n// dip into the outer context by falling off the end of the decision state rule,\n// or when we force SLL mode.</p>\n//\n// <p>\n// As an example of the not dip into outer context case, consider as super\n// constructor calls versus function calls. One grammar might look like\n// this:</p>\n//\n// <pre>\n// ctorBody\n//   : '{' superCall? stat* '}'\n//   ;\n// </pre>\n//\n// <p>\n// Or, you might see something like</p>\n//\n// <pre>\n// stat\n//   : superCall ';'\n//   | expression ';'\n//   | ...\n//   ;\n// </pre>\n//\n// <p>\n// In both cases I believe that no closure operations will dip into the outer\n// context. In the first case ctorBody in the worst case will stop at the '}'.\n// In the 2nd case it should stop at the ';'. Both cases should stay within the\n// entry rule and not dip into the outer context.</p>\n//\n// <p>\n// <strong>PREDICATES</strong></p>\n//\n// <p>\n// Predicates are always evaluated if present in either SLL or LL both. SLL and\n// LL simulation deals with predicates differently. SLL collects predicates as\n// it performs closure operations like ANTLR v3 did. It delays predicate\n// evaluation until it reaches and accept state. This allows us to cache the SLL\n// ATN simulation whereas, if we had evaluated predicates on-the-fly during\n// closure, the DFA state configuration sets would be different and we couldn't\n// build up a suitable DFA.</p>\n//\n// <p>\n// When building a DFA accept state during ATN simulation, we evaluate any\n// predicates and return the sole semantically valid alternative. If there is\n// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n// we throw an exception. Alternatives without predicates act like they have\n// true predicates. The simple way to think about it is to strip away all\n// alternatives with false predicates and choose the minimum alternative that\n// remains.</p>\n//\n// <p>\n// When we start in the DFA and reach an accept state that's predicated, we test\n// those and return the minimum semantically viable alternative. If no\n// alternatives are viable, we throw an exception.</p>\n//\n// <p>\n// During full LL ATN simulation, closure always evaluates predicates and\n// on-the-fly. This is crucial to reducing the configuration set size during\n// closure. It hits a landmine when parsing with the Java grammar, for example,\n// without this on-the-fly evaluation.</p>\n//\n// <p>\n// <strong>SHARING DFA</strong></p>\n//\n// <p>\n// All instances of the same parser share the same decision DFAs through a\n// static field. Each instance gets its own ATN simulator but they share the\n// same {@link //decisionToDFA} field. They also share a\n// {@link PredictionContextCache} object that makes sure that all\n// {@link PredictionContext} objects are shared among the DFA states. This makes\n// a big size difference.</p>\n//\n// <p>\n// <strong>THREAD SAFETY</strong></p>\n//\n// <p>\n// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n// it adds a new DFA object to that array. {@link //addDFAEdge}\n// locks on the DFA for the current decision when setting the\n// {@link DFAState//edges} field. {@link //addDFAState} locks on\n// the DFA for the current decision when looking up a DFA state to see if it\n// already exists. We must make sure that all requests to add DFA states that\n// are equivalent result in the same shared DFA object. This is because lots of\n// threads will be trying to update the DFA at once. The\n// {@link //addDFAState} method also locks inside the DFA lock\n// but this time on the shared context cache when it rebuilds the\n// configurations' {@link PredictionContext} objects using cached\n// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n// safe as long as we can guarantee that all threads referencing\n// {@code s.edge[t]} get the same physical target {@link DFAState}, or\n// {@code null}. Once into the DFA, the DFA simulation does not reference the\n// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n// targets. The DFA simulator will either find {@link DFAState//edges} to be\n// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n// {@code dfa.edges[t]} to be non-null. The\n// {@link //addDFAEdge} method could be racing to set the field\n// but in either case the DFA simulator works; if {@code null}, and requests ATN\n// simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n// way it will work because it's not doing a test and set operation.</p>\n//\n// <p>\n// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n// Parsing)</strong></p>\n//\n// <p>\n// Sam pointed out that if SLL does not give a syntax error, then there is no\n// point in doing full LL, which is slower. We only have to try LL if we get a\n// syntax error. For maximum speed, Sam starts the parser set to pure SLL\n// mode with the {@link BailErrorStrategy}:</p>\n//\n// <pre>\n// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n// </pre>\n//\n// <p>\n// If it does not get a syntax error, then we're done. If it does get a syntax\n// error, we need to retry with the combined SLL/LL strategy.</p>\n//\n// <p>\n// The reason this works is as follows. If there are no SLL conflicts, then the\n// grammar is SLL (at least for that input set). If there is an SLL conflict,\n// the full LL analysis must yield a set of viable alternatives which is a\n// subset of the alternatives reported by SLL. If the LL set is a singleton,\n// then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n// set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n// is truly ambiguous on the current input. If the LL set is smaller, then the\n// SLL conflict resolution might choose an alternative that the full LL would\n// rule out as a possibility based upon better context information. If that's\n// the case, then the SLL parse will definitely get an error because the full LL\n// analysis says it's not viable. If SLL conflict resolution chooses an\n// alternative within the LL set, them both SLL and LL would choose the same\n// alternative because they both choose the minimum of multiple conflicting\n// alternatives.</p>\n//\n// <p>\n// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n// parsing will get an error because SLL will pursue alternative 1. If\n// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n// choose the same alternative because alternative one is the minimum of either\n// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n//\n// <p>\n// Of course, if the input is invalid, then we will get an error for sure in\n// both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n// the input.</p>\n//\n\nvar Utils = require('./../Utils');\nvar Set = Utils.Set;\nvar BitSet = Utils.BitSet;\nvar DoubleDict = Utils.DoubleDict;\nvar ATN = require('./ATN').ATN;\nvar ATNState = require('./ATNState').ATNState;\nvar ATNConfig = require('./ATNConfig').ATNConfig;\nvar ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;\nvar Token = require('./../Token').Token;\nvar DFAState = require('./../dfa/DFAState').DFAState;\nvar PredPrediction = require('./../dfa/DFAState').PredPrediction;\nvar ATNSimulator = require('./ATNSimulator').ATNSimulator;\nvar PredictionMode = require('./PredictionMode').PredictionMode;\nvar RuleContext = require('./../RuleContext').RuleContext;\nvar ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;\nvar SemanticContext = require('./SemanticContext').SemanticContext;\nvar StarLoopEntryState = require('./ATNState').StarLoopEntryState;\nvar RuleStopState = require('./ATNState').RuleStopState;\nvar PredictionContext = require('./../PredictionContext').PredictionContext;\nvar Interval = require('./../IntervalSet').Interval;\nvar Transitions = require('./Transition');\nvar Transition = Transitions.Transition;\nvar SetTransition = Transitions.SetTransition;\nvar NotSetTransition = Transitions.NotSetTransition;\nvar RuleTransition = Transitions.RuleTransition;\nvar ActionTransition = Transitions.ActionTransition;\nvar NoViableAltException = require('./../error/Errors').NoViableAltException;\n\nvar SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;\nvar predictionContextFromRuleContext = require('./../PredictionContext').predictionContextFromRuleContext;\n\nfunction ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {\n\tATNSimulator.call(this, atn, sharedContextCache);\n    this.parser = parser;\n    this.decisionToDFA = decisionToDFA;\n    // SLL, LL, or LL + exact ambig detection?//\n    this.predictionMode = PredictionMode.LL;\n    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n    this._input = null;\n    this._startIndex = 0;\n    this._outerContext = null;\n    this._dfa = null;\n    // Each prediction operation uses a cache for merge of prediction contexts.\n    //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n    //  isn't synchronized but we're ok since two threads shouldn't reuse same\n    //  parser/atnsim object because it can only handle one input at a time.\n    //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n    //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n    //  also be examined during cache lookup.\n    //\n    this.mergeCache = null;\n    return this;\n}\n\nParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);\nParserATNSimulator.prototype.constructor = ParserATNSimulator;\n\nParserATNSimulator.prototype.debug = false;\nParserATNSimulator.prototype.debug_closure = false;\nParserATNSimulator.prototype.debug_add = false;\nParserATNSimulator.prototype.debug_list_atn_decisions = false;\nParserATNSimulator.prototype.dfa_debug = false;\nParserATNSimulator.prototype.retry_debug = false;\n\n\nParserATNSimulator.prototype.reset = function() {\n};\n\nParserATNSimulator.prototype.adaptivePredict = function(input, decision, outerContext) {\n    if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"adaptivePredict decision \" + decision +\n                               \" exec LA(1)==\" + this.getLookaheadName(input) +\n                               \" line \" + input.LT(1).line + \":\" +\n                               input.LT(1).column);\n    }\n    this._input = input;\n    this._startIndex = input.index;\n    this._outerContext = outerContext;\n\n    var dfa = this.decisionToDFA[decision];\n    this._dfa = dfa;\n    var m = input.mark();\n    var index = input.index;\n\n    // Now we are certain to have a specific decision's DFA\n    // But, do we still need an initial state?\n    try {\n        var s0;\n        if (dfa.precedenceDfa) {\n            // the start state for a precedence DFA depends on the current\n            // parser precedence, and is provided by a DFA method.\n            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n        } else {\n            // the start state for a \"regular\" DFA is just s0\n            s0 = dfa.s0;\n        }\n        if (s0===null) {\n            if (outerContext===null) {\n                outerContext = RuleContext.EMPTY;\n            }\n            if (this.debug || this.debug_list_atn_decisions) {\n                console.log(\"predictATN decision \" + dfa.decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n            }\n\n            var fullCtx = false;\n            var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n            if( dfa.precedenceDfa) {\n                // If this is a precedence DFA, we use applyPrecedenceFilter\n                // to convert the computed start state to a precedence start\n                // state. We then use DFA.setPrecedenceStartState to set the\n                // appropriate start state for the precedence level rather\n                // than simply setting DFA.s0.\n                //\n                dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                s0_closure = this.applyPrecedenceFilter(s0_closure);\n                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n            } else {\n                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                dfa.s0 = s0;\n            }\n        }\n        var alt = this.execATN(dfa, s0, input, index, outerContext);\n        if (this.debug) {\n            console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames));\n        }\n        return alt;\n    } finally {\n        this._dfa = null;\n        this.mergeCache = null; // wack cache after each prediction\n        input.seek(index);\n        input.release(m);\n    }\n};\n// Performs ATN simulation to compute a predicted alternative based\n//  upon the remaining input, but also updates the DFA cache to avoid\n//  having to traverse the ATN again for the same input sequence.\n\n// There are some key conditions we're looking for after computing a new\n// set of ATN configs (proposed DFA state):\n      // if the set is empty, there is no viable alternative for current symbol\n      // does the state uniquely predict an alternative?\n      // does the state have a conflict that would prevent us from\n      //   putting it on the work list?\n\n// We also have some key operations to do:\n      // add an edge from previous DFA state to potentially new DFA state, D,\n      //   upon current symbol but only if adding to work list, which means in all\n      //   cases except no viable alternative (and possibly non-greedy decisions?)\n      // collecting predicates and adding semantic context to DFA accept states\n      // adding rule context to context-sensitive DFA accept states\n      // consuming an input symbol\n      // reporting a conflict\n      // reporting an ambiguity\n      // reporting a context sensitivity\n      // reporting insufficient predicates\n\n// cover these cases:\n//    dead end\n//    single alt\n//    single alt + preds\n//    conflict\n//    conflict + preds\n//\nParserATNSimulator.prototype.execATN = function(dfa, s0, input, startIndex, outerContext ) {\n    if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"execATN decision \" + dfa.decision +\n                \" exec LA(1)==\" + this.getLookaheadName(input) +\n                \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n    }\n    var alt;\n    var previousD = s0;\n\n    if (this.debug) {\n        console.log(\"s0 = \" + s0);\n    }\n    var t = input.LA(1);\n    while(true) { // while more work\n        var D = this.getExistingTargetState(previousD, t);\n        if(D===null) {\n            D = this.computeTargetState(dfa, previousD, t);\n        }\n        if(D===ATNSimulator.ERROR) {\n            // if any configs in previous dipped into outer context, that\n            // means that input up to t actually finished entry rule\n            // at least for SLL decision. Full LL doesn't dip into outer\n            // so don't need special case.\n            // We will get an error no matter what so delay until after\n            // decision; better error message. Also, no reachable target\n            // ATN states in SLL implies LL will also get nowhere.\n            // If conflict in states that dip out, choose min since we\n            // will get error no matter what.\n            var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n            input.seek(startIndex);\n            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n            if(alt!==ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            } else {\n                throw e;\n            }\n        }\n        if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n            // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n            var conflictingAlts = null;\n            if (D.predicates!==null) {\n                if (this.debug) {\n                    console.log(\"DFA state has preds in DFA sim LL failover\");\n                }\n                var conflictIndex = input.index;\n                if(conflictIndex !== startIndex) {\n                    input.seek(startIndex);\n                }\n                conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (conflictingAlts.length===1) {\n                    if(this.debug) {\n                        console.log(\"Full LL avoided\");\n                    }\n                    return conflictingAlts.minValue();\n                }\n                if (conflictIndex !== startIndex) {\n                    // restore the index so reporting the fallback to full\n                    // context occurs with the index at the correct spot\n                    input.seek(conflictIndex);\n                }\n            }\n            if (this.dfa_debug) {\n                console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n            }\n            var fullCtx = true;\n            var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n            this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n            alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n            return alt;\n        }\n        if (D.isAcceptState) {\n            if (D.predicates===null) {\n                return D.prediction;\n            }\n            var stopIndex = input.index;\n            input.seek(startIndex);\n            var alts = this.evalSemanticContext(D.predicates, outerContext, true);\n            if (alts.length===0) {\n                throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n            } else if (alts.length===1) {\n                return alts.minValue();\n            } else {\n                // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                return alts.minValue();\n            }\n        }\n        previousD = D;\n\n        if (t !== Token.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n};\n//\n// Get an existing target state for an edge in the DFA. If the target state\n// for the edge has not yet been computed or is otherwise not available,\n// this method returns {@code null}.\n//\n// @param previousD The current DFA state\n// @param t The next input symbol\n// @return The existing target DFA state for the given input symbol\n// {@code t}, or {@code null} if the target state for this edge is not\n// already cached\n//\nParserATNSimulator.prototype.getExistingTargetState = function(previousD, t) {\n    var edges = previousD.edges;\n    if (edges===null) {\n        return null;\n    } else {\n        return edges[t + 1] || null;\n    }\n};\n//\n// Compute a target state for an edge in the DFA, and attempt to add the\n// computed state and corresponding edge to the DFA.\n//\n// @param dfa The DFA\n// @param previousD The current DFA state\n// @param t The next input symbol\n//\n// @return The computed target DFA state for the given input symbol\n// {@code t}. If {@code t} does not lead to a valid DFA state, this method\n// returns {@link //ERROR}.\n//\nParserATNSimulator.prototype.computeTargetState = function(dfa, previousD, t) {\n   var reach = this.computeReachSet(previousD.configs, t, false);\n    if(reach===null) {\n        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n        return ATNSimulator.ERROR;\n    }\n    // create new target state; we'll add to DFA after it's complete\n    var D = new DFAState(null, reach);\n\n    var predictedAlt = this.getUniqueAlt(reach);\n\n    if (this.debug) {\n        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                    \", previous=\" + previousD.configs +\n                    \", configs=\" + reach +\n                    \", predict=\" + predictedAlt +\n                    \", allSubsetsConflict=\" +\n                    PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                    this.getConflictingAlts(reach));\n    }\n    if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n        // NO CONFLICT, UNIQUELY PREDICTED ALT\n        D.isAcceptState = true;\n        D.configs.uniqueAlt = predictedAlt;\n        D.prediction = predictedAlt;\n    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n        // MORE THAN ONE VIABLE ALTERNATIVE\n        D.configs.conflictingAlts = this.getConflictingAlts(reach);\n        D.requiresFullContext = true;\n        // in SLL-only mode, we will stop at this state and return the minimum alt\n        D.isAcceptState = true;\n        D.prediction = D.configs.conflictingAlts.minValue();\n    }\n    if (D.isAcceptState && D.configs.hasSemanticContext) {\n        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n        if( D.predicates!==null) {\n            D.prediction = ATN.INVALID_ALT_NUMBER;\n        }\n    }\n    // all adds to dfa are done after we've created full D state\n    D = this.addDFAEdge(dfa, previousD, t, D);\n    return D;\n};\n\nParserATNSimulator.prototype.predicateDFAState = function(dfaState, decisionState) {\n    // We need to test all predicates, even in DFA states that\n    // uniquely predict alternative.\n    var nalts = decisionState.transitions.length;\n    // Update DFA so reach becomes accept state with (predicate,alt)\n    // pairs if preds found for conflicting alts\n    var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n    var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n    if (altToPred!==null) {\n        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n        dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n    } else {\n        // There are preds in configs but they might go away\n        // when OR'd together like {p}? || NONE == NONE. If neither\n        // alt has preds, resolve to min alt\n        dfaState.prediction = altsToCollectPredsFrom.minValue();\n    }\n};\n\n// comes back with reach.uniqueAlt set to a valid alt\nParserATNSimulator.prototype.execATNWithFullContext = function(dfa, D, // how far we got before failing over\n                                     s0,\n                                     input,\n                                     startIndex,\n                                     outerContext) {\n    if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"execATNWithFullContext \"+s0);\n    }\n    var fullCtx = true;\n    var foundExactAmbig = false;\n    var reach = null;\n    var previous = s0;\n    input.seek(startIndex);\n    var t = input.LA(1);\n    var predictedAlt = -1;\n    while (true) { // while more work\n        reach = this.computeReachSet(previous, t, fullCtx);\n        if (reach===null) {\n            // if any configs in previous dipped into outer context, that\n            // means that input up to t actually finished entry rule\n            // at least for LL decision. Full LL doesn't dip into outer\n            // so don't need special case.\n            // We will get an error no matter what so delay until after\n            // decision; better error message. Also, no reachable target\n            // ATN states in SLL implies LL will also get nowhere.\n            // If conflict in states that dip out, choose min since we\n            // will get error no matter what.\n            var e = this.noViableAlt(input, outerContext, previous, startIndex);\n            input.seek(startIndex);\n            var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n            if(alt!==ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            } else {\n                throw e;\n            }\n        }\n        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if(this.debug) {\n            console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                  PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                  PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        reach.uniqueAlt = this.getUniqueAlt(reach);\n        // unique prediction?\n        if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            // In exact ambiguity mode, we never try to terminate early.\n            // Just keeps scarfing until we know what the conflict is\n            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n            // else there are multiple non-conflicting subsets or\n            // we're not sure what the ambiguity is yet.\n            // So, keep going.\n        }\n        previous = reach;\n        if( t !== Token.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n    // If the configuration set uniquely predicts an alternative,\n    // without conflict, then we know that it's a full LL decision\n    // not SLL.\n    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n        return predictedAlt;\n    }\n    // We do not check predicates here because we have checked them\n    // on-the-fly when doing full context prediction.\n\n    //\n    // In non-exact ambiguity detection mode, we might\tactually be able to\n    // detect an exact ambiguity, but I'm not going to spend the cycles\n    // needed to check. We only emit ambiguity warnings in exact ambiguity\n    // mode.\n    //\n    // For example, we might know that we have conflicting configurations.\n    // But, that does not mean that there is no way forward without a\n    // conflict. It's possible to have nonconflicting alt subsets as in:\n\n    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n    // from\n    //\n    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n    //\n    // In this case, (17,1,[5 $]) indicates there is some next sequence that\n    // would resolve this without conflict to alternative 1. Any other viable\n    // next sequence, however, is associated with a conflict.  We stop\n    // looking for input because no amount of further lookahead will alter\n    // the fact that we should predict alternative 1.  We just can't say for\n    // sure that there is an ambiguity without looking further.\n\n    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n    return predictedAlt;\n};\n\nParserATNSimulator.prototype.computeReachSet = function(closure, t, fullCtx) {\n    if (this.debug) {\n        console.log(\"in computeReachSet, starting closure: \" + closure);\n    }\n    if( this.mergeCache===null) {\n        this.mergeCache = new DoubleDict();\n    }\n    var intermediate = new ATNConfigSet(fullCtx);\n\n    // Configurations already in a rule stop state indicate reaching the end\n    // of the decision rule (local context) or end of the start rule (full\n    // context). Once reached, these configurations are never updated by a\n    // closure operation, so they are handled separately for the performance\n    // advantage of having a smaller intermediate set when calling closure.\n    //\n    // For full-context reach operations, separate handling is required to\n    // ensure that the alternative matching the longest overall sequence is\n    // chosen when multiple such configurations can match the input.\n\n    var skippedStopStates = null;\n\n    // First figure out where we can reach on input t\n    for (var i=0; i<closure.items.length;i++) {\n        var c = closure.items[i];\n        if(this.debug_add) {\n            console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n        }\n        if (c.state instanceof RuleStopState) {\n            if (fullCtx || t === Token.EOF) {\n                if (skippedStopStates===null) {\n                    skippedStopStates = [];\n                }\n                skippedStopStates.push(c);\n                if(this.debug_add) {\n                    console.log(\"added \" + c + \" to skippedStopStates\");\n                }\n            }\n            continue;\n        }\n        for(var j=0;j<c.state.transitions.length;j++) {\n            var trans = c.state.transitions[j];\n            var target = this.getReachableTarget(trans, t);\n            if (target!==null) {\n                var cfg = new ATNConfig({state:target}, c);\n                intermediate.add(cfg, this.mergeCache);\n                if(this.debug_add) {\n                    console.log(\"added \" + cfg + \" to intermediate\");\n                }\n            }\n        }\n    }\n    // Now figure out where the reach operation can take us...\n    var reach = null;\n\n    // This block optimizes the reach operation for intermediate sets which\n    // trivially indicate a termination state for the overall\n    // adaptivePredict operation.\n    //\n    // The conditions assume that intermediate\n    // contains all configurations relevant to the reach set, but this\n    // condition is not true when one or more configurations have been\n    // withheld in skippedStopStates, or when the current symbol is EOF.\n    //\n    if (skippedStopStates===null && t!==Token.EOF) {\n        if (intermediate.items.length===1) {\n            // Don't pursue the closure if there is just one state.\n            // It can only have one alternative; just add to result\n            // Also don't pursue the closure if there is unique alternative\n            // among the configurations.\n            reach = intermediate;\n        } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n            // Also don't pursue the closure if there is unique alternative\n            // among the configurations.\n            reach = intermediate;\n        }\n    }\n    // If the reach set could not be trivially determined, perform a closure\n    // operation on the intermediate set to compute its initial value.\n    //\n    if (reach===null) {\n        reach = new ATNConfigSet(fullCtx);\n        var closureBusy = new Set();\n        var treatEofAsEpsilon = t === Token.EOF;\n        for (var k=0; k<intermediate.items.length;k++) {\n            this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n        }\n    }\n    if (t === Token.EOF) {\n        // After consuming EOF no additional input is possible, so we are\n        // only interested in configurations which reached the end of the\n        // decision rule (local context) or end of the start rule (full\n        // context). Update reach to contain only these configurations. This\n        // handles both explicit EOF transitions in the grammar and implicit\n        // EOF transitions following the end of the decision or start rule.\n        //\n        // When reach==intermediate, no closure operation was performed. In\n        // this case, removeAllConfigsNotInRuleStopState needs to check for\n        // reachable rule stop states as well as configurations already in\n        // a rule stop state.\n        //\n        // This is handled before the configurations in skippedStopStates,\n        // because any configurations potentially added from that list are\n        // already guaranteed to meet this condition whether or not it's\n        // required.\n        //\n        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n    }\n    // If skippedStopStates!==null, then it contains at least one\n    // configuration. For full-context reach operations, these\n    // configurations reached the end of the start rule, in which case we\n    // only add them back to reach if no configuration during the current\n    // closure operation reached such a state. This ensures adaptivePredict\n    // chooses an alternative matching the longest overall sequence when\n    // multiple alternatives are viable.\n    //\n    if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n        for (var l=0; l<skippedStopStates.length;l++) {\n            reach.add(skippedStopStates[l], this.mergeCache);\n        }\n    }\n    if (reach.items.length===0) {\n        return null;\n    } else {\n        return reach;\n    }\n};\n//\n// Return a configuration set containing only the configurations from\n// {@code configs} which are in a {@link RuleStopState}. If all\n// configurations in {@code configs} are already in a rule stop state, this\n// method simply returns {@code configs}.\n//\n// <p>When {@code lookToEndOfRule} is true, this method uses\n// {@link ATN//nextTokens} for each configuration in {@code configs} which is\n// not already in a rule stop state to see if a rule stop state is reachable\n// from the configuration via epsilon-only transitions.</p>\n//\n// @param configs the configuration set to update\n// @param lookToEndOfRule when true, this method checks for rule stop states\n// reachable by epsilon-only transitions from each configuration in\n// {@code configs}.\n//\n// @return {@code configs} if all configurations in {@code configs} are in a\n// rule stop state, otherwise return a new configuration set containing only\n// the configurations from {@code configs} which are in a rule stop state\n//\nParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function(configs, lookToEndOfRule) {\n    if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n        return configs;\n    }\n    var result = new ATNConfigSet(configs.fullCtx);\n    for(var i=0; i<configs.items.length;i++) {\n        var config = configs.items[i];\n        if (config.state instanceof RuleStopState) {\n            result.add(config, this.mergeCache);\n            continue;\n        }\n        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n            var nextTokens = this.atn.nextTokens(config.state);\n            if (nextTokens.contains(Token.EPSILON)) {\n                var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n            }\n        }\n    }\n    return result;\n};\n\nParserATNSimulator.prototype.computeStartState = function(p, ctx, fullCtx) {\n    // always at least the implicit call to start rule\n    var initialContext = predictionContextFromRuleContext(this.atn, ctx);\n    var configs = new ATNConfigSet(fullCtx);\n    for(var i=0;i<p.transitions.length;i++) {\n        var target = p.transitions[i].target;\n        var c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n        var closureBusy = new Set();\n        this.closure(c, configs, closureBusy, true, fullCtx, false);\n    }\n    return configs;\n};\n\n//\n// This method transforms the start state computed by\n// {@link //computeStartState} to the special start state used by a\n// precedence DFA for a particular precedence value. The transformation\n// process applies the following changes to the start state's configuration\n// set.\n//\n// <ol>\n// <li>Evaluate the precedence predicates for each configuration using\n// {@link SemanticContext//evalPrecedence}.</li>\n// <li>Remove all configurations which predict an alternative greater than\n// 1, for which another configuration that predicts alternative 1 is in the\n// same ATN state with the same prediction context. This transformation is\n// valid for the following reasons:\n// <ul>\n// <li>The closure block cannot contain any epsilon transitions which bypass\n// the body of the closure, so all states reachable via alternative 1 are\n// part of the precedence alternatives of the transformed left-recursive\n// rule.</li>\n// <li>The \"primary\" portion of a left recursive rule cannot contain an\n// epsilon transition, so the only way an alternative other than 1 can exist\n// in a state that is also reachable via alternative 1 is by nesting calls\n// to the left-recursive rule, with the outer calls not being at the\n// preferred precedence level.</li>\n// </ul>\n// </li>\n// </ol>\n//\n// <p>\n// The prediction context must be considered by this filter to address\n// situations like the following.\n// </p>\n// <code>\n// <pre>\n// grammar TA;\n// prog: statement* EOF;\n// statement: letterA | statement letterA 'b' ;\n// letterA: 'a';\n// </pre>\n// </code>\n// <p>\n// If the above grammar, the ATN state immediately before the token\n// reference {@code 'a'} in {@code letterA} is reachable from the left edge\n// of both the primary and closure blocks of the left-recursive rule\n// {@code statement}. The prediction context associated with each of these\n// configurations distinguishes between them, and prevents the alternative\n// which stepped out to {@code prog} (and then back in to {@code statement}\n// from being eliminated by the filter.\n// </p>\n//\n// @param configs The configuration set computed by\n// {@link //computeStartState} as the start state for the DFA.\n// @return The transformed configuration set representing the start state\n// for a precedence DFA at a particular precedence level (determined by\n// calling {@link Parser//getPrecedence}).\n//\nParserATNSimulator.prototype.applyPrecedenceFilter = function(configs) {\n\tvar config;\n\tvar statesFromAlt1 = [];\n    var configSet = new ATNConfigSet(configs.fullCtx);\n    for(var i=0; i<configs.items.length; i++) {\n        config = configs.items[i];\n        // handle alt 1 first\n        if (config.alt !== 1) {\n            continue;\n        }\n        var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n        if (updatedContext===null) {\n            // the configuration was eliminated\n            continue;\n        }\n        statesFromAlt1[config.state.stateNumber] = config.context;\n        if (updatedContext !== config.semanticContext) {\n            configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n        } else {\n            configSet.add(config, this.mergeCache);\n        }\n    }\n    for(i=0; i<configs.items.length; i++) {\n        config = configs.items[i];\n        if (config.alt === 1) {\n            // already handled\n            continue;\n        }\n        // In the future, this elimination step could be updated to also\n        // filter the prediction context for alternatives predicting alt>1\n        // (basically a graph subtraction algorithm).\n\t\tif (!config.precedenceFilterSuppressed) {\n            var context = statesFromAlt1[config.state.stateNumber] || null;\n            if (context!==null && context.equals(config.context)) {\n                // eliminated\n                continue;\n            }\n\t\t}\n        configSet.add(config, this.mergeCache);\n    }\n    return configSet;\n};\n\nParserATNSimulator.prototype.getReachableTarget = function(trans, ttype) {\n    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n        return trans.target;\n    } else {\n        return null;\n    }\n};\n\nParserATNSimulator.prototype.getPredsForAmbigAlts = function(ambigAlts, configs, nalts) {\n    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n    // altToPred starts as an array of all null contexts. The entry at index i\n    // corresponds to alternative i. altToPred[i] may have one of three values:\n    //   1. null: no ATNConfig c is found such that c.alt==i\n    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n    //      alt i has at least one unpredicated config.\n    //   3. Non-NONE Semantic Context: There exists at least one, and for all\n    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n    //\n    // From this, it is clear that NONE||anything==NONE.\n    //\n    var altToPred = [];\n    for(var i=0;i<configs.items.length;i++) {\n        var c = configs.items[i];\n        if(ambigAlts.contains( c.alt )) {\n            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n        }\n    }\n    var nPredAlts = 0;\n    for (i =1;i< nalts+1;i++) {\n        var pred = altToPred[i] || null;\n        if (pred===null) {\n            altToPred[i] = SemanticContext.NONE;\n        } else if (pred !== SemanticContext.NONE) {\n            nPredAlts += 1;\n        }\n    }\n    // nonambig alts are null in altToPred\n    if (nPredAlts===0) {\n        altToPred = null;\n    }\n    if (this.debug) {\n        console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n    }\n    return altToPred;\n};\n\nParserATNSimulator.prototype.getPredicatePredictions = function(ambigAlts, altToPred) {\n    var pairs = [];\n    var containsPredicate = false;\n    for (var i=1; i<altToPred.length;i++) {\n        var pred = altToPred[i];\n        // unpredicated is indicated by SemanticContext.NONE\n        if( ambigAlts!==null && ambigAlts.contains( i )) {\n            pairs.push(new PredPrediction(pred, i));\n        }\n        if (pred !== SemanticContext.NONE) {\n            containsPredicate = true;\n        }\n    }\n    if (! containsPredicate) {\n        return null;\n    }\n    return pairs;\n};\n\n//\n// This method is used to improve the localization of error messages by\n// choosing an alternative rather than throwing a\n// {@link NoViableAltException} in particular prediction scenarios where the\n// {@link //ERROR} state was reached during ATN simulation.\n//\n// <p>\n// The default implementation of this method uses the following\n// algorithm to identify an ATN configuration which successfully parsed the\n// decision entry rule. Choosing such an alternative ensures that the\n// {@link ParserRuleContext} returned by the calling rule will be complete\n// and valid, and the syntax error will be reported later at a more\n// localized location.</p>\n//\n// <ul>\n// <li>If a syntactically valid path or paths reach the end of the decision rule and\n// they are semantically valid if predicated, return the min associated alt.</li>\n// <li>Else, if a semantically invalid but syntactically valid path exist\n// or paths exist, return the minimum associated alt.\n// </li>\n// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n// </ul>\n//\n// <p>\n// In some scenarios, the algorithm described above could predict an\n// alternative which will result in a {@link FailedPredicateException} in\n// the parser. Specifically, this could occur if the <em>only</em> configuration\n// capable of successfully parsing to the end of the decision rule is\n// blocked by a semantic predicate. By choosing this alternative within\n// {@link //adaptivePredict} instead of throwing a\n// {@link NoViableAltException}, the resulting\n// {@link FailedPredicateException} in the parser will identify the specific\n// predicate which is preventing the parser from successfully parsing the\n// decision rule, which helps developers identify and correct logic errors\n// in semantic predicates.\n// </p>\n//\n// @param configs The ATN configurations which were valid immediately before\n// the {@link //ERROR} state was reached\n// @param outerContext The is the \\gamma_0 initial parser context from the paper\n// or the parser stack at the instant before prediction commences.\n//\n// @return The value to return from {@link //adaptivePredict}, or\n// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n// identified and {@link //adaptivePredict} should report an error instead.\n//\nParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function(configs, outerContext) {\n    var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n    var semValidConfigs = cfgs[0];\n    var semInvalidConfigs = cfgs[1];\n    var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n    if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n        return alt;\n    }\n    // Is there a syntactically valid path with a failed pred?\n    if (semInvalidConfigs.items.length>0) {\n        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n            return alt;\n        }\n    }\n    return ATN.INVALID_ALT_NUMBER;\n};\n\nParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function(configs) {\n    var alts = [];\n    for(var i=0;i<configs.items.length; i++) {\n        var c = configs.items[i];\n        if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n            if(alts.indexOf(c.alt)<0) {\n                alts.push(c.alt);\n            }\n        }\n    }\n    if (alts.length===0) {\n        return ATN.INVALID_ALT_NUMBER;\n    } else {\n        return Math.min.apply(null, alts);\n    }\n};\n// Walk the list of configurations and split them according to\n//  those that have preds evaluating to true/false.  If no pred, assume\n//  true pred and include in succeeded set.  Returns Pair of sets.\n//\n//  Create a new set so as not to alter the incoming parameter.\n//\n//  Assumption: the input stream has been restored to the starting point\n//  prediction, which is where predicates need to evaluate.\n//\nParserATNSimulator.prototype.splitAccordingToSemanticValidity = function( configs, outerContext) {\n    var succeeded = new ATNConfigSet(configs.fullCtx);\n    var failed = new ATNConfigSet(configs.fullCtx);\n    for(var i=0;i<configs.items.length; i++) {\n        var c = configs.items[i];\n        if (c.semanticContext !== SemanticContext.NONE) {\n            var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n            if (predicateEvaluationResult) {\n                succeeded.add(c);\n            } else {\n                failed.add(c);\n            }\n        } else {\n            succeeded.add(c);\n        }\n    }\n    return [succeeded, failed];\n};\n\n// Look through a list of predicate/alt pairs, returning alts for the\n//  pairs that win. A {@code NONE} predicate indicates an alt containing an\n//  unpredicated config which behaves as \"always true.\" If !complete\n//  then we stop at the first predicate that evaluates to true. This\n//  includes pairs with null predicates.\n//\nParserATNSimulator.prototype.evalSemanticContext = function(predPredictions, outerContext, complete) {\n    var predictions = new BitSet();\n    for(var i=0;i<predPredictions.length;i++) {\n    \tvar pair = predPredictions[i];\n        if (pair.pred === SemanticContext.NONE) {\n            predictions.add(pair.alt);\n            if (! complete) {\n                break;\n            }\n            continue;\n        }\n        var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n        if (this.debug || this.dfa_debug) {\n            console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n        }\n        if (predicateEvaluationResult) {\n            if (this.debug || this.dfa_debug) {\n                console.log(\"PREDICT \" + pair.alt);\n            }\n            predictions.add(pair.alt);\n            if (! complete) {\n                break;\n            }\n        }\n    }\n    return predictions;\n};\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n\nParserATNSimulator.prototype.closure = function(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n    var initialDepth = 0;\n    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                             fullCtx, initialDepth, treatEofAsEpsilon);\n};\n\n\nParserATNSimulator.prototype.closureCheckingStopState = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    if (this.debug || this.debug_closure) {\n        console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n        // console.log(\"configs(\" + configs.toString() + \")\");\n        if(config.reachesIntoOuterContext>50) {\n            throw \"problem\";\n        }\n    }\n    if (config.state instanceof RuleStopState) {\n        // We hit rule end. If we have context info, use it\n        // run thru all possible stack tops in ctx\n        if (! config.context.isEmpty()) {\n            for ( var i =0; i<config.context.length; i++) {\n                if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                    if (fullCtx) {\n                        configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                        continue;\n                    } else {\n                        // we have no context info, just chase follow links (if greedy)\n                        if (this.debug) {\n                            console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                        }\n                        this.closure_(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, depth, treatEofAsEpsilon);\n                    }\n                    continue;\n                }\n                var returnState = this.atn.states[config.context.getReturnState(i)];\n                var newContext = config.context.getParent(i); // \"pop\" return state\n                var parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                var c = new ATNConfig(parms, null);\n                // While we have context to pop back from, we may have\n                // gotten that context AFTER having falling off a rule.\n                // Make sure we track that we are now out of context.\n                c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n            }\n            return;\n        } else if( fullCtx) {\n            // reached end of start rule\n            configs.add(config, this.mergeCache);\n            return;\n        } else {\n            // else if we have no context info, just chase follow links (if greedy)\n            if (this.debug) {\n                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n            }\n        }\n    }\n    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n};\n\n\n// Do the actual work of walking epsilon edges//\nParserATNSimulator.prototype.closure_ = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    var p = config.state;\n    // optimization\n    if (! p.epsilonOnlyTransitions) {\n        configs.add(config, this.mergeCache);\n        // make sure to not return here, because EOF transitions can act as\n        // both epsilon transitions and non-epsilon transitions.\n    }\n    for(var i = 0;i<p.transitions.length; i++) {\n        if(i==0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n            continue;\n\n        var t = p.transitions[i];\n        var continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n        var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n        if (c!==null) {\n            var newDepth = depth;\n            if ( config.state instanceof RuleStopState) {\n                // target fell off end of rule; mark resulting c as having dipped into outer context\n                // We can't get here if incoming config was rule stop and we had context\n                // track how far we dip into outer context.  Might\n                // come in handy and we avoid evaluating context dependent\n                // preds if this is > 0.\n\t\t\t\tif (this._dfa !== null && this._dfa.precedenceDfa) {\n\t\t\t\t\tif (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\tc.precedenceFilterSuppressed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n                c.reachesIntoOuterContext += 1;\n                if (closureBusy.add(c)!==c) {\n                    // avoid infinite recursion for right-recursive rules\n                    continue;\n                }\n                configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                newDepth -= 1;\n                if (this.debug) {\n                    console.log(\"dips into outer ctx: \" + c);\n                }\n            } else {\n                if (!t.isEpsilon && closureBusy.add(c)!==c){\n                    // avoid infinite recursion for EOF* and EOF+\n                    continue;\n                }\n                if (t instanceof RuleTransition) {\n                    // latch when newDepth goes negative - once we step out of the entry context we can't return\n                    if (newDepth >= 0) {\n                        newDepth += 1;\n                    }\n                }\n            }\n            this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n};\n\n\nParserATNSimulator.prototype.canDropLoopEntryEdgeInLeftRecursiveRule = function(config) {\n    // return False\n    var p = config.state;\n    // First check to see if we are in StarLoopEntryState generated during\n    // left-recursion elimination. For efficiency, also check if\n    // the context has an empty stack case. If so, it would mean\n    // global FOLLOW so we can't perform optimization\n    // Are we the special loop entry/exit state? or SLL wildcard\n    if(p.stateType != ATNState.STAR_LOOP_ENTRY)\n        return false;\n    if(p.stateType != ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n           config.context.isEmpty() || config.context.hasEmptyPath())\n        return false;\n\n    // Require all return states to return back to the same rule that p is in.\n    var numCtxs = config.context.length;\n    for(var i=0; i<numCtxs; i++) { // for each stack context\n        var returnState = this.atn.states[config.context.getReturnState(i)];\n        if (returnState.ruleIndex != p.ruleIndex)\n            return false;\n    }\n\n    var decisionStartState = p.transitions[0].target;\n    var blockEndStateNum = decisionStartState.endState.stateNumber;\n    var blockEndState = this.atn.states[blockEndStateNum];\n\n    // Verify that the top of each stack context leads to loop entry/exit\n    // state through epsilon edges and w/o leaving rule.\n    for(var i=0; i<numCtxs; i++) { // for each stack context\n        var returnStateNumber = config.context.getReturnState(i);\n        var returnState = this.atn.states[returnStateNumber];\n        // all states must have single outgoing epsilon edge\n        if (returnState.transitions.length != 1 || !returnState.transitions[0].isEpsilon)\n            return false;\n\n        // Look for prefix op case like 'not expr', (' type ')' expr\n        var returnStateTarget = returnState.transitions[0].target;\n        if ( returnState.stateType == ATNState.BLOCK_END && returnStateTarget == p )\n            continue;\n\n        // Look for 'expr op expr' or case where expr's return state is block end\n        // of (...)* internal block; the block end points to loop back\n        // which points to p but we don't need to check that\n        if ( returnState == blockEndState )\n            continue;\n\n        // Look for ternary expr ? expr : expr. The return state points at block end,\n        // which points at loop entry state\n        if ( returnStateTarget == blockEndState )\n            continue;\n\n        // Look for complex prefix 'between expr and expr' case where 2nd expr's\n        // return state points at block end state of (...)* internal block\n        if (returnStateTarget.stateType == ATNState.BLOCK_END && returnStateTarget.transitions.length == 1\n                && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target == p)\n            continue;\n\n        // anything else ain't conforming\n        return false;\n    }\n    return true;\n};\n\n\nParserATNSimulator.prototype.getRuleName = function( index) {\n    if (this.parser!==null && index>=0) {\n        return this.parser.ruleNames[index];\n    } else {\n        return \"<rule \" + index + \">\";\n    }\n};\n\nParserATNSimulator.prototype.getEpsilonTarget = function(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n    switch(t.serializationType) {\n    case Transition.RULE:\n        return this.ruleTransition(config, t);\n    case Transition.PRECEDENCE:\n        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n    case Transition.PREDICATE:\n        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n    case Transition.ACTION:\n        return this.actionTransition(config, t);\n    case Transition.EPSILON:\n        return new ATNConfig({state:t.target}, config);\n    case Transition.ATOM:\n    case Transition.RANGE:\n    case Transition.SET:\n        // EOF transitions act like epsilon transitions after the first EOF\n        // transition is traversed\n        if (treatEofAsEpsilon) {\n            if (t.matches(Token.EOF, 0, 1)) {\n                return new ATNConfig({state: t.target}, config);\n            }\n        }\n        return null;\n    default:\n    \treturn null;\n    }\n};\n\nParserATNSimulator.prototype.actionTransition = function(config, t) {\n    if (this.debug) {\n        var index = t.actionIndex==-1 ? 65535 : t.actionIndex;\n        console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n    }\n    return new ATNConfig({state:t.target}, config);\n};\n\nParserATNSimulator.prototype.precedenceTransition = function(config, pt,  collectPredicates, inContext, fullCtx) {\n    if (this.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                pt.precedence + \">=_p, ctx dependent=true\");\n        if (this.parser!==null) {\n        \tconsole.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n        }\n    }\n    var c = null;\n    if (collectPredicates && inContext) {\n        if (fullCtx) {\n            // In full context mode, we can evaluate predicates on-the-fly\n            // during closure, which dramatically reduces the size of\n            // the config sets. It also obviates the need to test predicates\n            // later during conflict resolution.\n            var currentPosition = this._input.index;\n            this._input.seek(this._startIndex);\n            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n            this._input.seek(currentPosition);\n            if (predSucceeds) {\n                c = new ATNConfig({state:pt.target}, config); // no pred context\n            }\n        } else {\n            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n        }\n    } else {\n        c = new ATNConfig({state:pt.target}, config);\n    }\n    if (this.debug) {\n        console.log(\"config from pred transition=\" + c);\n    }\n    return c;\n};\n\nParserATNSimulator.prototype.predTransition = function(config, pt, collectPredicates, inContext, fullCtx) {\n    if (this.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n        if (this.parser!==null) {\n            console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n        }\n    }\n    var c = null;\n    if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n        if (fullCtx) {\n            // In full context mode, we can evaluate predicates on-the-fly\n            // during closure, which dramatically reduces the size of\n            // the config sets. It also obviates the need to test predicates\n            // later during conflict resolution.\n            var currentPosition = this._input.index;\n            this._input.seek(this._startIndex);\n            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n            this._input.seek(currentPosition);\n            if (predSucceeds) {\n                c = new ATNConfig({state:pt.target}, config); // no pred context\n            }\n        } else {\n            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n        }\n    } else {\n        c = new ATNConfig({state:pt.target}, config);\n    }\n    if (this.debug) {\n        console.log(\"config from pred transition=\" + c);\n    }\n    return c;\n};\n\nParserATNSimulator.prototype.ruleTransition = function(config, t) {\n    if (this.debug) {\n        console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n    }\n    var returnState = t.followState;\n    var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n    return new ATNConfig({state:t.target, context:newContext}, config );\n};\n\nParserATNSimulator.prototype.getConflictingAlts = function(configs) {\n    var altsets = PredictionMode.getConflictingAltSubsets(configs);\n    return PredictionMode.getAlts(altsets);\n};\n\n // Sam pointed out a problem with the previous definition, v3, of\n // ambiguous states. If we have another state associated with conflicting\n // alternatives, we should keep going. For example, the following grammar\n //\n // s : (ID | ID ID?) ';' ;\n //\n // When the ATN simulation reaches the state before ';', it has a DFA\n // state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n // 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n // because alternative to has another way to continue, via [6|2|[]].\n // The key is that we have a single state that has config's only associated\n // with a single alternative, 2, and crucially the state transitions\n // among the configurations are all non-epsilon transitions. That means\n // we don't consider any conflicts that include alternative 2. So, we\n // ignore the conflict between alts 1 and 2. We ignore a set of\n // conflicting alts when there is an intersection with an alternative\n // associated with a single alt state in the state&rarr;config-list map.\n //\n // It's also the case that we might have two conflicting configurations but\n // also a 3rd nonconflicting configuration for a different alternative:\n // [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n //\n // a : A | A | A B ;\n //\n // After matching input A, we reach the stop state for rule A, state 1.\n // State 8 is the state right before B. Clearly alternatives 1 and 2\n // conflict and no amount of further lookahead will separate the two.\n // However, alternative 3 will be able to continue and so we do not\n // stop working on this state. In the previous example, we're concerned\n // with states associated with the conflicting alternatives. Here alt\n // 3 is not associated with the conflicting configs, but since we can continue\n // looking for input reasonably, I don't declare the state done. We\n // ignore a set of conflicting alts when we have an alternative\n // that we still need to pursue.\n//\n\nParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function(configs) {\n    var conflictingAlts = null;\n    if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n        conflictingAlts = new BitSet();\n        conflictingAlts.add(configs.uniqueAlt);\n    } else {\n        conflictingAlts = configs.conflictingAlts;\n    }\n    return conflictingAlts;\n};\n\nParserATNSimulator.prototype.getTokenName = function( t) {\n    if (t===Token.EOF) {\n        return \"EOF\";\n    }\n    if( this.parser!==null && this.parser.literalNames!==null) {\n        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n            console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n            console.log(\"\" + this.parser.getInputStream().getTokens());\n        } else {\n            var name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n            return name + \"<\" + t + \">\";\n        }\n    }\n    return \"\" + t;\n};\n\nParserATNSimulator.prototype.getLookaheadName = function(input) {\n    return this.getTokenName(input.LA(1));\n};\n\n// Used for debugging in adaptivePredict around execATN but I cut\n//  it out for clarity now that alg. works well. We can leave this\n//  \"dead\" code for a bit.\n//\nParserATNSimulator.prototype.dumpDeadEndConfigs = function(nvae) {\n    console.log(\"dead end configs: \");\n    var decs = nvae.getDeadEndConfigs();\n    for(var i=0; i<decs.length; i++) {\n    \tvar c = decs[i];\n        var trans = \"no edges\";\n        if (c.state.transitions.length>0) {\n            var t = c.state.transitions[0];\n            if (t instanceof AtomTransition) {\n                trans = \"Atom \"+ this.getTokenName(t.label);\n            } else if (t instanceof SetTransition) {\n                var neg = (t instanceof NotSetTransition);\n                trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n            }\n        }\n        console.error(c.toString(this.parser, true) + \":\" + trans);\n    }\n};\n\nParserATNSimulator.prototype.noViableAlt = function(input, outerContext, configs, startIndex) {\n    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n};\n\nParserATNSimulator.prototype.getUniqueAlt = function(configs) {\n    var alt = ATN.INVALID_ALT_NUMBER;\n    for(var i=0;i<configs.items.length;i++) {\n    \tvar c = configs.items[i];\n        if (alt === ATN.INVALID_ALT_NUMBER) {\n            alt = c.alt // found first alt\n        } else if( c.alt!==alt) {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    }\n    return alt;\n};\n\n//\n// Add an edge to the DFA, if possible. This method calls\n// {@link //addDFAState} to ensure the {@code to} state is present in the\n// DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n// range of edges that can be represented in the DFA tables, this method\n// returns without adding the edge to the DFA.\n//\n// <p>If {@code to} is {@code null}, this method returns {@code null}.\n// Otherwise, this method returns the {@link DFAState} returned by calling\n// {@link //addDFAState} for the {@code to} state.</p>\n//\n// @param dfa The DFA\n// @param from The source state for the edge\n// @param t The input symbol\n// @param to The target state for the edge\n//\n// @return If {@code to} is {@code null}, this method returns {@code null};\n// otherwise this method returns the result of calling {@link //addDFAState}\n// on {@code to}\n//\nParserATNSimulator.prototype.addDFAEdge = function(dfa, from_, t, to) {\n    if( this.debug) {\n        console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n    }\n    if (to===null) {\n        return null;\n    }\n    to = this.addDFAState(dfa, to); // used existing if possible not incoming\n    if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n        return to;\n    }\n    if (from_.edges===null) {\n        from_.edges = [];\n    }\n    from_.edges[t+1] = to; // connect\n\n    if (this.debug) {\n        var literalNames = this.parser===null ? null : this.parser.literalNames;\n        var symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n        console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n    }\n    return to;\n};\n//\n// Add state {@code D} to the DFA if it is not already present, and return\n// the actual instance stored in the DFA. If a state equivalent to {@code D}\n// is already in the DFA, the existing state is returned. Otherwise this\n// method returns {@code D} after adding it to the DFA.\n//\n// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n// does not change the DFA.</p>\n//\n// @param dfa The dfa\n// @param D The DFA state to add\n// @return The state stored in the DFA. This will be either the existing\n// state if {@code D} is already in the DFA, or {@code D} itself if the\n// state was not already present.\n//\nParserATNSimulator.prototype.addDFAState = function(dfa, D) {\n    if (D == ATNSimulator.ERROR) {\n        return D;\n    }\n    var existing = dfa.states.get(D);\n    if(existing!==null) {\n        return existing;\n    }\n    D.stateNumber = dfa.states.length;\n    if (! D.configs.readOnly) {\n        D.configs.optimizeConfigs(this);\n        D.configs.setReadonly(true);\n    }\n    dfa.states.add(D);\n    if (this.debug) {\n        console.log(\"adding new DFA state: \" + D);\n    }\n    return D;\n};\n\nParserATNSimulator.prototype.reportAttemptingFullContext = function(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n    if (this.debug || this.retry_debug) {\n        var interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                           \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n    if (this.parser!==null) {\n        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n    }\n};\n\nParserATNSimulator.prototype.reportContextSensitivity = function(dfa, prediction, configs, startIndex, stopIndex) {\n    if (this.debug || this.retry_debug) {\n        var interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                           \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n    if (this.parser!==null) {\n        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n    }\n};\n\n// If context sensitive parsing, we know it's ambiguity not conflict//\nParserATNSimulator.prototype.reportAmbiguity = function(dfa, D, startIndex, stopIndex,\n                               exact, ambigAlts, configs ) {\n    if (this.debug || this.retry_debug) {\n        var interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                           \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n    if (this.parser!==null) {\n        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n};\n\nexports.ParserATNSimulator = ParserATNSimulator;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n//\n// This enumeration defines the prediction modes available in ANTLR 4 along with\n// utility methods for analyzing configuration sets for conflicts and/or\n// ambiguities.\n\nvar Set = require('./../Utils').Set;\nvar Map = require('./../Utils').Map;\nvar BitSet = require('./../Utils').BitSet;\nvar AltDict = require('./../Utils').AltDict;\nvar ATN = require('./ATN').ATN;\nvar RuleStopState = require('./ATNState').RuleStopState;\nvar ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;\nvar ATNConfig = require('./ATNConfig').ATNConfig;\nvar SemanticContext = require('./SemanticContext').SemanticContext;\nvar Hash = require(\"../Utils\").Hash;\nvar hashStuff = require('./../Utils').hashStuff;\nvar equalArrays = require('./../Utils').equalArrays;\n\nfunction PredictionMode() {\n\treturn this;\n}\n\n//\n// The SLL(*) prediction mode. This prediction mode ignores the current\n// parser context when making predictions. This is the fastest prediction\n// mode, and provides correct results for many grammars. This prediction\n// mode is more powerful than the prediction mode provided by ANTLR 3, but\n// may result in syntax errors for grammar and input combinations which are\n// not SLL.\n//\n// <p>\n// When using this prediction mode, the parser will either return a correct\n// parse tree (i.e. the same parse tree that would be returned with the\n// {@link //LL} prediction mode), or it will report a syntax error. If a\n// syntax error is encountered when using the {@link //SLL} prediction mode,\n// it may be due to either an actual syntax error in the input or indicate\n// that the particular combination of grammar and input requires the more\n// powerful {@link //LL} prediction abilities to complete successfully.</p>\n//\n// <p>\n// This prediction mode does not provide any guarantees for prediction\n// behavior for syntactically-incorrect inputs.</p>\n//\nPredictionMode.SLL = 0;\n//\n// The LL(*) prediction mode. This prediction mode allows the current parser\n// context to be used for resolving SLL conflicts that occur during\n// prediction. This is the fastest prediction mode that guarantees correct\n// parse results for all combinations of grammars with syntactically correct\n// inputs.\n//\n// <p>\n// When using this prediction mode, the parser will make correct decisions\n// for all syntactically-correct grammar and input combinations. However, in\n// cases where the grammar is truly ambiguous this prediction mode might not\n// report a precise answer for <em>exactly which</em> alternatives are\n// ambiguous.</p>\n//\n// <p>\n// This prediction mode does not provide any guarantees for prediction\n// behavior for syntactically-incorrect inputs.</p>\n//\nPredictionMode.LL = 1;\n//\n// The LL(*) prediction mode with exact ambiguity detection. In addition to\n// the correctness guarantees provided by the {@link //LL} prediction mode,\n// this prediction mode instructs the prediction algorithm to determine the\n// complete and exact set of ambiguous alternatives for every ambiguous\n// decision encountered while parsing.\n//\n// <p>\n// This prediction mode may be used for diagnosing ambiguities during\n// grammar development. Due to the performance overhead of calculating sets\n// of ambiguous alternatives, this prediction mode should be avoided when\n// the exact results are not necessary.</p>\n//\n// <p>\n// This prediction mode does not provide any guarantees for prediction\n// behavior for syntactically-incorrect inputs.</p>\n//\nPredictionMode.LL_EXACT_AMBIG_DETECTION = 2;\n\n\n//\n// Computes the SLL prediction termination condition.\n//\n// <p>\n// This method computes the SLL prediction termination condition for both of\n// the following cases.</p>\n//\n// <ul>\n// <li>The usual SLL+LL fallback upon SLL conflict</li>\n// <li>Pure SLL without LL fallback</li>\n// </ul>\n//\n// <p><strong>COMBINED SLL+LL PARSING</strong></p>\n//\n// <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n// ensured regardless of how the termination condition is computed by this\n// method. Due to the substantially higher cost of LL prediction, the\n// prediction should only fall back to LL when the additional lookahead\n// cannot lead to a unique SLL prediction.</p>\n//\n// <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n// conflicting subsets should fall back to full LL, even if the\n// configuration sets don't resolve to the same alternative (e.g.\n// {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n// configuration, SLL could continue with the hopes that more lookahead will\n// resolve via one of those non-conflicting configurations.</p>\n//\n// <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n// stops when it sees only conflicting configuration subsets. In contrast,\n// full LL keeps going when there is uncertainty.</p>\n//\n// <p><strong>HEURISTIC</strong></p>\n//\n// <p>As a heuristic, we stop prediction when we see any conflicting subset\n// unless we see a state that only has one alternative associated with it.\n// The single-alt-state thing lets prediction continue upon rules like\n// (otherwise, it would admit defeat too soon):</p>\n//\n// <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n//\n// <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n// DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n// {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n// processing this node because alternative to has another way to continue,\n// via {@code [6|2|[]]}.</p>\n//\n// <p>It also let's us continue for this rule:</p>\n//\n// <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n//\n// <p>After matching input A, we reach the stop state for rule A, state 1.\n// State 8 is the state right before B. Clearly alternatives 1 and 2\n// conflict and no amount of further lookahead will separate the two.\n// However, alternative 3 will be able to continue and so we do not stop\n// working on this state. In the previous example, we're concerned with\n// states associated with the conflicting alternatives. Here alt 3 is not\n// associated with the conflicting configs, but since we can continue\n// looking for input reasonably, don't declare the state done.</p>\n//\n// <p><strong>PURE SLL PARSING</strong></p>\n//\n// <p>To handle pure SLL parsing, all we have to do is make sure that we\n// combine stack contexts for configurations that differ only by semantic\n// predicate. From there, we can do the usual SLL termination heuristic.</p>\n//\n// <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n//\n// <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n// states because they need to create the DFA cache that works in all\n// semantic situations. In contrast, full LL evaluates predicates collected\n// during start state computation so it can ignore predicates thereafter.\n// This means that SLL termination detection can totally ignore semantic\n// predicates.</p>\n//\n// <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n// semantic predicate contexts so we might see two configurations like the\n// following.</p>\n//\n// <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n//\n// <p>Before testing these configurations against others, we have to merge\n// {@code x} and {@code x'} (without modifying the existing configurations).\n// For example, we test {@code (x+x')==x''} when looking for conflicts in\n// the following configurations.</p>\n//\n// <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n//\n// <p>If the configuration set has predicates (as indicated by\n// {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n// the configurations to strip out all of the predicates so that a standard\n// {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n//\nPredictionMode.hasSLLConflictTerminatingPrediction = function( mode, configs) {\n    // Configs in rule stop states indicate reaching the end of the decision\n    // rule (local context) or end of start rule (full context). If all\n    // configs meet this condition, then none of the configurations is able\n    // to match additional input so we terminate prediction.\n    //\n    if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    // pure SLL mode parsing\n    if (mode === PredictionMode.SLL) {\n        // Don't bother with combining configs from different semantic\n        // contexts if we can fail over to full LL; costs more time\n        // since we'll often fail over anyway.\n        if (configs.hasSemanticContext) {\n            // dup configs, tossing out semantic predicates\n            var dup = new ATNConfigSet();\n            for(var i=0;i<configs.items.length;i++) {\n            \tvar c = configs.items[i];\n                c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                dup.add(c);\n            }\n            configs = dup;\n        }\n        // now we have combined contexts for configs with dissimilar preds\n    }\n    // pure SLL or combined SLL+LL mode parsing\n    var altsets = PredictionMode.getConflictingAltSubsets(configs);\n    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n};\n\n// Checks if any configuration in {@code configs} is in a\n// {@link RuleStopState}. Configurations meeting this condition have reached\n// the end of the decision rule (local context) or end of start rule (full\n// context).\n//\n// @param configs the configuration set to test\n// @return {@code true} if any configuration in {@code configs} is in a\n// {@link RuleStopState}, otherwise {@code false}\nPredictionMode.hasConfigInRuleStopState = function(configs) {\n\tfor(var i=0;i<configs.items.length;i++) {\n\t\tvar c = configs.items[i];\n        if (c.state instanceof RuleStopState) {\n            return true;\n        }\n\t}\n    return false;\n};\n\n// Checks if all configurations in {@code configs} are in a\n// {@link RuleStopState}. Configurations meeting this condition have reached\n// the end of the decision rule (local context) or end of start rule (full\n// context).\n//\n// @param configs the configuration set to test\n// @return {@code true} if all configurations in {@code configs} are in a\n// {@link RuleStopState}, otherwise {@code false}\nPredictionMode.allConfigsInRuleStopStates = function(configs) {\n\tfor(var i=0;i<configs.items.length;i++) {\n\t\tvar c = configs.items[i];\n        if (!(c.state instanceof RuleStopState)) {\n            return false;\n        }\n\t}\n    return true;\n};\n\n//\n// Full LL prediction termination.\n//\n// <p>Can we stop looking ahead during ATN simulation or is there some\n// uncertainty as to which alternative we will ultimately pick, after\n// consuming more input? Even if there are partial conflicts, we might know\n// that everything is going to resolve to the same minimum alternative. That\n// means we can stop since no more lookahead will change that fact. On the\n// other hand, there might be multiple conflicts that resolve to different\n// minimums. That means we need more look ahead to decide which of those\n// alternatives we should predict.</p>\n//\n// <p>The basic idea is to split the set of configurations {@code C}, into\n// conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n// non-conflicting configurations. Two configurations conflict if they have\n// identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n// but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n// and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n//\n// <p>Reduce these configuration subsets to the set of possible alternatives.\n// You can compute the alternative subsets in one pass as follows:</p>\n//\n// <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n// {@code C} holding {@code s} and {@code ctx} fixed.</p>\n//\n// <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n//\n// <pre>\n// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n// alt and not pred\n// </pre>\n//\n// <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n//\n// <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n// {@code s} and {@code ctx}.</p>\n//\n// <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n// the union of these alternative subsets is a singleton, then no amount of\n// more lookahead will help us. We will always pick that alternative. If,\n// however, there is more than one alternative, then we are uncertain which\n// alternative to predict and must continue looking for resolution. We may\n// or may not discover an ambiguity in the future, even if there are no\n// conflicting subsets this round.</p>\n//\n// <p>The biggest sin is to terminate early because it means we've made a\n// decision but were uncertain as to the eventual outcome. We haven't used\n// enough lookahead. On the other hand, announcing a conflict too late is no\n// big deal; you will still have the conflict. It's just inefficient. It\n// might even look until the end of file.</p>\n//\n// <p>No special consideration for semantic predicates is required because\n// predicates are evaluated on-the-fly for full LL prediction, ensuring that\n// no configuration contains a semantic context during the termination\n// check.</p>\n//\n// <p><strong>CONFLICTING CONFIGS</strong></p>\n//\n// <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n// when {@code i!=j} but {@code x=x'}. Because we merge all\n// {@code (s, i, _)} configurations together, that means that there are at\n// most {@code n} configurations associated with state {@code s} for\n// {@code n} possible alternatives in the decision. The merged stacks\n// complicate the comparison of configuration contexts {@code x} and\n// {@code x'}. Sam checks to see if one is a subset of the other by calling\n// merge and checking to see if the merged result is either {@code x} or\n// {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n// is the superset, then {@code i} is the only possible prediction since the\n// others resolve to {@code min(i)} as well. However, if {@code x} is\n// associated with {@code j>i} then at least one stack configuration for\n// {@code j} is not in conflict with alternative {@code i}. The algorithm\n// should keep going, looking for more lookahead due to the uncertainty.</p>\n//\n// <p>For simplicity, I'm doing a equality check between {@code x} and\n// {@code x'} that lets the algorithm continue to consume lookahead longer\n// than necessary. The reason I like the equality is of course the\n// simplicity but also because that is the test you need to detect the\n// alternatives that are actually in conflict.</p>\n//\n// <p><strong>CONTINUE/STOP RULE</strong></p>\n//\n// <p>Continue if union of resolved alternative sets from non-conflicting and\n// conflicting alternative subsets has more than one alternative. We are\n// uncertain about which alternative to predict.</p>\n//\n// <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n// alternatives are still in the running for the amount of input we've\n// consumed at this point. The conflicting sets let us to strip away\n// configurations that won't lead to more states because we resolve\n// conflicts to the configuration with a minimum alternate for the\n// conflicting set.</p>\n//\n// <p><strong>CASES</strong></p>\n//\n// <ul>\n//\n// <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n//\n// <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n// {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n// {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n// {@code {1,3}} =&gt; continue\n// </li>\n//\n// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n// {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n// {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n// {@code {1}} =&gt; stop and predict 1</li>\n//\n// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n// {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n// {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n// ambiguity {@code {1,2}}</li>\n//\n// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n// {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n// {@code {2}} = {@code {1,2}} =&gt; continue</li>\n//\n// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n// {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n// {@code {3}} = {@code {1,3}} =&gt; continue</li>\n//\n// </ul>\n//\n// <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n//\n// <p>If all states report the same conflicting set of alternatives, then we\n// know we have the exact ambiguity set.</p>\n//\n// <p><code>|A_<em>i</em>|&gt;1</code> and\n// <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n//\n// <p>In other words, we continue examining lookahead until all {@code A_i}\n// have more than one alternative and all {@code A_i} are the same. If\n// {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n// because the resolved set is {@code {1}}. To determine what the real\n// ambiguity is, we have to know whether the ambiguity is between one and\n// two or one and three so we keep going. We can only stop prediction when\n// we need exact ambiguity detection when the sets look like\n// {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n//\nPredictionMode.resolvesToJustOneViableAlt = function(altsets) {\n    return PredictionMode.getSingleViableAlt(altsets);\n};\n\n//\n// Determines if every alternative subset in {@code altsets} contains more\n// than one alternative.\n//\n// @param altsets a collection of alternative subsets\n// @return {@code true} if every {@link BitSet} in {@code altsets} has\n// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n//\nPredictionMode.allSubsetsConflict = function(altsets) {\n    return ! PredictionMode.hasNonConflictingAltSet(altsets);\n};\n//\n// Determines if any single alternative subset in {@code altsets} contains\n// exactly one alternative.\n//\n// @param altsets a collection of alternative subsets\n// @return {@code true} if {@code altsets} contains a {@link BitSet} with\n// {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n//\nPredictionMode.hasNonConflictingAltSet = function(altsets) {\n\tfor(var i=0;i<altsets.length;i++) {\n\t\tvar alts = altsets[i];\n        if (alts.length===1) {\n            return true;\n        }\n\t}\n    return false;\n};\n\n//\n// Determines if any single alternative subset in {@code altsets} contains\n// more than one alternative.\n//\n// @param altsets a collection of alternative subsets\n// @return {@code true} if {@code altsets} contains a {@link BitSet} with\n// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n//\nPredictionMode.hasConflictingAltSet = function(altsets) {\n\tfor(var i=0;i<altsets.length;i++) {\n\t\tvar alts = altsets[i];\n        if (alts.length>1) {\n            return true;\n        }\n\t}\n    return false;\n};\n\n//\n// Determines if every alternative subset in {@code altsets} is equivalent.\n//\n// @param altsets a collection of alternative subsets\n// @return {@code true} if every member of {@code altsets} is equal to the\n// others, otherwise {@code false}\n//\nPredictionMode.allSubsetsEqual = function(altsets) {\n    var first = null;\n\tfor(var i=0;i<altsets.length;i++) {\n\t\tvar alts = altsets[i];\n        if (first === null) {\n            first = alts;\n        } else if (alts!==first) {\n            return false;\n        }\n\t}\n    return true;\n};\n\n//\n// Returns the unique alternative predicted by all alternative subsets in\n// {@code altsets}. If no such alternative exists, this method returns\n// {@link ATN//INVALID_ALT_NUMBER}.\n//\n// @param altsets a collection of alternative subsets\n//\nPredictionMode.getUniqueAlt = function(altsets) {\n    var all = PredictionMode.getAlts(altsets);\n    if (all.length===1) {\n        return all.minValue();\n    } else {\n        return ATN.INVALID_ALT_NUMBER;\n    }\n};\n\n// Gets the complete set of represented alternatives for a collection of\n// alternative subsets. This method returns the union of each {@link BitSet}\n// in {@code altsets}.\n//\n// @param altsets a collection of alternative subsets\n// @return the set of represented alternatives in {@code altsets}\n//\nPredictionMode.getAlts = function(altsets) {\n    var all = new BitSet();\n    altsets.map( function(alts) { all.or(alts); });\n    return all;\n};\n\n//\n// This function gets the conflicting alt subsets from a configuration set.\n// For each configuration {@code c} in {@code configs}:\n//\n// <pre>\n// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n// alt and not pred\n// </pre>\n\nPredictionMode.getConflictingAltSubsets = function(configs) {\n    var configToAlts = new Map();\n    configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n    configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber==c2.state.stateNumber && c1.context.equals(c2.context);}\n    configs.items.map(function(cfg) {\n        var alts = configToAlts.get(cfg);\n        if (alts === null) {\n            alts = new BitSet();\n            configToAlts.put(cfg, alts);\n        }\n        alts.add(cfg.alt);\n\t});\n    return configToAlts.getValues();\n};\n\n//\n// Get a map from state to alt subset from a configuration set. For each\n// configuration {@code c} in {@code configs}:\n//\n// <pre>\n// map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n// </pre>\n//\nPredictionMode.getStateToAltMap = function(configs) {\n    var m = new AltDict();\n    configs.items.map(function(c) {\n        var alts = m.get(c.state);\n        if (alts === null) {\n            alts = new BitSet();\n            m.put(c.state, alts);\n        }\n        alts.add(c.alt);\n    });\n    return m;\n};\n\nPredictionMode.hasStateAssociatedWithOneAlt = function(configs) {\n    var values = PredictionMode.getStateToAltMap(configs).values();\n    for(var i=0;i<values.length;i++) {\n        if (values[i].length===1) {\n            return true;\n        }\n    }\n    return false;\n};\n\nPredictionMode.getSingleViableAlt = function(altsets) {\n    var result = null;\n\tfor(var i=0;i<altsets.length;i++) {\n\t\tvar alts = altsets[i];\n        var minAlt = alts.minValue();\n        if(result===null) {\n            result = minAlt;\n        } else if(result!==minAlt) { // more than 1 viable alt\n            return ATN.INVALID_ALT_NUMBER;\n        }\n\t}\n    return result;\n};\n\nexports.PredictionMode = PredictionMode;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n// A tree structure used to record the semantic context in which\n//  an ATN configuration is valid.  It's either a single predicate,\n//  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n//\n//  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n//  {@link SemanticContext} within the scope of this outer class.</p>\n//\n\nvar Set = require('./../Utils').Set;\nvar Hash = require('./../Utils').Hash;\n\nfunction SemanticContext() {\n\treturn this;\n}\n\nSemanticContext.prototype.hashCode = function() {\n    var hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n};\n\n// For context independent predicates, we evaluate them without a local\n// context (i.e., null context). That way, we can evaluate them without\n// having to create proper rule-specific context during prediction (as\n// opposed to the parser, which creates them naturally). In a practical\n// sense, this avoids a cast exception from RuleContext to myruleContext.\n//\n// <p>For context dependent predicates, we must pass in a local context so that\n// references such as $arg evaluate properly as _localctx.arg. We only\n// capture context dependent predicates in the context in which we begin\n// prediction, so we passed in the outer context here in case of context\n// dependent predicate evaluation.</p>\n//\nSemanticContext.prototype.evaluate = function(parser, outerContext) {\n};\n\n//\n// Evaluate the precedence predicates for the context and reduce the result.\n//\n// @param parser The parser instance.\n// @param outerContext The current parser context object.\n// @return The simplified semantic context after precedence predicates are\n// evaluated, which will be one of the following values.\n// <ul>\n// <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n// precedence predicates are evaluated.</li>\n// <li>{@code null}: if the predicate simplifies to {@code false} after\n// precedence predicates are evaluated.</li>\n// <li>{@code this}: if the semantic context is not changed as a result of\n// precedence predicate evaluation.</li>\n// <li>A non-{@code null} {@link SemanticContext}: the new simplified\n// semantic context after precedence predicates are evaluated.</li>\n// </ul>\n//\nSemanticContext.prototype.evalPrecedence = function(parser, outerContext) {\n\treturn this;\n};\n\nSemanticContext.andContext = function(a, b) {\n\tif (a === null || a === SemanticContext.NONE) {\n\t\treturn b;\n\t}\n\tif (b === null || b === SemanticContext.NONE) {\n\t\treturn a;\n\t}\n\tvar result = new AND(a, b);\n\tif (result.opnds.length === 1) {\n\t\treturn result.opnds[0];\n\t} else {\n\t\treturn result;\n\t}\n};\n\nSemanticContext.orContext = function(a, b) {\n\tif (a === null) {\n\t\treturn b;\n\t}\n\tif (b === null) {\n\t\treturn a;\n\t}\n\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\treturn SemanticContext.NONE;\n\t}\n\tvar result = new OR(a, b);\n\tif (result.opnds.length === 1) {\n\t\treturn result.opnds[0];\n\t} else {\n\t\treturn result;\n\t}\n};\n\nfunction Predicate(ruleIndex, predIndex, isCtxDependent) {\n\tSemanticContext.call(this);\n\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\treturn this;\n}\n\nPredicate.prototype = Object.create(SemanticContext.prototype);\nPredicate.prototype.constructor = Predicate;\n\n//The default {@link SemanticContext}, which is semantically equivalent to\n//a predicate of the form {@code {true}?}.\n//\nSemanticContext.NONE = new Predicate();\n\n\nPredicate.prototype.evaluate = function(parser, outerContext) {\n\tvar localctx = this.isCtxDependent ? outerContext : null;\n\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n};\n\nPredicate.prototype.updateHashCode = function(hash) {\n\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n};\n\nPredicate.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof Predicate)) {\n\t\treturn false;\n\t} else {\n\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t}\n};\n\nPredicate.prototype.toString = function() {\n\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n};\n\nfunction PrecedencePredicate(precedence) {\n\tSemanticContext.call(this);\n\tthis.precedence = precedence === undefined ? 0 : precedence;\n}\n\nPrecedencePredicate.prototype = Object.create(SemanticContext.prototype);\nPrecedencePredicate.prototype.constructor = PrecedencePredicate;\n\nPrecedencePredicate.prototype.evaluate = function(parser, outerContext) {\n\treturn parser.precpred(outerContext, this.precedence);\n};\n\nPrecedencePredicate.prototype.evalPrecedence = function(parser, outerContext) {\n\tif (parser.precpred(outerContext, this.precedence)) {\n\t\treturn SemanticContext.NONE;\n\t} else {\n\t\treturn null;\n\t}\n};\n\nPrecedencePredicate.prototype.compareTo = function(other) {\n\treturn this.precedence - other.precedence;\n};\n\nPrecedencePredicate.prototype.updateHashCode = function(hash) {\n    hash.update(31);\n};\n\nPrecedencePredicate.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\treturn false;\n\t} else {\n\t\treturn this.precedence === other.precedence;\n\t}\n};\n\nPrecedencePredicate.prototype.toString = function() {\n\treturn \"{\"+this.precedence+\">=prec}?\";\n};\n\n\n\nPrecedencePredicate.filterPrecedencePredicates = function(set) {\n\tvar result = [];\n\tset.values().map( function(context) {\n\t\tif (context instanceof PrecedencePredicate) {\n\t\t\tresult.push(context);\n\t\t}\n\t});\n\treturn result;\n};\n\n\n// A semantic context which is true whenever none of the contained contexts\n// is false.\n//\nfunction AND(a, b) {\n\tSemanticContext.call(this);\n\tvar operands = new Set();\n\tif (a instanceof AND) {\n\t\ta.opnds.map(function(o) {\n\t\t\toperands.add(o);\n\t\t});\n\t} else {\n\t\toperands.add(a);\n\t}\n\tif (b instanceof AND) {\n\t\tb.opnds.map(function(o) {\n\t\t\toperands.add(o);\n\t\t});\n\t} else {\n\t\toperands.add(b);\n\t}\n\tvar precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\tif (precedencePredicates.length > 0) {\n\t\t// interested in the transition with the lowest precedence\n\t\tvar reduced = null;\n\t\tprecedencePredicates.map( function(p) {\n\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\treduced = p;\n\t\t\t}\n\t\t});\n\t\toperands.add(reduced);\n\t}\n\tthis.opnds = operands.values();\n\treturn this;\n}\n\nAND.prototype = Object.create(SemanticContext.prototype);\nAND.prototype.constructor = AND;\n\nAND.prototype.equals = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof AND)) {\n\t\treturn false;\n\t} else {\n\t\treturn this.opnds === other.opnds;\n\t}\n};\n\nAND.prototype.updateHashCode = function(hash) {\n    hash.update(this.opnds, \"AND\");\n};\n//\n// {@inheritDoc}\n//\n// <p>\n// The evaluation of predicates by this context is short-circuiting, but\n// unordered.</p>\n//\nAND.prototype.evaluate = function(parser, outerContext) {\n\tfor (var i = 0; i < this.opnds.length; i++) {\n\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nAND.prototype.evalPrecedence = function(parser, outerContext) {\n\tvar differs = false;\n\tvar operands = [];\n\tfor (var i = 0; i < this.opnds.length; i++) {\n\t\tvar context = this.opnds[i];\n\t\tvar evaluated = context.evalPrecedence(parser, outerContext);\n\t\tdiffers |= (evaluated !== context);\n\t\tif (evaluated === null) {\n\t\t\t// The AND context is false if any element is false\n\t\t\treturn null;\n\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t// Reduce the result by skipping true elements\n\t\t\toperands.push(evaluated);\n\t\t}\n\t}\n\tif (!differs) {\n\t\treturn this;\n\t}\n\tif (operands.length === 0) {\n\t\t// all elements were true, so the AND context is true\n\t\treturn SemanticContext.NONE;\n\t}\n\tvar result = null;\n\toperands.map(function(o) {\n\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t});\n\treturn result;\n};\n\nAND.prototype.toString = function() {\n\tvar s = \"\";\n\tthis.opnds.map(function(o) {\n\t\ts += \"&& \" + o.toString();\n\t});\n\treturn s.length > 3 ? s.slice(3) : s;\n};\n\n//\n// A semantic context which is true whenever at least one of the contained\n// contexts is true.\n//\nfunction OR(a, b) {\n\tSemanticContext.call(this);\n\tvar operands = new Set();\n\tif (a instanceof OR) {\n\t\ta.opnds.map(function(o) {\n\t\t\toperands.add(o);\n\t\t});\n\t} else {\n\t\toperands.add(a);\n\t}\n\tif (b instanceof OR) {\n\t\tb.opnds.map(function(o) {\n\t\t\toperands.add(o);\n\t\t});\n\t} else {\n\t\toperands.add(b);\n\t}\n\n\tvar precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\tif (precedencePredicates.length > 0) {\n\t\t// interested in the transition with the highest precedence\n\t\tvar s = precedencePredicates.sort(function(a, b) {\n\t\t\treturn a.compareTo(b);\n\t\t});\n\t\tvar reduced = s[s.length-1];\n\t\toperands.add(reduced);\n\t}\n\tthis.opnds = operands.values();\n\treturn this;\n}\n\nOR.prototype = Object.create(SemanticContext.prototype);\nOR.prototype.constructor = OR;\n\nOR.prototype.constructor = function(other) {\n\tif (this === other) {\n\t\treturn true;\n\t} else if (!(other instanceof OR)) {\n\t\treturn false;\n\t} else {\n\t\treturn this.opnds === other.opnds;\n\t}\n};\n\nOR.prototype.updateHashCode = function(hash) {\n    hash.update(this.opnds, \"OR\");\n};\n\n// <p>\n// The evaluation of predicates by this context is short-circuiting, but\n// unordered.</p>\n//\nOR.prototype.evaluate = function(parser, outerContext) {\n\tfor (var i = 0; i < this.opnds.length; i++) {\n\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\nOR.prototype.evalPrecedence = function(parser, outerContext) {\n\tvar differs = false;\n\tvar operands = [];\n\tfor (var i = 0; i < this.opnds.length; i++) {\n\t\tvar context = this.opnds[i];\n\t\tvar evaluated = context.evalPrecedence(parser, outerContext);\n\t\tdiffers |= (evaluated !== context);\n\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t// The OR context is true if any element is true\n\t\t\treturn SemanticContext.NONE;\n\t\t} else if (evaluated !== null) {\n\t\t\t// Reduce the result by skipping false elements\n\t\t\toperands.push(evaluated);\n\t\t}\n\t}\n\tif (!differs) {\n\t\treturn this;\n\t}\n\tif (operands.length === 0) {\n\t\t// all elements were false, so the OR context is false\n\t\treturn null;\n\t}\n\tvar result = null;\n\toperands.map(function(o) {\n\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t});\n\treturn result;\n};\n\nOR.prototype.toString = function() {\n\tvar s = \"\";\n\tthis.opnds.map(function(o) {\n\t\ts += \"|| \" + o.toString();\n\t});\n\treturn s.length > 3 ? s.slice(3) : s;\n};\n\nexports.SemanticContext = SemanticContext;\nexports.PrecedencePredicate = PrecedencePredicate;\nexports.Predicate = Predicate;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n//  An ATN transition between any two ATN states.  Subclasses define\n//  atom, set, epsilon, action, predicate, rule transitions.\n//\n//  <p>This is a one way link.  It emanates from a state (usually via a list of\n//  transitions) and has a target state.</p>\n//\n//  <p>Since we never have to change the ATN transitions once we construct it,\n//  we can fix these transitions as specific classes. The DFA transitions\n//  on the other hand need to update the labels as it adds transitions to\n//  the states. We'll use the term Edge for the DFA to distinguish them from\n//  ATN transitions.</p>\n\nvar Token = require('./../Token').Token;\nvar Interval = require('./../IntervalSet').Interval;\nvar IntervalSet = require('./../IntervalSet').IntervalSet;\nvar Predicate = require('./SemanticContext').Predicate;\nvar PrecedencePredicate = require('./SemanticContext').PrecedencePredicate;\n\nfunction Transition (target) {\n    // The target of this transition.\n    if (target===undefined || target===null) {\n        throw \"target cannot be null.\";\n    }\n    this.target = target;\n    // Are we epsilon, action, sempred?\n    this.isEpsilon = false;\n    this.label = null;\n    return this;\n}\n    // constants for serialization\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\nTransition.PREDICATE = 4; // e.g., {isType(input.LT(1))}?\nTransition.ATOM = 5;\nTransition.ACTION = 6;\nTransition.SET = 7; // ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\nfunction AtomTransition(target, label) {\n\tTransition.call(this, target);\n\tthis.label_ = label; // The token type or character value; or, signifies special label.\n    this.label = this.makeLabel();\n    this.serializationType = Transition.ATOM;\n    return this;\n}\n\nAtomTransition.prototype = Object.create(Transition.prototype);\nAtomTransition.prototype.constructor = AtomTransition;\n\nAtomTransition.prototype.makeLabel = function() {\n\tvar s = new IntervalSet();\n    s.addOne(this.label_);\n    return s;\n};\n\nAtomTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {\n    return this.label_ === symbol;\n};\n\nAtomTransition.prototype.toString = function() {\n\treturn this.label_;\n};\n\nfunction RuleTransition(ruleStart, ruleIndex, precedence, followState) {\n\tTransition.call(this, ruleStart);\n    this.ruleIndex = ruleIndex; // ptr to the rule definition object for this rule ref\n    this.precedence = precedence;\n    this.followState = followState; // what node to begin computations following ref to rule\n    this.serializationType = Transition.RULE;\n    this.isEpsilon = true;\n    return this;\n}\n\nRuleTransition.prototype = Object.create(Transition.prototype);\nRuleTransition.prototype.constructor = RuleTransition;\n\nRuleTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn false;\n};\n\n\nfunction EpsilonTransition(target, outermostPrecedenceReturn) {\n\tTransition.call(this, target);\n    this.serializationType = Transition.EPSILON;\n    this.isEpsilon = true;\n    this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    return this;\n}\n\nEpsilonTransition.prototype = Object.create(Transition.prototype);\nEpsilonTransition.prototype.constructor = EpsilonTransition;\n\nEpsilonTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn false;\n};\n\nEpsilonTransition.prototype.toString = function() {\n\treturn \"epsilon\";\n};\n\nfunction RangeTransition(target, start, stop) {\n\tTransition.call(this, target);\n\tthis.serializationType = Transition.RANGE;\n    this.start = start;\n    this.stop = stop;\n    this.label = this.makeLabel();\n    return this;\n}\n\nRangeTransition.prototype = Object.create(Transition.prototype);\nRangeTransition.prototype.constructor = RangeTransition;\n\nRangeTransition.prototype.makeLabel = function() {\n    var s = new IntervalSet();\n    s.addRange(this.start, this.stop);\n    return s;\n};\n\nRangeTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn symbol >= this.start && symbol <= this.stop;\n};\n\nRangeTransition.prototype.toString = function() {\n\treturn \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n};\n\nfunction AbstractPredicateTransition(target) {\n\tTransition.call(this, target);\n\treturn this;\n}\n\nAbstractPredicateTransition.prototype = Object.create(Transition.prototype);\nAbstractPredicateTransition.prototype.constructor = AbstractPredicateTransition;\n\nfunction PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {\n\tAbstractPredicateTransition.call(this, target);\n    this.serializationType = Transition.PREDICATE;\n    this.ruleIndex = ruleIndex;\n    this.predIndex = predIndex;\n    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n    this.isEpsilon = true;\n    return this;\n}\n\nPredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);\nPredicateTransition.prototype.constructor = PredicateTransition;\n\nPredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn false;\n};\n\nPredicateTransition.prototype.getPredicate = function() {\n\treturn new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n};\n\nPredicateTransition.prototype.toString = function() {\n\treturn \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n};\n\nfunction ActionTransition(target, ruleIndex, actionIndex, isCtxDependent) {\n\tTransition.call(this, target);\n    this.serializationType = Transition.ACTION;\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n    this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n    this.isEpsilon = true;\n    return this;\n}\n\nActionTransition.prototype = Object.create(Transition.prototype);\nActionTransition.prototype.constructor = ActionTransition;\n\n\nActionTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn false;\n};\n\nActionTransition.prototype.toString = function() {\n\treturn \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n};\n\n\n// A transition containing a set of values.\nfunction SetTransition(target, set) {\n\tTransition.call(this, target);\n\tthis.serializationType = Transition.SET;\n    if (set !==undefined && set !==null) {\n        this.label = set;\n    } else {\n        this.label = new IntervalSet();\n        this.label.addOne(Token.INVALID_TYPE);\n    }\n    return this;\n}\n\nSetTransition.prototype = Object.create(Transition.prototype);\nSetTransition.prototype.constructor = SetTransition;\n\nSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn this.label.contains(symbol);\n};\n\n\nSetTransition.prototype.toString = function() {\n\treturn this.label.toString();\n};\n\nfunction NotSetTransition(target, set) {\n\tSetTransition.call(this, target, set);\n\tthis.serializationType = Transition.NOT_SET;\n\treturn this;\n}\n\nNotSetTransition.prototype = Object.create(SetTransition.prototype);\nNotSetTransition.prototype.constructor = NotSetTransition;\n\nNotSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n\t\t\t!SetTransition.prototype.matches.call(this, symbol, minVocabSymbol, maxVocabSymbol);\n};\n\nNotSetTransition.prototype.toString = function() {\n\treturn '~' + SetTransition.prototype.toString.call(this);\n};\n\nfunction WildcardTransition(target) {\n\tTransition.call(this, target);\n\tthis.serializationType = Transition.WILDCARD;\n\treturn this;\n}\n\nWildcardTransition.prototype = Object.create(Transition.prototype);\nWildcardTransition.prototype.constructor = WildcardTransition;\n\n\nWildcardTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n};\n\nWildcardTransition.prototype.toString = function() {\n\treturn \".\";\n};\n\nfunction PrecedencePredicateTransition(target, precedence) {\n\tAbstractPredicateTransition.call(this, target);\n    this.serializationType = Transition.PRECEDENCE;\n    this.precedence = precedence;\n    this.isEpsilon = true;\n    return this;\n}\n\nPrecedencePredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);\nPrecedencePredicateTransition.prototype.constructor = PrecedencePredicateTransition;\n\nPrecedencePredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {\n\treturn false;\n};\n\nPrecedencePredicateTransition.prototype.getPredicate = function() {\n\treturn new PrecedencePredicate(this.precedence);\n};\n\nPrecedencePredicateTransition.prototype.toString = function() {\n\treturn this.precedence + \" >= _p\";\n};\n\nexports.Transition = Transition;\nexports.AtomTransition = AtomTransition;\nexports.SetTransition = SetTransition;\nexports.NotSetTransition = NotSetTransition;\nexports.RuleTransition = RuleTransition;\nexports.ActionTransition = ActionTransition;\nexports.EpsilonTransition = EpsilonTransition;\nexports.RangeTransition = RangeTransition;\nexports.WildcardTransition = WildcardTransition;\nexports.PredicateTransition = PredicateTransition;\nexports.PrecedencePredicateTransition = PrecedencePredicateTransition;\nexports.AbstractPredicateTransition = AbstractPredicateTransition;","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.ATN = require('./ATN').ATN;\nexports.ATNDeserializer = require('./ATNDeserializer').ATNDeserializer;\nexports.LexerATNSimulator = require('./LexerATNSimulator').LexerATNSimulator;\nexports.ParserATNSimulator = require('./ParserATNSimulator').ParserATNSimulator;\nexports.PredictionMode = require('./PredictionMode').PredictionMode;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar Set = require(\"../Utils\").Set;\nvar DFAState = require('./DFAState').DFAState;\nvar StarLoopEntryState = require('../atn/ATNState').StarLoopEntryState;\nvar ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;\nvar DFASerializer = require('./DFASerializer').DFASerializer;\nvar LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;\n\n\n\nfunction DFA(atnStartState, decision) {\n\tif (decision === undefined) {\n\t\tdecision = 0;\n\t}\n\t// From which ATN state did we create this DFA?\n\tthis.atnStartState = atnStartState;\n\tthis.decision = decision;\n\t// A set of all DFA states. Use {@link Map} so we can get old state back\n\t// ({@link Set} only allows you to see if it's there).\n\tthis._states = new Set();\n\tthis.s0 = null;\n\t// {@code true} if this DFA is for a precedence decision; otherwise,\n\t// {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t// {@link //setPrecedenceDfa}.\n\tthis.precedenceDfa = false;\n    if (atnStartState instanceof StarLoopEntryState)\n    {\n        if (atnStartState.isPrecedenceDecision) {\n            this.precedenceDfa = true;\n            var precedenceState = new DFAState(null, new ATNConfigSet());\n            precedenceState.edges = [];\n            precedenceState.isAcceptState = false;\n            precedenceState.requiresFullContext = false;\n            this.s0 = precedenceState;\n        }\n    }\n\treturn this;\n}\n\n// Get the start state for a specific precedence value.\n//\n// @param precedence The current precedence.\n// @return The start state corresponding to the specified precedence, or\n// {@code null} if no start state exists for the specified precedence.\n//\n// @throws IllegalStateException if this is not a precedence DFA.\n// @see //isPrecedenceDfa()\n\nDFA.prototype.getPrecedenceStartState = function(precedence) {\n\tif (!(this.precedenceDfa)) {\n\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t}\n\t// s0.edges is never null for a precedence DFA\n\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\treturn null;\n\t}\n\treturn this.s0.edges[precedence] || null;\n};\n\n// Set the start state for a specific precedence value.\n//\n// @param precedence The current precedence.\n// @param startState The start state corresponding to the specified\n// precedence.\n//\n// @throws IllegalStateException if this is not a precedence DFA.\n// @see //isPrecedenceDfa()\n//\nDFA.prototype.setPrecedenceStartState = function(precedence, startState) {\n\tif (!(this.precedenceDfa)) {\n\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t}\n\tif (precedence < 0) {\n\t\treturn;\n\t}\n\n\t// synchronization on s0 here is ok. when the DFA is turned into a\n\t// precedence DFA, s0 will be initialized once and not updated again\n\t// s0.edges is never null for a precedence DFA\n\tthis.s0.edges[precedence] = startState;\n};\n\n//\n// Sets whether this is a precedence DFA. If the specified value differs\n// from the current DFA configuration, the following actions are taken;\n// otherwise no changes are made to the current DFA.\n//\n// <ul>\n// <li>The {@link //states} map is cleared</li>\n// <li>If {@code precedenceDfa} is {@code false}, the initial state\n// {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n// {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n// store the start states for individual precedence values.</li>\n// <li>The {@link //precedenceDfa} field is updated</li>\n// </ul>\n//\n// @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n// {@code false}\n\nDFA.prototype.setPrecedenceDfa = function(precedenceDfa) {\n\tif (this.precedenceDfa!==precedenceDfa) {\n\t\tthis._states = new DFAStatesSet();\n\t\tif (precedenceDfa) {\n\t\t\tvar precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\tprecedenceState.edges = [];\n\t\t\tprecedenceState.isAcceptState = false;\n\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\tthis.s0 = precedenceState;\n\t\t} else {\n\t\t\tthis.s0 = null;\n\t\t}\n\t\tthis.precedenceDfa = precedenceDfa;\n\t}\n};\n\nObject.defineProperty(DFA.prototype, \"states\", {\n\tget : function() {\n\t\treturn this._states;\n\t}\n});\n\n// Return a list of all states in this DFA, ordered by state number.\nDFA.prototype.sortedStates = function() {\n\tvar list = this._states.values();\n\treturn list.sort(function(a, b) {\n\t\treturn a.stateNumber - b.stateNumber;\n\t});\n};\n\nDFA.prototype.toString = function(literalNames, symbolicNames) {\n\tliteralNames = literalNames || null;\n\tsymbolicNames = symbolicNames || null;\n\tif (this.s0 === null) {\n\t\treturn \"\";\n\t}\n\tvar serializer = new DFASerializer(this, literalNames, symbolicNames);\n\treturn serializer.toString();\n};\n\nDFA.prototype.toLexerString = function() {\n\tif (this.s0 === null) {\n\t\treturn \"\";\n\t}\n\tvar serializer = new LexerDFASerializer(this);\n\treturn serializer.toString();\n};\n\nexports.DFA = DFA;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n// A DFA walker that knows how to dump them to serialized strings.#/\n\n\nfunction DFASerializer(dfa, literalNames, symbolicNames) {\n\tthis.dfa = dfa;\n\tthis.literalNames = literalNames || [];\n\tthis.symbolicNames = symbolicNames || [];\n\treturn this;\n}\n\nDFASerializer.prototype.toString = function() {\n   if(this.dfa.s0 === null) {\n       return null;\n   }\n   var buf = \"\";\n   var states = this.dfa.sortedStates();\n   for(var i=0;i<states.length;i++) {\n       var s = states[i];\n       if(s.edges!==null) {\n            var n = s.edges.length;\n            for(var j=0;j<n;j++) {\n                var t = s.edges[j] || null;\n                if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                    buf = buf.concat(this.getStateString(s));\n                    buf = buf.concat(\"-\");\n                    buf = buf.concat(this.getEdgeLabel(j));\n                    buf = buf.concat(\"->\");\n                    buf = buf.concat(this.getStateString(t));\n                    buf = buf.concat('\\n');\n                }\n            }\n       }\n   }\n   return buf.length===0 ? null : buf;\n};\n\nDFASerializer.prototype.getEdgeLabel = function(i) {\n    if (i===0) {\n        return \"EOF\";\n    } else if(this.literalNames !==null || this.symbolicNames!==null) {\n        return this.literalNames[i-1] || this.symbolicNames[i-1];\n    } else {\n        return String.fromCharCode(i-1);\n    }\n};\n\nDFASerializer.prototype.getStateString = function(s) {\n    var baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n    if(s.isAcceptState) {\n        if (s.predicates !== null) {\n            return baseStateStr + \"=>\" + s.predicates.toString();\n        } else {\n            return baseStateStr + \"=>\" + s.prediction.toString();\n        }\n    } else {\n        return baseStateStr;\n    }\n};\n\nfunction LexerDFASerializer(dfa) {\n\tDFASerializer.call(this, dfa, null);\n\treturn this;\n}\n\nLexerDFASerializer.prototype = Object.create(DFASerializer.prototype);\nLexerDFASerializer.prototype.constructor = LexerDFASerializer;\n\nLexerDFASerializer.prototype.getEdgeLabel = function(i) {\n\treturn \"'\" + String.fromCharCode(i) + \"'\";\n};\n\nexports.DFASerializer = DFASerializer;\nexports.LexerDFASerializer = LexerDFASerializer;\n\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\nvar ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;\nvar Utils = require('./../Utils');\nvar Hash = Utils.Hash;\nvar Set = Utils.Set;\n\n// Map a predicate to a predicted alternative.///\n\nfunction PredPrediction(pred, alt) {\n\tthis.alt = alt;\n\tthis.pred = pred;\n\treturn this;\n}\n\nPredPrediction.prototype.toString = function() {\n\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n};\n\n// A DFA state represents a set of possible ATN configurations.\n// As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n// to keep track of all possible states the ATN can be in after\n// reading each input symbol. That is to say, after reading\n// input a1a2..an, the DFA is in a state that represents the\n// subset T of the states of the ATN that are reachable from the\n// ATN's start state along some path labeled a1a2..an.\"\n// In conventional NFA&rarr;DFA conversion, therefore, the subset T\n// would be a bitset representing the set of states the\n// ATN could be in. We need to track the alt predicted by each\n// state as well, however. More importantly, we need to maintain\n// a stack of states, tracking the closure operations as they\n// jump from rule to rule, emulating rule invocations (method calls).\n// I have to add a stack to simulate the proper lookahead sequences for\n// the underlying LL grammar from which the ATN was derived.\n//\n// <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n// is both a state (ala normal conversion) and a RuleContext describing\n// the chain of rules (if any) followed to arrive at that state.</p>\n//\n// <p>A DFA state may have multiple references to a particular state,\n// but with different ATN contexts (with same or different alts)\n// meaning that state was reached via a different set of rule invocations.</p>\n// /\n\nfunction DFAState(stateNumber, configs) {\n\tif (stateNumber === null) {\n\t\tstateNumber = -1;\n\t}\n\tif (configs === null) {\n\t\tconfigs = new ATNConfigSet();\n\t}\n\tthis.stateNumber = stateNumber;\n\tthis.configs = configs;\n\t// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t// {@link Token//EOF} maps to {@code edges[0]}.\n\tthis.edges = null;\n\tthis.isAcceptState = false;\n\t// if accept state, what ttype do we match or alt do we predict?\n\t// This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link\n\t// //predicates}{@code !=null} or\n\t// {@link //requiresFullContext}.\n\tthis.prediction = 0;\n\tthis.lexerActionExecutor = null;\n\t// Indicates that this state was created during SLL prediction that\n\t// discovered a conflict between the configurations in the state. Future\n\t// {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t// full context prediction if this field is true.\n\tthis.requiresFullContext = false;\n\t// During SLL parsing, this is a list of predicates associated with the\n\t// ATN configurations of the DFA state. When we have predicates,\n\t// {@link //requiresFullContext} is {@code false} since full context\n\t// prediction evaluates predicates\n\t// on-the-fly. If this is not null, then {@link //prediction} is\n\t// {@link ATN//INVALID_ALT_NUMBER}.\n\t//\n\t// <p>We only use these for non-{@link //requiresFullContext} but\n\t// conflicting states. That\n\t// means we know from the context (it's $ or we don't dip into outer\n\t// context) that it's an ambiguity not a conflict.</p>\n\t//\n\t// <p>This list is computed by {@link\n\t// ParserATNSimulator//predicateDFAState}.</p>\n\tthis.predicates = null;\n\treturn this;\n}\n\n// Get the set of all alts mentioned by all ATN configurations in this\n// DFA state.\nDFAState.prototype.getAltSet = function() {\n\tvar alts = new Set();\n\tif (this.configs !== null) {\n\t\tfor (var i = 0; i < this.configs.length; i++) {\n\t\t\tvar c = this.configs[i];\n\t\t\talts.add(c.alt);\n\t\t}\n\t}\n\tif (alts.length === 0) {\n\t\treturn null;\n\t} else {\n\t\treturn alts;\n\t}\n};\n\n// Two {@link DFAState} instances are equal if their ATN configuration sets\n// are the same. This method is used to see if a state already exists.\n//\n// <p>Because the number of alternatives and number of ATN configurations are\n// finite, there is a finite number of DFA states that can be processed.\n// This is necessary to show that the algorithm terminates.</p>\n//\n// <p>Cannot test the DFA state numbers here because in\n// {@link ParserATNSimulator//addDFAState} we need to know if any other state\n// exists that has this exact set of ATN configurations. The\n// {@link //stateNumber} is irrelevant.</p>\nDFAState.prototype.equals = function(other) {\n\t// compare set of ATN configurations in this set with other\n\treturn this === other ||\n\t\t\t(other instanceof DFAState &&\n\t\t\t\tthis.configs.equals(other.configs));\n};\n\nDFAState.prototype.toString = function() {\n\tvar s = \"\" + this.stateNumber + \":\" + this.configs;\n\tif(this.isAcceptState) {\n        s = s + \"=>\";\n        if (this.predicates !== null)\n            s = s + this.predicates;\n        else\n            s = s + this.prediction;\n    }\n\treturn s;\n};\n\nDFAState.prototype.hashCode = function() {\n\tvar hash = new Hash();\n\thash.update(this.configs);\n\tif(this.isAcceptState) {\n        if (this.predicates !== null)\n            hash.update(this.predicates);\n        else\n            hash.update(this.prediction);\n    }\n    return hash.finish();\n};\n\nexports.DFAState = DFAState;\nexports.PredPrediction = PredPrediction;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.DFA = require('./DFA').DFA;\nexports.DFASerializer = require('./DFASerializer').DFASerializer;\nexports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;\nexports.PredPrediction = require('./DFAState').PredPrediction;\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\n//\n// This implementation of {@link ANTLRErrorListener} can be used to identify\n// certain potential correctness and performance problems in grammars. \"Reports\"\n// are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n// message.\n//\n// <ul>\n// <li><b>Ambiguities</b>: These are cases where more than one path through the\n// grammar can match the input.</li>\n// <li><b>Weak context sensitivity</b>: These are cases where full-context\n// prediction resolved an SLL conflict to a unique alternative which equaled the\n// minimum alternative of the SLL conflict.</li>\n// <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n// full-context prediction resolved an SLL conflict to a unique alternative,\n// <em>and</em> the minimum alternative of the SLL conflict was found to not be\n// a truly viable alternative. Two-stage parsing cannot be used for inputs where\n// this situation occurs.</li>\n// </ul>\n\nvar BitSet = require('./../Utils').BitSet;\nvar ErrorListener = require('./ErrorListener').ErrorListener;\nvar Interval = require('./../IntervalSet').Interval;\n\nfunction DiagnosticErrorListener(exactOnly) {\n\tErrorListener.call(this);\n\texactOnly = exactOnly || true;\n\t// whether all ambiguities or only exact ambiguities are reported.\n\tthis.exactOnly = exactOnly;\n\treturn this;\n}\n\nDiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);\nDiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;\n\nDiagnosticErrorListener.prototype.reportAmbiguity = function(recognizer, dfa,\n\t\tstartIndex, stopIndex, exact, ambigAlts, configs) {\n\tif (this.exactOnly && !exact) {\n\t\treturn;\n\t}\n\tvar msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n\trecognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.reportAttemptingFullContext = function(\n\t\trecognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\tvar msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n\trecognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.reportContextSensitivity = function(\n\t\trecognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\tvar msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n\trecognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.getDecisionDescription = function(recognizer, dfa) {\n\tvar decision = dfa.decision;\n\tvar ruleIndex = dfa.atnStartState.ruleIndex;\n\n\tvar ruleNames = recognizer.ruleNames;\n\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\treturn \"\" + decision;\n\t}\n\tvar ruleName = ruleNames[ruleIndex] || null;\n\tif (ruleName === null || ruleName.length === 0) {\n\t\treturn \"\" + decision;\n\t}\n\treturn \"\" + decision + \" (\" + ruleName + \")\";\n};\n\n//\n// Computes the set of conflicting or ambiguous alternatives from a\n// configuration set, if that information was not already provided by the\n// parser.\n//\n// @param reportedAlts The set of conflicting or ambiguous alternatives, as\n// reported by the parser.\n// @param configs The conflicting or ambiguous configuration set.\n// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n// returns the set of alternatives represented in {@code configs}.\n//\nDiagnosticErrorListener.prototype.getConflictingAlts = function(reportedAlts, configs) {\n\tif (reportedAlts !== null) {\n\t\treturn reportedAlts;\n\t}\n\tvar result = new BitSet();\n\tfor (var i = 0; i < configs.items.length; i++) {\n\t\tresult.add(configs.items[i].alt);\n\t}\n\treturn \"{\" + result.values().join(\", \") + \"}\";\n};\n\nexports.DiagnosticErrorListener = DiagnosticErrorListener;","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n// Provides an empty default implementation of {@link ANTLRErrorListener}. The\n// default implementation of each method does nothing, but can be overridden as\n// necessary.\n\nfunction ErrorListener() {\n\treturn this;\n}\n\nErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {\n};\n\nErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n};\n\nErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n};\n\nErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n};\n\nfunction ConsoleErrorListener() {\n\tErrorListener.call(this);\n\treturn this;\n}\n\nConsoleErrorListener.prototype = Object.create(ErrorListener.prototype);\nConsoleErrorListener.prototype.constructor = ConsoleErrorListener;\n\n//\n// Provides a default instance of {@link ConsoleErrorListener}.\n//\nConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n\n//\n// {@inheritDoc}\n//\n// <p>\n// This implementation prints messages to {@link System//err} containing the\n// values of {@code line}, {@code charPositionInLine}, and {@code msg} using\n// the following format.</p>\n//\n// <pre>\n// line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>\n// </pre>\n//\nConsoleErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {\n    console.error(\"line \" + line + \":\" + column + \" \" + msg);\n};\n\nfunction ProxyErrorListener(delegates) {\n\tErrorListener.call(this);\n    if (delegates===null) {\n        throw \"delegates\";\n    }\n    this.delegates = delegates;\n\treturn this;\n}\n\nProxyErrorListener.prototype = Object.create(ErrorListener.prototype);\nProxyErrorListener.prototype.constructor = ProxyErrorListener;\n\nProxyErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {\n    this.delegates.map(function(d) { d.syntaxError(recognizer, offendingSymbol, line, column, msg, e); });\n};\n\nProxyErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    this.delegates.map(function(d) { d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs); });\n};\n\nProxyErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\tthis.delegates.map(function(d) { d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs); });\n};\n\nProxyErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\tthis.delegates.map(function(d) { d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs); });\n};\n\nexports.ErrorListener = ErrorListener;\nexports.ConsoleErrorListener = ConsoleErrorListener;\nexports.ProxyErrorListener = ProxyErrorListener;\n\n","//\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n\nvar Token = require('./../Token').Token;\nvar Errors = require('./Errors');\nvar NoViableAltException = Errors.NoViableAltException;\nvar InputMismatchException = Errors.InputMismatchException;\nvar FailedPredicateException = Errors.FailedPredicateException;\nvar ParseCancellationException = Errors.ParseCancellationException;\nvar ATNState = require('./../atn/ATNState').ATNState;\nvar Interval = require('./../IntervalSet').Interval;\nvar IntervalSet = require('./../IntervalSet').IntervalSet;\n\nfunction ErrorStrategy() {\n\n}\n\nErrorStrategy.prototype.reset = function(recognizer){\n};\n\nErrorStrategy.prototype.recoverInline = function(recognizer){\n};\n\nErrorStrategy.prototype.recover = function(recognizer, e){\n};\n\nErrorStrategy.prototype.sync = function(recognizer){\n};\n\nErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer){\n};\n\nErrorStrategy.prototype.reportError = function(recognizer){\n};\n\n\n\n// This is the default implementation of {@link ANTLRErrorStrategy} used for\n// error reporting and recovery in ANTLR parsers.\n//\nfunction DefaultErrorStrategy() {\n\tErrorStrategy.call(this);\n    // Indicates whether the error strategy is currently \"recovering from an\n    // error\". This is used to suppress reporting multiple error messages while\n    // attempting to recover from a detected syntax error.\n    //\n    // @see //inErrorRecoveryMode\n    //\n    this.errorRecoveryMode = false;\n\n    // The index into the input stream where the last error occurred.\n    // This is used to prevent infinite loops where an error is found\n    // but no token is consumed during recovery...another error is found,\n    // ad nauseum. This is a failsafe mechanism to guarantee that at least\n    // one token/tree node is consumed for two errors.\n    //\n    this.lastErrorIndex = -1;\n    this.lastErrorStates = null;\n    return this;\n}\n\nDefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);\nDefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy;\n\n// <p>The default implementation simply calls {@link //endErrorCondition} to\n// ensure that the handler is not in error recovery mode.</p>\nDefaultErrorStrategy.prototype.reset = function(recognizer) {\n    this.endErrorCondition(recognizer);\n};\n\n//\n// This method is called to enter error recovery mode when a recognition\n// exception is reported.\n//\n// @param recognizer the parser instance\n//\nDefaultErrorStrategy.prototype.beginErrorCondition = function(recognizer) {\n    this.errorRecoveryMode = true;\n};\n\nDefaultErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer) {\n    return this.errorRecoveryMode;\n};\n\n//\n// This method is called to leave error recovery mode after recovering from\n// a recognition exception.\n//\n// @param recognizer\n//\nDefaultErrorStrategy.prototype.endErrorCondition = function(recognizer) {\n    this.errorRecoveryMode = false;\n    this.lastErrorStates = null;\n    this.lastErrorIndex = -1;\n};\n\n//\n// {@inheritDoc}\n//\n// <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n//\nDefaultErrorStrategy.prototype.reportMatch = function(recognizer) {\n    this.endErrorCondition(recognizer);\n};\n\n//\n// {@inheritDoc}\n//\n// <p>The default implementation returns immediately if the handler is already\n// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n// and dispatches the reporting task based on the runtime type of {@code e}\n// according to the following table.</p>\n//\n// <ul>\n// <li>{@link NoViableAltException}: Dispatches the call to\n// {@link //reportNoViableAlternative}</li>\n// <li>{@link InputMismatchException}: Dispatches the call to\n// {@link //reportInputMismatch}</li>\n// <li>{@link FailedPredicateException}: Dispatches the call to\n// {@link //reportFailedPredicate}</li>\n// <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n// the exception</li>\n// </ul>\n//\nDefaultErrorStrategy.prototype.reportError = function(recognizer, e) {\n   // if we've already reported an error and have not matched a token\n   // yet successfully, don't report any errors.\n    if(this.inErrorRecoveryMode(recognizer)) {\n        return; // don't report spurious errors\n    }\n    this.beginErrorCondition(recognizer);\n    if ( e instanceof NoViableAltException ) {\n        this.reportNoViableAlternative(recognizer, e);\n    } else if ( e instanceof InputMismatchException ) {\n        this.reportInputMismatch(recognizer, e);\n    } else if ( e instanceof FailedPredicateException ) {\n        this.reportFailedPredicate(recognizer, e);\n    } else {\n        console.log(\"unknown recognition error type: \" + e.constructor.name);\n        console.log(e.stack);\n        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n    }\n};\n//\n// {@inheritDoc}\n//\n// <p>The default implementation resynchronizes the parser by consuming tokens\n// until we find one in the resynchronization set--loosely the set of tokens\n// that can follow the current rule.</p>\n//\nDefaultErrorStrategy.prototype.recover = function(recognizer, e) {\n    if (this.lastErrorIndex===recognizer.getInputStream().index &&\n        this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n\t\t// uh oh, another error at same token index and previously-visited\n\t\t// state in ATN; must be a case where LT(1) is in the recovery\n\t\t// token set so nothing got consumed. Consume a single token\n\t\t// at least to prevent an infinite loop; this is a failsafe.\n\t\trecognizer.consume();\n    }\n    this.lastErrorIndex = recognizer._input.index;\n    if (this.lastErrorStates === null) {\n        this.lastErrorStates = [];\n    }\n    this.lastErrorStates.push(recognizer.state);\n    var followSet = this.getErrorRecoverySet(recognizer);\n    this.consumeUntil(recognizer, followSet);\n};\n\n// The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n// that the current lookahead symbol is consistent with what were expecting\n// at this point in the ATN. You can call this anytime but ANTLR only\n// generates code to check before subrules/loops and each iteration.\n//\n// <p>Implements Jim Idle's magic sync mechanism in closures and optional\n// subrules. E.g.,</p>\n//\n// <pre>\n// a : sync ( stuff sync )* ;\n// sync : {consume to what can follow sync} ;\n// </pre>\n//\n// At the start of a sub rule upon error, {@link //sync} performs single\n// token deletion, if possible. If it can't do that, it bails on the current\n// rule and uses the default error recovery, which consumes until the\n// resynchronization set of the current rule.\n//\n// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n// with an empty alternative), then the expected set includes what follows\n// the subrule.</p>\n//\n// <p>During loop iteration, it consumes until it sees a token that can start a\n// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n// stay in the loop as long as possible.</p>\n//\n// <p><strong>ORIGINS</strong></p>\n//\n// <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n// A single mismatch token or missing token would force the parser to bail\n// out of the entire rules surrounding the loop. So, for rule</p>\n//\n// <pre>\n// classDef : 'class' ID '{' member* '}'\n// </pre>\n//\n// input with an extra token between members would force the parser to\n// consume until it found the next class definition rather than the next\n// member definition of the current class.\n//\n// <p>This functionality cost a little bit of effort because the parser has to\n// compare token set at the start of the loop and at each iteration. If for\n// some reason speed is suffering for you, you can turn off this\n// functionality by simply overriding this method as a blank { }.</p>\n//\nDefaultErrorStrategy.prototype.sync = function(recognizer) {\n    // If already recovering, don't try to sync\n    if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n    }\n    var s = recognizer._interp.atn.states[recognizer.state];\n    var la = recognizer.getTokenStream().LA(1);\n    // try cheaper subset first; might get lucky. seems to shave a wee bit off\n    var nextTokens = recognizer.atn.nextTokens(s);\n    if (nextTokens.contains(Token.EPSILON) || nextTokens.contains(la)) {\n        return;\n    }\n    switch (s.stateType) {\n    case ATNState.BLOCK_START:\n    case ATNState.STAR_BLOCK_START:\n    case ATNState.PLUS_BLOCK_START:\n    case ATNState.STAR_LOOP_ENTRY:\n       // report error and recover if possible\n        if( this.singleTokenDeletion(recognizer) !== null) {\n            return;\n        } else {\n            throw new InputMismatchException(recognizer);\n        }\n        break;\n    case ATNState.PLUS_LOOP_BACK:\n    case ATNState.STAR_LOOP_BACK:\n        this.reportUnwantedToken(recognizer);\n        var expecting = new IntervalSet();\n        expecting.addSet(recognizer.getExpectedTokens());\n        var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n        break;\n    default:\n        // do nothing if we can't identify the exact kind of ATN state\n    }\n};\n\n// This is called by {@link //reportError} when the exception is a\n// {@link NoViableAltException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\nDefaultErrorStrategy.prototype.reportNoViableAlternative = function(recognizer, e) {\n    var tokens = recognizer.getTokenStream();\n    var input;\n    if(tokens !== null) {\n        if (e.startToken.type===Token.EOF) {\n            input = \"<EOF>\";\n        } else {\n            input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n        }\n    } else {\n        input = \"<unknown input>\";\n    }\n    var msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n};\n\n//\n// This is called by {@link //reportError} when the exception is an\n// {@link InputMismatchException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\nDefaultErrorStrategy.prototype.reportInputMismatch = function(recognizer, e) {\n    var msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n          \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n};\n\n//\n// This is called by {@link //reportError} when the exception is a\n// {@link FailedPredicateException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\nDefaultErrorStrategy.prototype.reportFailedPredicate = function(recognizer, e) {\n    var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];\n    var msg = \"rule \" + ruleName + \" \" + e.message;\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n};\n\n// This method is called to report a syntax error which requires the removal\n// of a token from the input stream. At the time this method is called, the\n// erroneous symbol is current {@code LT(1)} symbol and has not yet been\n// removed from the input stream. When this method returns,\n// {@code recognizer} is in error recovery mode.\n//\n// <p>This method is called when {@link //singleTokenDeletion} identifies\n// single-token deletion as a viable recovery strategy for a mismatched\n// input error.</p>\n//\n// <p>The default implementation simply returns if the handler is already in\n// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n// enter error recovery mode, followed by calling\n// {@link Parser//notifyErrorListeners}.</p>\n//\n// @param recognizer the parser instance\n//\nDefaultErrorStrategy.prototype.reportUnwantedToken = function(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n    }\n    this.beginErrorCondition(recognizer);\n    var t = recognizer.getCurrentToken();\n    var tokenName = this.getTokenErrorDisplay(t);\n    var expecting = this.getExpectedTokens(recognizer);\n    var msg = \"extraneous input \" + tokenName + \" expecting \" +\n        expecting.toString(recognizer.literalNames, recognizer.symbolicNames);\n    recognizer.notifyErrorListeners(msg, t, null);\n};\n// This method is called to report a syntax error which requires the\n// insertion of a missing token into the input stream. At the time this\n// method is called, the missing token has not yet been inserted. When this\n// method returns, {@code recognizer} is in error recovery mode.\n//\n// <p>This method is called when {@link //singleTokenInsertion} identifies\n// single-token insertion as a viable recovery strategy for a mismatched\n// input error.</p>\n//\n// <p>The default implementation simply returns if the handler is already in\n// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n// enter error recovery mode, followed by calling\n// {@link Parser//notifyErrorListeners}.</p>\n//\n// @param recognizer the parser instance\n//\nDefaultErrorStrategy.prototype.reportMissingToken = function(recognizer) {\n    if ( this.inErrorRecoveryMode(recognizer)) {\n        return;\n    }\n    this.beginErrorCondition(recognizer);\n    var t = recognizer.getCurrentToken();\n    var expecting = this.getExpectedTokens(recognizer);\n    var msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n          \" at \" + this.getTokenErrorDisplay(t);\n    recognizer.notifyErrorListeners(msg, t, null);\n};\n\n// <p>The default implementation attempts to recover from the mismatched input\n// by using single token insertion and deletion as described below. If the\n// recovery attempt fails, this method throws an\n// {@link InputMismatchException}.</p>\n//\n// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n//\n// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n// right token, however, then assume {@code LA(1)} is some extra spurious\n// token and delete it. Then consume and return the next token (which was\n// the {@code LA(2)} token) as the successful result of the match operation.</p>\n//\n// <p>This recovery strategy is implemented by {@link\n// //singleTokenDeletion}.</p>\n//\n// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n//\n// <p>If current token (at {@code LA(1)}) is consistent with what could come\n// after the expected {@code LA(1)} token, then assume the token is missing\n// and use the parser's {@link TokenFactory} to create it on the fly. The\n// \"insertion\" is performed by returning the created token as the successful\n// result of the match operation.</p>\n//\n// <p>This recovery strategy is implemented by {@link\n// //singleTokenInsertion}.</p>\n//\n// <p><strong>EXAMPLE</strong></p>\n//\n// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n// the parser returns from the nested call to {@code expr}, it will have\n// call chain:</p>\n//\n// <pre>\n// stat &rarr; expr &rarr; atom\n// </pre>\n//\n// and it will be trying to match the {@code ')'} at this point in the\n// derivation:\n//\n// <pre>\n// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n// ^\n// </pre>\n//\n// The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n// is in the set of tokens that can follow the {@code ')'} token reference\n// in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n//\nDefaultErrorStrategy.prototype.recoverInline = function(recognizer) {\n    // SINGLE TOKEN DELETION\n    var matchedSymbol = this.singleTokenDeletion(recognizer);\n    if (matchedSymbol !== null) {\n        // we have deleted the extra token.\n        // now, move past ttype token as if all were ok\n        recognizer.consume();\n        return matchedSymbol;\n    }\n    // SINGLE TOKEN INSERTION\n    if (this.singleTokenInsertion(recognizer)) {\n        return this.getMissingSymbol(recognizer);\n    }\n    // even that didn't work; must throw the exception\n    throw new InputMismatchException(recognizer);\n};\n\n//\n// This method implements the single-token insertion inline error recovery\n// strategy. It is called by {@link //recoverInline} if the single-token\n// deletion strategy fails to recover from the mismatched input. If this\n// method returns {@code true}, {@code recognizer} will be in error recovery\n// mode.\n//\n// <p>This method determines whether or not single-token insertion is viable by\n// checking if the {@code LA(1)} input symbol could be successfully matched\n// if it were instead the {@code LA(2)} symbol. If this method returns\n// {@code true}, the caller is responsible for creating and inserting a\n// token with the correct type to produce this behavior.</p>\n//\n// @param recognizer the parser instance\n// @return {@code true} if single-token insertion is a viable recovery\n// strategy for the current mismatched input, otherwise {@code false}\n//\nDefaultErrorStrategy.prototype.singleTokenInsertion = function(recognizer) {\n    var currentSymbolType = recognizer.getTokenStream().LA(1);\n    // if current token is consistent with what could come after current\n    // ATN state, then we know we're missing a token; error recovery\n    // is free to conjure up and insert the missing token\n    var atn = recognizer._interp.atn;\n    var currentState = atn.states[recognizer.state];\n    var next = currentState.transitions[0].target;\n    var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);\n    if (expectingAtLL2.contains(currentSymbolType) ){\n        this.reportMissingToken(recognizer);\n        return true;\n    } else {\n        return false;\n    }\n};\n\n// This method implements the single-token deletion inline error recovery\n// strategy. It is called by {@link //recoverInline} to attempt to recover\n// from mismatched input. If this method returns null, the parser and error\n// handler state will not have changed. If this method returns non-null,\n// {@code recognizer} will <em>not</em> be in error recovery mode since the\n// returned token was a successful match.\n//\n// <p>If the single-token deletion is successful, this method calls\n// {@link //reportUnwantedToken} to report the error, followed by\n// {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n// before returning {@link //reportMatch} is called to signal a successful\n// match.</p>\n//\n// @param recognizer the parser instance\n// @return the successfully matched {@link Token} instance if single-token\n// deletion successfully recovers from the mismatched input, otherwise\n// {@code null}\n//\nDefaultErrorStrategy.prototype.singleTokenDeletion = function(recognizer) {\n    var nextTokenType = recognizer.getTokenStream().LA(2);\n    var expecting = this.getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        this.reportUnwantedToken(recognizer);\n        // print(\"recoverFromMismatchedToken deleting \" \\\n        // + str(recognizer.getTokenStream().LT(1)) \\\n        // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n        // + \" is what we want\", file=sys.stderr)\n        recognizer.consume(); // simply delete extra token\n        // we want to return the token we're actually matching\n        var matchedSymbol = recognizer.getCurrentToken();\n        this.reportMatch(recognizer); // we know current token is correct\n        return matchedSymbol;\n    } else {\n        return null;\n    }\n};\n\n// Conjure up a missing token during error recovery.\n//\n// The recognizer attempts to recover from single missing\n// symbols. But, actions might refer to that missing symbol.\n// For example, x=ID {f($x);}. The action clearly assumes\n// that there has been an identifier matched previously and that\n// $x points at that token. If that token is missing, but\n// the next token in the stream is what we want we assume that\n// this token is missing and we keep going. Because we\n// have to return some token to replace the missing token,\n// we have to conjure one up. This method gives the user control\n// over the tokens returned for missing tokens. Mostly,\n// you will want to create something special for identifier\n// tokens. For literals such as '{' and ',', the default\n// action in the parser or tree parser works. It simply creates\n// a CommonToken of the appropriate type. The text will be the token.\n// If you change what tokens must be created by the lexer,\n// override this method to create the appropriate tokens.\n//\nDefaultErrorStrategy.prototype.getMissingSymbol = function(recognizer) {\n    var currentSymbol = recognizer.getCurrentToken();\n    var expecting = this.getExpectedTokens(recognizer);\n    var expectedTokenType = expecting.first(); // get any element\n    var tokenText;\n    if (expectedTokenType===Token.EOF) {\n        tokenText = \"<missing EOF>\";\n    } else {\n        tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n    }\n    var current = currentSymbol;\n    var lookback = recognizer.getTokenStream().LT(-1);\n    if (current.type===Token.EOF && lookback !== null) {\n        current = lookback;\n    }\n    return recognizer.getTokenFactory().create(current.source,\n        expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n        -1, -1, current.line, current.column);\n};\n\nDefaultErrorStrategy.prototype.getExpectedTokens = function(recognizer) {\n    return recognizer.getExpectedTokens();\n};\n\n// How should a token be displayed in an error message? The default\n// is to display just the text, but during development you might\n// want to have a lot of information spit out. Override in that case\n// to use t.toString() (which, for CommonToken, dumps everything about\n// the token). This is better than forcing you to override a method in\n// your token objects because you don't have to go modify your lexer\n// so that it creates a new Java type.\n//\nDefaultErrorStrategy.prototype.getTokenErrorDisplay = function(t) {\n    if (t === null) {\n        return \"<no token>\";\n    }\n    var s = t.text;\n    if (s === null) {\n        if (t.type===Token.EOF) {\n            s = \"<EOF>\";\n        } else {\n            s = \"<\" + t.type + \">\";\n        }\n    }\n    return this.escapeWSAndQuote(s);\n};\n\nDefaultErrorStrategy.prototype.escapeWSAndQuote = function(s) {\n    s = s.replace(/\\n/g,\"\\\\n\");\n    s = s.replace(/\\r/g,\"\\\\r\");\n    s = s.replace(/\\t/g,\"\\\\t\");\n    return \"'\" + s + \"'\";\n};\n\n// Compute the error recovery set for the current rule. During\n// rule invocation, the parser pushes the set of tokens that can\n// follow that rule reference on the stack; this amounts to\n// computing FIRST of what follows the rule reference in the\n// enclosing rule. See LinearApproximator.FIRST().\n// This local follow set only includes tokens\n// from within the rule; i.e., the FIRST computation done by\n// ANTLR stops at the end of a rule.\n//\n// EXAMPLE\n//\n// When you find a \"no viable alt exception\", the input is not\n// consistent with any of the alternatives for rule r. The best\n// thing to do is to consume tokens until you see something that\n// can legally follow a call to r//or* any rule that called r.\n// You don't want the exact set of viable next tokens because the\n// input might just be missing a token--you might consume the\n// rest of the input looking for one of the missing tokens.\n//\n// Consider grammar:\n//\n// a : '[' b ']'\n// | '(' b ')'\n// ;\n// b : c '^' INT ;\n// c : ID\n// | INT\n// ;\n//\n// At each rule invocation, the set of tokens that could follow\n// that rule is pushed on a stack. Here are the various\n// context-sensitive follow sets:\n//\n// FOLLOW(b1_in_a) = FIRST(']') = ']'\n// FOLLOW(b2_in_a) = FIRST(')') = ')'\n// FOLLOW(c_in_b) = FIRST('^') = '^'\n//\n// Upon erroneous input \"[]\", the call chain is\n//\n// a -> b -> c\n//\n// and, hence, the follow context stack is:\n//\n// depth follow set start of rule execution\n// 0 <EOF> a (from main())\n// 1 ']' b\n// 2 '^' c\n//\n// Notice that ')' is not included, because b would have to have\n// been called from a different context in rule a for ')' to be\n// included.\n//\n// For error recovery, we cannot consider FOLLOW(c)\n// (context-sensitive or otherwise). We need the combined set of\n// all context-sensitive FOLLOW sets--the set of all tokens that\n// could follow any reference in the call chain. We need to\n// resync to one of those tokens. Note that FOLLOW(c)='^' and if\n// we resync'd to that token, we'd consume until EOF. We need to\n// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n// In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n// not consume anything. After printing an error, rule c would\n// return normally. Rule b would not find the required '^' though.\n// At this point, it gets a mismatched token error and throws an\n// exception (since LA(1) is not in the viable following token\n// set). The rule exception handler tries to recover, but finds\n// the same recovery set and doesn't consume anything. Rule b\n// exits normally returning to rule a. Now it finds the ']' (and\n// with the successful match exits errorRecovery mode).\n//\n// So, you can see that the parser walks up the call chain looking\n// for the token that was a member of the recovery set.\n//\n// Errors are not generated in errorRecovery mode.\n//\n// ANTLR's error recovery mechanism is based upon original ideas:\n//\n// \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n//\n// and\n//\n// \"A note on error recovery in recursive descent parsers\":\n// http://portal.acm.org/citation.cfm?id=947902.947905\n//\n// Later, Josef Grosch had some good ideas:\n//\n// \"Efficient and Comfortable Error Recovery in Recursive Descent\n// Parsers\":\n// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n//\n// Like Grosch I implement context-sensitive FOLLOW sets that are combined\n// at run-time upon error to avoid overhead during parsing.\n//\nDefaultErrorStrategy.prototype.getErrorRecoverySet = function(recognizer) {\n    var atn = recognizer._interp.atn;\n    var ctx = recognizer._ctx;\n    var recoverSet = new IntervalSet();\n    while (ctx !== null && ctx.invokingState>=0) {\n        // compute what follows who invoked us\n        var invokingState = atn.states[ctx.invokingState];\n        var rt = invokingState.transitions[0];\n        var follow = atn.nextTokens(rt.followState);\n        recoverSet.addSet(follow);\n        ctx = ctx.parentCtx;\n    }\n    recoverSet.removeOne(Token.EPSILON);\n    return recoverSet;\n};\n\n// Consume tokens until one matches the given token set.//\nDefaultErrorStrategy.prototype.consumeUntil = function(recognizer, set) {\n    var ttype = recognizer.getTokenStream().LA(1);\n    while( ttype !== Token.EOF && !set.contains(ttype)) {\n        recognizer.consume();\n        ttype = recognizer.getTokenStream().LA(1);\n    }\n};\n\n//\n// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n// by immediately canceling the parse operation with a\n// {@link ParseCancellationException}. The implementation ensures that the\n// {@link ParserRuleContext//exception} field is set for all parse tree nodes\n// that were not completed prior to encountering the error.\n//\n// <p>\n// This error strategy is useful in the following scenarios.</p>\n//\n// <ul>\n// <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n// stage of two-stage parsing to immediately terminate if an error is\n// encountered, and immediately fall back to the second stage. In addition to\n// avoiding wasted work by attempting to recover from errors here, the empty\n// implementation of {@link BailErrorStrategy//sync} improves the performance of\n// the first stage.</li>\n// <li><strong>Silent validation:</strong> When syntax errors are not being\n// reported or logged, and the parse result is simply ignored if errors occur,\n// the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n// when the result will be ignored either way.</li>\n// </ul>\n//\n// <p>\n// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n//\n// @see Parser//setErrorHandler(ANTLRErrorStrategy)\n//\nfunction BailErrorStrategy() {\n\tDefaultErrorStrategy.call(this);\n\treturn this;\n}\n\nBailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);\nBailErrorStrategy.prototype.constructor = BailErrorStrategy;\n\n// Instead of recovering from exception {@code e}, re-throw it wrapped\n// in a {@link ParseCancellationException} so it is not caught by the\n// rule function catches. Use {@link Exception//getCause()} to get the\n// original {@link RecognitionException}.\n//\nBailErrorStrategy.prototype.recover = function(recognizer, e) {\n    var context = recognizer._ctx;\n    while (context !== null) {\n        context.exception = e;\n        context = context.parentCtx;\n    }\n    throw new ParseCancellationException(e);\n};\n\n// Make sure we don't attempt to recover inline; if the parser\n// successfully recovers, it won't throw an exception.\n//\nBailErrorStrategy.prototype.recoverInline = function(recognizer) {\n    this.recover(recognizer, new InputMismatchException(recognizer));\n};\n\n// Make sure we don't attempt to recover from problems in subrules.//\nBailErrorStrategy.prototype.sync = function(recognizer) {\n    // pass\n};\n\nexports.BailErrorStrategy = BailErrorStrategy;\nexports.DefaultErrorStrategy = DefaultErrorStrategy;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n//  3 kinds of errors: prediction errors, failed predicate errors, and\n//  mismatched input errors. In each case, the parser knows where it is\n//  in the input, where it is in the ATN, the rule invocation stack,\n//  and what kind of problem occurred.\n\nvar PredicateTransition = require('./../atn/Transition').PredicateTransition;\n\nfunction RecognitionException(params) {\n\tError.call(this);\n\tif (!!Error.captureStackTrace) {\n        Error.captureStackTrace(this, RecognitionException);\n\t} else {\n\t\tvar stack = new Error().stack;\n\t}\n\tthis.message = params.message;\n    this.recognizer = params.recognizer;\n    this.input = params.input;\n    this.ctx = params.ctx;\n    // The current {@link Token} when an error occurred. Since not all streams\n    // support accessing symbols by index, we have to track the {@link Token}\n    // instance itself.\n    this.offendingToken = null;\n    // Get the ATN state number the parser was in at the time the error\n    // occurred. For {@link NoViableAltException} and\n    // {@link LexerNoViableAltException} exceptions, this is the\n    // {@link DecisionState} number. For others, it is the state whose outgoing\n    // edge we couldn't match.\n    this.offendingState = -1;\n    if (this.recognizer!==null) {\n        this.offendingState = this.recognizer.state;\n    }\n    return this;\n}\n\nRecognitionException.prototype = Object.create(Error.prototype);\nRecognitionException.prototype.constructor = RecognitionException;\n\n// <p>If the state number is not known, this method returns -1.</p>\n\n//\n// Gets the set of input symbols which could potentially follow the\n// previously matched symbol at the time this exception was thrown.\n//\n// <p>If the set of expected tokens is not known and could not be computed,\n// this method returns {@code null}.</p>\n//\n// @return The set of token types that could potentially follow the current\n// state in the ATN, or {@code null} if the information is not available.\n// /\nRecognitionException.prototype.getExpectedTokens = function() {\n    if (this.recognizer!==null) {\n        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n    } else {\n        return null;\n    }\n};\n\nRecognitionException.prototype.toString = function() {\n    return this.message;\n};\n\nfunction LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {\n\tRecognitionException.call(this, {message:\"\", recognizer:lexer, input:input, ctx:null});\n    this.startIndex = startIndex;\n    this.deadEndConfigs = deadEndConfigs;\n    return this;\n}\n\nLexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);\nLexerNoViableAltException.prototype.constructor = LexerNoViableAltException;\n\nLexerNoViableAltException.prototype.toString = function() {\n    var symbol = \"\";\n    if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n        symbol = this.input.getText((this.startIndex,this.startIndex));\n    }\n    return \"LexerNoViableAltException\" + symbol;\n};\n\n// Indicates that the parser could not decide which of two or more paths\n// to take based upon the remaining input. It tracks the starting token\n// of the offending input and also knows where the parser was\n// in the various paths when the error. Reported by reportNoViableAlternative()\n//\nfunction NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n\tctx = ctx || recognizer._ctx;\n\toffendingToken = offendingToken || recognizer.getCurrentToken();\n\tstartToken = startToken || recognizer.getCurrentToken();\n\tinput = input || recognizer.getInputStream();\n\tRecognitionException.call(this, {message:\"\", recognizer:recognizer, input:input, ctx:ctx});\n    // Which configurations did we try at input.index() that couldn't match\n\t// input.LT(1)?//\n    this.deadEndConfigs = deadEndConfigs;\n    // The token object at the start index; the input stream might\n    // not be buffering tokens so get a reference to it. (At the\n    // time the error occurred, of course the stream needs to keep a\n    // buffer all of the tokens but later we might not have access to those.)\n    this.startToken = startToken;\n    this.offendingToken = offendingToken;\n}\n\nNoViableAltException.prototype = Object.create(RecognitionException.prototype);\nNoViableAltException.prototype.constructor = NoViableAltException;\n\n// This signifies any kind of mismatched input exceptions such as\n// when the current input does not match the expected token.\n//\nfunction InputMismatchException(recognizer) {\n\tRecognitionException.call(this, {message:\"\", recognizer:recognizer, input:recognizer.getInputStream(), ctx:recognizer._ctx});\n    this.offendingToken = recognizer.getCurrentToken();\n}\n\nInputMismatchException.prototype = Object.create(RecognitionException.prototype);\nInputMismatchException.prototype.constructor = InputMismatchException;\n\n// A semantic predicate failed during validation. Validation of predicates\n// occurs when normally parsing the alternative just like matching a token.\n// Disambiguating predicate evaluation occurs when we test a predicate during\n// prediction.\n\nfunction FailedPredicateException(recognizer, predicate, message) {\n\tRecognitionException.call(this, {message:this.formatMessage(predicate,message || null), recognizer:recognizer,\n                         input:recognizer.getInputStream(), ctx:recognizer._ctx});\n    var s = recognizer._interp.atn.states[recognizer.state];\n    var trans = s.transitions[0];\n    if (trans instanceof PredicateTransition) {\n        this.ruleIndex = trans.ruleIndex;\n        this.predicateIndex = trans.predIndex;\n    } else {\n        this.ruleIndex = 0;\n        this.predicateIndex = 0;\n    }\n    this.predicate = predicate;\n    this.offendingToken = recognizer.getCurrentToken();\n    return this;\n}\n\nFailedPredicateException.prototype = Object.create(RecognitionException.prototype);\nFailedPredicateException.prototype.constructor = FailedPredicateException;\n\nFailedPredicateException.prototype.formatMessage = function(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n};\n\nfunction ParseCancellationException() {\n\tError.call(this);\n\tError.captureStackTrace(this, ParseCancellationException);\n\treturn this;\n}\n\nParseCancellationException.prototype = Object.create(Error.prototype);\nParseCancellationException.prototype.constructor = ParseCancellationException;\n\nexports.RecognitionException = RecognitionException;\nexports.NoViableAltException = NoViableAltException;\nexports.LexerNoViableAltException = LexerNoViableAltException;\nexports.InputMismatchException = InputMismatchException;\nexports.FailedPredicateException = FailedPredicateException;\nexports.ParseCancellationException = ParseCancellationException;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.RecognitionException = require('./Errors').RecognitionException;\nexports.NoViableAltException = require('./Errors').NoViableAltException;\nexports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;\nexports.InputMismatchException = require('./Errors').InputMismatchException;\nexports.FailedPredicateException = require('./Errors').FailedPredicateException;\nexports.DiagnosticErrorListener = require('./DiagnosticErrorListener').DiagnosticErrorListener;\nexports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;\nexports.ErrorListener = require('./ErrorListener').ErrorListener;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = require('./atn/index');\nexports.codepointat = require('./polyfills/codepointat');\nexports.dfa = require('./dfa/index');\nexports.fromcodepoint = require('./polyfills/fromcodepoint');\nexports.tree = require('./tree/index');\nexports.error = require('./error/index');\nexports.Token = require('./Token').Token;\nexports.CharStreams = require('./CharStreams').CharStreams;\nexports.CommonToken = require('./Token').CommonToken;\nexports.InputStream = require('./InputStream').InputStream;\nexports.FileStream = require('./FileStream').FileStream;\nexports.CommonTokenStream = require('./CommonTokenStream').CommonTokenStream;\nexports.Lexer = require('./Lexer').Lexer;\nexports.Parser = require('./Parser').Parser;\nvar pc = require('./PredictionContext');\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = require('./ParserRuleContext').ParserRuleContext;\nexports.Interval = require('./IntervalSet').Interval;\nexports.Utils = require('./Utils');\n","/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n\n// The basic notion of a tree has a parent, a payload, and a list of children.\n//  It is the most abstract interface for all the trees used by ANTLR.\n///\n\nvar Token = require('./../Token').Token;\nvar Interval = require('./../IntervalSet').Interval;\nvar INVALID_INTERVAL = new Interval(-1, -2);\nvar Utils = require('../Utils.js');\n\n\nfunction Tree() {\n\treturn this;\n}\n\nfunction SyntaxTree() {\n\tTree.call(this);\n\treturn this;\n}\n\nSyntaxTree.prototype = Object.create(Tree.prototype);\nSyntaxTree.prototype.constructor = SyntaxTree;\n\nfunction ParseTree() {\n\tSyntaxTree.call(this);\n\treturn this;\n}\n\nParseTree.prototype = Object.create(SyntaxTree.prototype);\nParseTree.prototype.constructor = ParseTree;\n\nfunction RuleNode() {\n\tParseTree.call(this);\n\treturn this;\n}\n\nRuleNode.prototype = Object.create(ParseTree.prototype);\nRuleNode.prototype.constructor = RuleNode;\n\nfunction TerminalNode() {\n\tParseTree.call(this);\n\treturn this;\n}\n\nTerminalNode.prototype = Object.create(ParseTree.prototype);\nTerminalNode.prototype.constructor = TerminalNode;\n\nfunction ErrorNode() {\n\tTerminalNode.call(this);\n\treturn this;\n}\n\nErrorNode.prototype = Object.create(TerminalNode.prototype);\nErrorNode.prototype.constructor = ErrorNode;\n\nfunction ParseTreeVisitor() {\n\treturn this;\n}\n\nParseTreeVisitor.prototype.visit = function(ctx) {\n \tif (Array.isArray(ctx)) {\n\t\treturn ctx.map(function(child) {\n            return child.accept(this);\n        }, this);\n\t} else {\n\t\treturn ctx.accept(this);\n\t}\n};\n\nParseTreeVisitor.prototype.visitChildren = function(ctx) {\n\tif (ctx.children) {\n\t\treturn this.visit(ctx.children);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nParseTreeVisitor.prototype.visitTerminal = function(node) {\n};\n\nParseTreeVisitor.prototype.visitErrorNode = function(node) {\n};\n\n\nfunction ParseTreeListener() {\n\treturn this;\n}\n\nParseTreeListener.prototype.visitTerminal = function(node) {\n};\n\nParseTreeListener.prototype.visitErrorNode = function(node) {\n};\n\nParseTreeListener.prototype.enterEveryRule = function(node) {\n};\n\nParseTreeListener.prototype.exitEveryRule = function(node) {\n};\n\nfunction TerminalNodeImpl(symbol) {\n\tTerminalNode.call(this);\n\tthis.parentCtx = null;\n\tthis.symbol = symbol;\n\treturn this;\n}\n\nTerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);\nTerminalNodeImpl.prototype.constructor = TerminalNodeImpl;\n\nTerminalNodeImpl.prototype.getChild = function(i) {\n\treturn null;\n};\n\nTerminalNodeImpl.prototype.getSymbol = function() {\n\treturn this.symbol;\n};\n\nTerminalNodeImpl.prototype.getParent = function() {\n\treturn this.parentCtx;\n};\n\nTerminalNodeImpl.prototype.getPayload = function() {\n\treturn this.symbol;\n};\n\nTerminalNodeImpl.prototype.getSourceInterval = function() {\n\tif (this.symbol === null) {\n\t\treturn INVALID_INTERVAL;\n\t}\n\tvar tokenIndex = this.symbol.tokenIndex;\n\treturn new Interval(tokenIndex, tokenIndex);\n};\n\nTerminalNodeImpl.prototype.getChildCount = function() {\n\treturn 0;\n};\n\nTerminalNodeImpl.prototype.accept = function(visitor) {\n\treturn visitor.visitTerminal(this);\n};\n\nTerminalNodeImpl.prototype.getText = function() {\n\treturn this.symbol.text;\n};\n\nTerminalNodeImpl.prototype.toString = function() {\n\tif (this.symbol.type === Token.EOF) {\n\t\treturn \"<EOF>\";\n\t} else {\n\t\treturn this.symbol.text;\n\t}\n};\n\n// Represents a token that was consumed during resynchronization\n// rather than during a valid match operation. For example,\n// we will create this kind of a node during single token insertion\n// and deletion as well as during \"consume until error recovery set\"\n// upon no viable alternative exceptions.\n\nfunction ErrorNodeImpl(token) {\n\tTerminalNodeImpl.call(this, token);\n\treturn this;\n}\n\nErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);\nErrorNodeImpl.prototype.constructor = ErrorNodeImpl;\n\nErrorNodeImpl.prototype.isErrorNode = function() {\n\treturn true;\n};\n\nErrorNodeImpl.prototype.accept = function(visitor) {\n\treturn visitor.visitErrorNode(this);\n};\n\nfunction ParseTreeWalker() {\n\treturn this;\n}\n\nParseTreeWalker.prototype.walk = function(listener, t) {\n\tvar errorNode = t instanceof ErrorNode ||\n\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\tif (errorNode) {\n\t\tlistener.visitErrorNode(t);\n\t} else if (t instanceof TerminalNode) {\n\t\tlistener.visitTerminal(t);\n\t} else {\n\t\tthis.enterRule(listener, t);\n\t\tfor (var i = 0; i < t.getChildCount(); i++) {\n\t\t\tvar child = t.getChild(i);\n\t\t\tthis.walk(listener, child);\n\t\t}\n\t\tthis.exitRule(listener, t);\n\t}\n};\n//\n// The discovery of a rule node, involves sending two events: the generic\n// {@link ParseTreeListener//enterEveryRule} and a\n// {@link RuleContext}-specific event. First we trigger the generic and then\n// the rule specific. We to them in reverse order upon finishing the node.\n//\nParseTreeWalker.prototype.enterRule = function(listener, r) {\n\tvar ctx = r.getRuleContext();\n\tlistener.enterEveryRule(ctx);\n\tctx.enterRule(listener);\n};\n\nParseTreeWalker.prototype.exitRule = function(listener, r) {\n\tvar ctx = r.getRuleContext();\n\tctx.exitRule(listener);\n\tlistener.exitEveryRule(ctx);\n};\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nexports.RuleNode = RuleNode;\nexports.ErrorNode = ErrorNode;\nexports.TerminalNode = TerminalNode;\nexports.ErrorNodeImpl = ErrorNodeImpl;\nexports.TerminalNodeImpl = TerminalNodeImpl;\nexports.ParseTreeListener = ParseTreeListener;\nexports.ParseTreeVisitor = ParseTreeVisitor;\nexports.ParseTreeWalker = ParseTreeWalker;\nexports.INVALID_INTERVAL = INVALID_INTERVAL;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar Utils = require('./../Utils');\nvar Token = require('./../Token').Token;\nvar RuleNode = require('./Tree').RuleNode;\nvar ErrorNode = require('./Tree').ErrorNode;\nvar TerminalNode = require('./Tree').TerminalNode;\nvar ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;\nvar RuleContext = require('./../RuleContext').RuleContext;\nvar INVALID_ALT_NUMBER = require('./../atn/ATN').INVALID_ALT_NUMBER;\n\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nfunction Trees() {\n}\n\n// Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n//  node payloads to get the text for the nodes.  Detect\n//  parse trees and extract data appropriately.\nTrees.toStringTree = function(tree, ruleNames, recog) {\n\truleNames = ruleNames || null;\n\trecog = recog || null;\n    if(recog!==null) {\n       ruleNames = recog.ruleNames;\n    }\n    var s = Trees.getNodeText(tree, ruleNames);\n    s = Utils.escapeWhitespace(s, false);\n    var c = tree.getChildCount();\n    if(c===0) {\n        return s;\n    }\n    var res = \"(\" + s + ' ';\n    if(c>0) {\n        s = Trees.toStringTree(tree.getChild(0), ruleNames);\n        res = res.concat(s);\n    }\n    for(var i=1;i<c;i++) {\n        s = Trees.toStringTree(tree.getChild(i), ruleNames);\n        res = res.concat(' ' + s);\n    }\n    res = res.concat(\")\");\n    return res;\n};\n\nTrees.getNodeText = function(t, ruleNames, recog) {\n\truleNames = ruleNames || null;\n\trecog = recog || null;\n    if(recog!==null) {\n        ruleNames = recog.ruleNames;\n    }\n    if(ruleNames!==null) {\n       if (t instanceof RuleContext) {\n           var altNumber = t.getAltNumber();\n           if ( altNumber!=INVALID_ALT_NUMBER ) {\n               return ruleNames[t.ruleIndex]+\":\"+altNumber;\n           }\n           return ruleNames[t.ruleIndex];\n       } else if ( t instanceof ErrorNode) {\n           return t.toString();\n       } else if(t instanceof TerminalNode) {\n           if(t.symbol!==null) {\n               return t.symbol.text;\n           }\n       }\n    }\n    // no recog for rule names\n    var payload = t.getPayload();\n    if (payload instanceof Token ) {\n       return payload.text;\n    }\n    return t.getPayload().toString();\n};\n\n\n// Return ordered list of all children of this node\nTrees.getChildren = function(t) {\n\tvar list = [];\n\tfor(var i=0;i<t.getChildCount();i++) {\n\t\tlist.push(t.getChild(i));\n\t}\n\treturn list;\n};\n\n// Return a list of all ancestors of this node.  The first node of\n//  list is the root and the last is the parent of this node.\n//\nTrees.getAncestors = function(t) {\n    var ancestors = [];\n    t = t.getParent();\n    while(t!==null) {\n        ancestors = [t].concat(ancestors);\n        t = t.getParent();\n    }\n    return ancestors;\n};\n\nTrees.findAllTokenNodes = function(t, ttype) {\n    return Trees.findAllNodes(t, ttype, true);\n};\n\nTrees.findAllRuleNodes = function(t, ruleIndex) {\n\treturn Trees.findAllNodes(t, ruleIndex, false);\n};\n\nTrees.findAllNodes = function(t, index, findTokens) {\n\tvar nodes = [];\n\tTrees._findAllNodes(t, index, findTokens, nodes);\n\treturn nodes;\n};\n\nTrees._findAllNodes = function(t, index, findTokens, nodes) {\n\t// check this node (the root) first\n\tif(findTokens && (t instanceof TerminalNode)) {\n\t\tif(t.symbol.type===index) {\n\t\t\tnodes.push(t);\n\t\t}\n\t} else if(!findTokens && (t instanceof ParserRuleContext)) {\n\t\tif(t.ruleIndex===index) {\n\t\t\tnodes.push(t);\n\t\t}\n\t}\n\t// check children\n\tfor(var i=0;i<t.getChildCount();i++) {\n\t\tTrees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n\t}\n};\n\nTrees.descendants = function(t) {\n\tvar nodes = [t];\n    for(var i=0;i<t.getChildCount();i++) {\n        nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n    }\n    return nodes;\n};\n\n\nexports.Trees = Trees;","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nvar Tree = require('./Tree');\nexports.Trees = require('./Trees').Trees;\nexports.RuleNode = Tree.RuleNode;\nexports.ParseTreeListener = Tree.ParseTreeListener;\nexports.ParseTreeVisitor = Tree.ParseTreeVisitor;\nexports.ParseTreeWalker = Tree.ParseTreeWalker;\n","// Generated from Lsc.g4 by ANTLR 4.7.2\r\n// jshint ignore: start\r\nvar antlr4 = require('antlr4/index');\r\n\r\n\r\n\r\nvar serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\",\r\n    \"\\u00022\\u020e\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\",\r\n    \"\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\",\r\n    \"\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\",\r\n    \"\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\",\r\n    \"\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\",\r\n    \"\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\",\r\n    \"\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\",\r\n    \"\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\",\r\n    \"\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\",\r\n    \"\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004\",\r\n    \"*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u0004\",\r\n    \"1\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u0003\\u0002\\u0005\\u0002\",\r\n    \"m\\n\\u0002\\u0003\\u0002\\u0003\\u0002\\u0007\\u0002q\\n\\u0002\\f\\u0002\\u000e\",\r\n    \"\\u0002t\\u000b\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\",\r\n    \"\\u0005\\u0003z\\n\\u0003\\u0003\\u0004\\u0005\\u0004}\\n\\u0004\\u0003\\u0004\\u0003\",\r\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\u0083\\n\\u0004\\u0003\\u0005\",\r\n    \"\\u0005\\u0005\\u0086\\n\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005\\u008a\",\r\n    \"\\n\\u0005\\u0003\\u0006\\u0005\\u0006\\u008d\\n\\u0006\\u0003\\u0006\\u0003\\u0006\",\r\n    \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006\\u0093\\n\\u0006\\u0003\\u0007\\u0003\",\r\n    \"\\u0007\\u0003\\b\\u0005\\b\\u0098\\n\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0005\\b\\u009d\",\r\n    \"\\n\\b\\u0003\\b\\u0005\\b\\u00a0\\n\\b\\u0003\\t\\u0006\\t\\u00a3\\n\\t\\r\\t\\u000e\\t\",\r\n    \"\\u00a4\\u0003\\n\\u0003\\n\\u0003\\u000b\\u0003\\u000b\\u0003\\f\\u0003\\f\\u0003\",\r\n    \"\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\",\r\n    \"\\u0003\\u0010\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0013\",\r\n    \"\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\\u0003\\u0016\",\r\n    \"\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\r\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\\u0003\\u001b\",\r\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\",\r\n    \"\\u0003\\u001b\\u0003\\u001b\\u0005\\u001b\\u00d4\\n\\u001b\\u0003\\u001c\\u0003\",\r\n    \"\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\",\r\n    \"\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\",\r\n    \"\\u001c\\u0005\\u001c\\u00e4\\n\\u001c\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\",\r\n    \"\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\",\r\n    \"\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\",\r\n    \"\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0005\\u001d\",\r\n    \"\\u00fa\\n\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\",\r\n    \"\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\",\r\n    \"\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\",\r\n    \"\\u001e\\u0003\\u001e\\u0005\\u001e\\u010e\\n\\u001e\\u0003\\u001f\\u0003\\u001f\",\r\n    \"\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\",\r\n    \"\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\",\r\n    \"\\u0003\\u001f\\u0003\\u001f\\u0005\\u001f\\u0120\\n\\u001f\\u0003 \\u0003 \\u0003\",\r\n    \" \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003\",\r\n    \" \\u0003 \\u0005 \\u0130\\n \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\",\r\n    \"!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\",\r\n    \"!\\u0003!\\u0003!\\u0003!\\u0005!\\u0146\\n!\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\r\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0005\",\r\n    \"\\\"\\u0154\\n\\\"\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0003\",\r\n    \"#\\u0003#\\u0003#\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003\",\r\n    \"$\\u0003$\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003&\\u0003&\\u0003\",\r\n    \"&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0005&\\u0179\\n&\\u0003\",\r\n    \"\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\",\r\n    \"\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0003\",\r\n    \"\\'\\u0003\\'\\u0003\\'\\u0003\\'\\u0005\\'\\u0191\\n\\'\\u0003(\\u0003(\\u0003(\\u0003\",\r\n    \"(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003(\\u0003\",\r\n    \"(\\u0003(\\u0003(\\u0003(\\u0003(\\u0005(\\u01a5\\n(\\u0003)\\u0003)\\u0003)\\u0003\",\r\n    \")\\u0003)\\u0003)\\u0003)\\u0003)\\u0005)\\u01af\\n)\\u0003*\\u0003*\\u0003*\\u0003\",\r\n    \"*\\u0003*\\u0003*\\u0003*\\u0003*\\u0005*\\u01b9\\n*\\u0003+\\u0003+\\u0003+\\u0003\",\r\n    \"+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003+\\u0003\",\r\n    \"+\\u0003+\\u0003+\\u0003+\\u0003+\\u0005+\\u01cd\\n+\\u0003,\\u0003,\\u0003,\\u0003\",\r\n    \",\\u0003,\\u0003,\\u0003,\\u0003,\\u0003,\\u0003,\\u0003,\\u0003,\\u0003,\\u0003\",\r\n    \",\\u0005,\\u01dd\\n,\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\r\n    \"-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\r\n    \"-\\u0005-\\u01f1\\n-\\u0003.\\u0006.\\u01f4\\n.\\r.\\u000e.\\u01f5\\u0003/\\u0006\",\r\n    \"/\\u01f9\\n/\\r/\\u000e/\\u01fa\\u00030\\u00030\\u00031\\u00061\\u0200\\n1\\r1\\u000e\",\r\n    \"1\\u0201\\u00032\\u00032\\u00033\\u00033\\u00034\\u00034\\u00034\\u00054\\u020b\",\r\n    \"\\n4\\u00035\\u00035\\u0002\\u00026\\u0003\\u0003\\u0005\\u0004\\u0007\\u0005\\t\",\r\n    \"\\u0006\\u000b\\u0007\\r\\b\\u000f\\t\\u0011\\n\\u0013\\u000b\\u0015\\f\\u0017\\r\\u0019\",\r\n    \"\\u000e\\u001b\\u000f\\u001d\\u0010\\u001f\\u0011!\\u0012#\\u0013%\\u0014\\'\\u0015\",\r\n    \")\\u0016+\\u0017-\\u0018/\\u00191\\u001a3\\u001b5\\u001c7\\u001d9\\u001e;\\u001f\",\r\n    \"= ?!A\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]0_1a2c\\u0002e\\u0002g\\u0002i\\u0002\",\r\n    \"\\u0003\\u0002\\u0007\\u0004\\u0002\\f\\f\\u000f\\u000f\\f\\u0002\\u000b\\u000f\\\"\",\r\n    \"\\\"\\u0087\\u0087\\u00a2\\u00a2\\u1682\\u1682\\u2002\\u200c\\u202a\\u202b\\u2031\",\r\n    \"\\u2031\\u2061\\u2061\\u3002\\u3002\\u0005\\u00022;C\\\\c|\\u0003\\u00022;\\u000e\",\r\n    \"\\u0002\\f\\f\\u000f\\u000f\\\"#%&((*1<<?B]_aa}}\\u007f\\u007f\\u0002\\u022a\\u0002\",\r\n    \"\\u0003\\u0003\\u0002\\u0002\\u0002\\u0002\\u0005\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\\u0002\\u0002\\u0002\\'\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\\u0002\\u0002+\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\\u0002/\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u00023\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"9\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\\u0002\\u0002\\u0002=\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\\u0002\\u0002A\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\\u0002E\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002I\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\\u0002\\u0002\\u0002\\u0002\",\r\n    \"O\\u0003\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002S\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0002U\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0003l\\u0003\\u0002\\u0002\\u0002\\u0005\",\r\n    \"w\\u0003\\u0002\\u0002\\u0002\\u0007|\\u0003\\u0002\\u0002\\u0002\\t\\u0085\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u000b\\u008c\\u0003\\u0002\\u0002\\u0002\\r\\u0094\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u000f\\u0097\\u0003\\u0002\\u0002\\u0002\\u0011\\u00a2\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0013\\u00a6\\u0003\\u0002\\u0002\\u0002\\u0015\\u00a8\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0017\\u00aa\\u0003\\u0002\\u0002\\u0002\\u0019\\u00ac\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u001b\\u00ae\\u0003\\u0002\\u0002\\u0002\\u001d\\u00b0\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u001f\\u00b2\\u0003\\u0002\\u0002\\u0002!\\u00b4\\u0003\",\r\n    \"\\u0002\\u0002\\u0002#\\u00b6\\u0003\\u0002\\u0002\\u0002%\\u00b8\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\'\\u00ba\\u0003\\u0002\\u0002\\u0002)\\u00bc\\u0003\\u0002\\u0002\",\r\n    \"\\u0002+\\u00be\\u0003\\u0002\\u0002\\u0002-\\u00c0\\u0003\\u0002\\u0002\\u0002\",\r\n    \"/\\u00c2\\u0003\\u0002\\u0002\\u00021\\u00c5\\u0003\\u0002\\u0002\\u00023\\u00c7\",\r\n    \"\\u0003\\u0002\\u0002\\u00025\\u00d3\\u0003\\u0002\\u0002\\u00027\\u00e3\\u0003\",\r\n    \"\\u0002\\u0002\\u00029\\u00f9\\u0003\\u0002\\u0002\\u0002;\\u010d\\u0003\\u0002\",\r\n    \"\\u0002\\u0002=\\u011f\\u0003\\u0002\\u0002\\u0002?\\u012f\\u0003\\u0002\\u0002\",\r\n    \"\\u0002A\\u0145\\u0003\\u0002\\u0002\\u0002C\\u0153\\u0003\\u0002\\u0002\\u0002\",\r\n    \"E\\u0155\\u0003\\u0002\\u0002\\u0002G\\u015f\\u0003\\u0002\\u0002\\u0002I\\u0168\",\r\n    \"\\u0003\\u0002\\u0002\\u0002K\\u0178\\u0003\\u0002\\u0002\\u0002M\\u0190\\u0003\",\r\n    \"\\u0002\\u0002\\u0002O\\u01a4\\u0003\\u0002\\u0002\\u0002Q\\u01ae\\u0003\\u0002\",\r\n    \"\\u0002\\u0002S\\u01b8\\u0003\\u0002\\u0002\\u0002U\\u01cc\\u0003\\u0002\\u0002\",\r\n    \"\\u0002W\\u01dc\\u0003\\u0002\\u0002\\u0002Y\\u01f0\\u0003\\u0002\\u0002\\u0002\",\r\n    \"[\\u01f3\\u0003\\u0002\\u0002\\u0002]\\u01f8\\u0003\\u0002\\u0002\\u0002_\\u01fc\",\r\n    \"\\u0003\\u0002\\u0002\\u0002a\\u01ff\\u0003\\u0002\\u0002\\u0002c\\u0203\\u0003\",\r\n    \"\\u0002\\u0002\\u0002e\\u0205\\u0003\\u0002\\u0002\\u0002g\\u020a\\u0003\\u0002\",\r\n    \"\\u0002\\u0002i\\u020c\\u0003\\u0002\\u0002\\u0002km\\u0005\\u0011\\t\\u0002lk\",\r\n    \"\\u0003\\u0002\\u0002\\u0002lm\\u0003\\u0002\\u0002\\u0002mn\\u0003\\u0002\\u0002\",\r\n    \"\\u0002nr\\u0005i5\\u0002oq\\n\\u0002\\u0002\\u0002po\\u0003\\u0002\\u0002\\u0002\",\r\n    \"qt\\u0003\\u0002\\u0002\\u0002rp\\u0003\\u0002\\u0002\\u0002rs\\u0003\\u0002\\u0002\",\r\n    \"\\u0002su\\u0003\\u0002\\u0002\\u0002tr\\u0003\\u0002\\u0002\\u0002uv\\b\\u0002\",\r\n    \"\\u0002\\u0002v\\u0004\\u0003\\u0002\\u0002\\u0002wy\\u0007.\\u0002\\u0002xz\\u0005\",\r\n    \"\\u0011\\t\\u0002yx\\u0003\\u0002\\u0002\\u0002yz\\u0003\\u0002\\u0002\\u0002z\",\r\n    \"\\u0006\\u0003\\u0002\\u0002\\u0002{}\\u0005\\u0011\\t\\u0002|{\\u0003\\u0002\\u0002\",\r\n    \"\\u0002|}\\u0003\\u0002\\u0002\\u0002}~\\u0003\\u0002\\u0002\\u0002~\\u007f\\u0007\",\r\n    \"?\\u0002\\u0002\\u007f\\u0080\\u0007@\\u0002\\u0002\\u0080\\u0082\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0081\\u0083\\u0005\\u0011\\t\\u0002\\u0082\\u0081\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0082\\u0083\\u0003\\u0002\\u0002\\u0002\\u0083\\b\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0084\\u0086\\u0005\\u0011\\t\\u0002\\u0085\\u0084\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0085\\u0086\\u0003\\u0002\\u0002\\u0002\\u0086\\u0087\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0087\\u0089\\u00071\\u0002\\u0002\\u0088\\u008a\\u0005\\u0011\",\r\n    \"\\t\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u0089\\u008a\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u008a\\n\\u0003\\u0002\\u0002\\u0002\\u008b\\u008d\\u0005\\u0011\",\r\n    \"\\t\\u0002\\u008c\\u008b\\u0003\\u0002\\u0002\\u0002\\u008c\\u008d\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u008d\\u008e\\u0003\\u0002\\u0002\\u0002\\u008e\\u008f\\u00071\",\r\n    \"\\u0002\\u0002\\u008f\\u0090\\u00071\\u0002\\u0002\\u0090\\u0092\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0091\\u0093\\u0005\\u0011\\t\\u0002\\u0092\\u0091\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0092\\u0093\\u0003\\u0002\\u0002\\u0002\\u0093\\f\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0094\\u0095\\u0007a\\u0002\\u0002\\u0095\\u000e\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0096\\u0098\\u0005\\u0011\\t\\u0002\\u0097\\u0096\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0097\\u0098\\u0003\\u0002\\u0002\\u0002\\u0098\\u009c\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0099\\u009a\\u0007\\u000f\\u0002\\u0002\\u009a\\u009d\\u0007\\f\",\r\n    \"\\u0002\\u0002\\u009b\\u009d\\u0007\\f\\u0002\\u0002\\u009c\\u0099\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u009c\\u009b\\u0003\\u0002\\u0002\\u0002\\u009d\\u009f\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u009e\\u00a0\\u0005\\u0011\\t\\u0002\\u009f\\u009e\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u009f\\u00a0\\u0003\\u0002\\u0002\\u0002\\u00a0\\u0010\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00a1\\u00a3\\t\\u0003\\u0002\\u0002\\u00a2\\u00a1\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00a3\\u00a4\\u0003\\u0002\\u0002\\u0002\\u00a4\\u00a2\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00a4\\u00a5\\u0003\\u0002\\u0002\\u0002\\u00a5\\u0012\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00a6\\u00a7\\u0007*\\u0002\\u0002\\u00a7\\u0014\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00a8\\u00a9\\u0007+\\u0002\\u0002\\u00a9\\u0016\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00aa\\u00ab\\u0007,\\u0002\\u0002\\u00ab\\u0018\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00ac\\u00ad\\u0007]\\u0002\\u0002\\u00ad\\u001a\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00ae\\u00af\\u0007_\\u0002\\u0002\\u00af\\u001c\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00b0\\u00b1\\u0007}\\u0002\\u0002\\u00b1\\u001e\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00b2\\u00b3\\u0007\\u007f\\u0002\\u0002\\u00b3 \\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00b4\\u00b5\\u0007-\\u0002\\u0002\\u00b5\\\"\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b6\\u00b7\\u0007A\\u0002\\u0002\\u00b7$\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00b8\\u00b9\\u0007/\\u0002\\u0002\\u00b9&\\u0003\\u0002\\u0002\\u0002\\u00ba\",\r\n    \"\\u00bb\\u0007<\\u0002\\u0002\\u00bb(\\u0003\\u0002\\u0002\\u0002\\u00bc\\u00bd\",\r\n    \"\\u0007#\\u0002\\u0002\\u00bd*\\u0003\\u0002\\u0002\\u0002\\u00be\\u00bf\\u0007\",\r\n    \"0\\u0002\\u0002\\u00bf,\\u0003\\u0002\\u0002\\u0002\\u00c0\\u00c1\\u0007&\\u0002\",\r\n    \"\\u0002\\u00c1.\\u0003\\u0002\\u0002\\u0002\\u00c2\\u00c3\\u0007&\\u0002\\u0002\",\r\n    \"\\u00c3\\u00c4\\u0007&\\u0002\\u0002\\u00c40\\u0003\\u0002\\u0002\\u0002\\u00c5\",\r\n    \"\\u00c6\\u0007B\\u0002\\u0002\\u00c62\\u0003\\u0002\\u0002\\u0002\\u00c7\\u00c8\",\r\n    \"\\u0007(\\u0002\\u0002\\u00c84\\u0003\\u0002\\u0002\\u0002\\u00c9\\u00ca\\u0007\",\r\n    \"E\\u0002\\u0002\\u00ca\\u00cb\\u0007n\\u0002\\u0002\\u00cb\\u00cc\\u0007c\\u0002\",\r\n    \"\\u0002\\u00cc\\u00cd\\u0007u\\u0002\\u0002\\u00cd\\u00d4\\u0007u\\u0002\\u0002\",\r\n    \"\\u00ce\\u00cf\\u0007e\\u0002\\u0002\\u00cf\\u00d0\\u0007n\\u0002\\u0002\\u00d0\",\r\n    \"\\u00d1\\u0007c\\u0002\\u0002\\u00d1\\u00d2\\u0007u\\u0002\\u0002\\u00d2\\u00d4\",\r\n    \"\\u0007u\\u0002\\u0002\\u00d3\\u00c9\\u0003\\u0002\\u0002\\u0002\\u00d3\\u00ce\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u00d46\\u0003\\u0002\\u0002\\u0002\\u00d5\\u00d6\",\r\n    \"\\u0007H\\u0002\\u0002\\u00d6\\u00d7\\u0007g\\u0002\\u0002\\u00d7\\u00d8\\u0007\",\r\n    \"c\\u0002\\u0002\\u00d8\\u00d9\\u0007v\\u0002\\u0002\\u00d9\\u00da\\u0007w\\u0002\",\r\n    \"\\u0002\\u00da\\u00db\\u0007t\\u0002\\u0002\\u00db\\u00e4\\u0007g\\u0002\\u0002\",\r\n    \"\\u00dc\\u00dd\\u0007h\\u0002\\u0002\\u00dd\\u00de\\u0007g\\u0002\\u0002\\u00de\",\r\n    \"\\u00df\\u0007c\\u0002\\u0002\\u00df\\u00e0\\u0007v\\u0002\\u0002\\u00e0\\u00e1\",\r\n    \"\\u0007w\\u0002\\u0002\\u00e1\\u00e2\\u0007t\\u0002\\u0002\\u00e2\\u00e4\\u0007\",\r\n    \"g\\u0002\\u0002\\u00e3\\u00d5\\u0003\\u0002\\u0002\\u0002\\u00e3\\u00dc\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00e48\\u0003\\u0002\\u0002\\u0002\\u00e5\\u00e6\\u0007\",\r\n    \"*\\u0002\\u0002\\u00e6\\u00e7\\u0007U\\u0002\\u0002\\u00e7\\u00e8\\u0007{\\u0002\",\r\n    \"\\u0002\\u00e8\\u00e9\\u0007n\\u0002\\u0002\\u00e9\\u00ea\\u0007n\\u0002\\u0002\",\r\n    \"\\u00ea\\u00eb\\u0007c\\u0002\\u0002\\u00eb\\u00ec\\u0007d\\u0002\\u0002\\u00ec\",\r\n    \"\\u00ed\\u0007n\\u0002\\u0002\\u00ed\\u00ee\\u0007g\\u0002\\u0002\\u00ee\\u00fa\",\r\n    \"\\u0007+\\u0002\\u0002\\u00ef\\u00f0\\u0007*\\u0002\\u0002\\u00f0\\u00f1\\u0007\",\r\n    \"u\\u0002\\u0002\\u00f1\\u00f2\\u0007{\\u0002\\u0002\\u00f2\\u00f3\\u0007n\\u0002\",\r\n    \"\\u0002\\u00f3\\u00f4\\u0007n\\u0002\\u0002\\u00f4\\u00f5\\u0007c\\u0002\\u0002\",\r\n    \"\\u00f5\\u00f6\\u0007d\\u0002\\u0002\\u00f6\\u00f7\\u0007n\\u0002\\u0002\\u00f7\",\r\n    \"\\u00f8\\u0007g\\u0002\\u0002\\u00f8\\u00fa\\u0007+\\u0002\\u0002\\u00f9\\u00e5\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u00f9\\u00ef\\u0003\\u0002\\u0002\\u0002\\u00fa:\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u00fb\\u00fc\\u0007F\\u0002\\u0002\\u00fc\\u00fd\",\r\n    \"\\u0007k\\u0002\\u0002\\u00fd\\u00fe\\u0007c\\u0002\\u0002\\u00fe\\u00ff\\u0007\",\r\n    \"e\\u0002\\u0002\\u00ff\\u0100\\u0007t\\u0002\\u0002\\u0100\\u0101\\u0007k\\u0002\",\r\n    \"\\u0002\\u0101\\u0102\\u0007v\\u0002\\u0002\\u0102\\u0103\\u0007k\\u0002\\u0002\",\r\n    \"\\u0103\\u010e\\u0007e\\u0002\\u0002\\u0104\\u0105\\u0007f\\u0002\\u0002\\u0105\",\r\n    \"\\u0106\\u0007k\\u0002\\u0002\\u0106\\u0107\\u0007c\\u0002\\u0002\\u0107\\u0108\",\r\n    \"\\u0007e\\u0002\\u0002\\u0108\\u0109\\u0007t\\u0002\\u0002\\u0109\\u010a\\u0007\",\r\n    \"k\\u0002\\u0002\\u010a\\u010b\\u0007v\\u0002\\u0002\\u010b\\u010c\\u0007k\\u0002\",\r\n    \"\\u0002\\u010c\\u010e\\u0007e\\u0002\\u0002\\u010d\\u00fb\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u010d\\u0104\\u0003\\u0002\\u0002\\u0002\\u010e<\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u010f\\u0110\\u0007*\\u0002\\u0002\\u0110\\u0111\\u0007D\\u0002\\u0002\",\r\n    \"\\u0111\\u0112\\u0007g\\u0002\\u0002\\u0112\\u0113\\u0007h\\u0002\\u0002\\u0113\",\r\n    \"\\u0114\\u0007q\\u0002\\u0002\\u0114\\u0115\\u0007t\\u0002\\u0002\\u0115\\u0116\",\r\n    \"\\u0007g\\u0002\\u0002\\u0116\\u0120\\u0007+\\u0002\\u0002\\u0117\\u0118\\u0007\",\r\n    \"*\\u0002\\u0002\\u0118\\u0119\\u0007d\\u0002\\u0002\\u0119\\u011a\\u0007g\\u0002\",\r\n    \"\\u0002\\u011a\\u011b\\u0007h\\u0002\\u0002\\u011b\\u011c\\u0007q\\u0002\\u0002\",\r\n    \"\\u011c\\u011d\\u0007t\\u0002\\u0002\\u011d\\u011e\\u0007g\\u0002\\u0002\\u011e\",\r\n    \"\\u0120\\u0007+\\u0002\\u0002\\u011f\\u010f\\u0003\\u0002\\u0002\\u0002\\u011f\",\r\n    \"\\u0117\\u0003\\u0002\\u0002\\u0002\\u0120>\\u0003\\u0002\\u0002\\u0002\\u0121\",\r\n    \"\\u0122\\u0007*\\u0002\\u0002\\u0122\\u0123\\u0007H\\u0002\\u0002\\u0123\\u0124\",\r\n    \"\\u0007k\\u0002\\u0002\\u0124\\u0125\\u0007t\\u0002\\u0002\\u0125\\u0126\\u0007\",\r\n    \"u\\u0002\\u0002\\u0126\\u0127\\u0007v\\u0002\\u0002\\u0127\\u0130\\u0007+\\u0002\",\r\n    \"\\u0002\\u0128\\u0129\\u0007*\\u0002\\u0002\\u0129\\u012a\\u0007h\\u0002\\u0002\",\r\n    \"\\u012a\\u012b\\u0007k\\u0002\\u0002\\u012b\\u012c\\u0007t\\u0002\\u0002\\u012c\",\r\n    \"\\u012d\\u0007u\\u0002\\u0002\\u012d\\u012e\\u0007v\\u0002\\u0002\\u012e\\u0130\",\r\n    \"\\u0007+\\u0002\\u0002\\u012f\\u0121\\u0003\\u0002\\u0002\\u0002\\u012f\\u0128\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0130@\\u0003\\u0002\\u0002\\u0002\\u0131\\u0132\",\r\n    \"\\u0007*\\u0002\\u0002\\u0132\\u0133\\u0007H\\u0002\\u0002\\u0133\\u0134\\u0007\",\r\n    \"n\\u0002\\u0002\\u0134\\u0135\\u0007q\\u0002\\u0002\\u0135\\u0136\\u0007c\\u0002\",\r\n    \"\\u0002\\u0136\\u0137\\u0007v\\u0002\\u0002\\u0137\\u0138\\u0007k\\u0002\\u0002\",\r\n    \"\\u0138\\u0139\\u0007p\\u0002\\u0002\\u0139\\u013a\\u0007i\\u0002\\u0002\\u013a\",\r\n    \"\\u0146\\u0007+\\u0002\\u0002\\u013b\\u013c\\u0007*\\u0002\\u0002\\u013c\\u013d\",\r\n    \"\\u0007h\\u0002\\u0002\\u013d\\u013e\\u0007n\\u0002\\u0002\\u013e\\u013f\\u0007\",\r\n    \"q\\u0002\\u0002\\u013f\\u0140\\u0007c\\u0002\\u0002\\u0140\\u0141\\u0007v\\u0002\",\r\n    \"\\u0002\\u0141\\u0142\\u0007k\\u0002\\u0002\\u0142\\u0143\\u0007p\\u0002\\u0002\",\r\n    \"\\u0143\\u0144\\u0007i\\u0002\\u0002\\u0144\\u0146\\u0007+\\u0002\\u0002\\u0145\",\r\n    \"\\u0131\\u0003\\u0002\\u0002\\u0002\\u0145\\u013b\\u0003\\u0002\\u0002\\u0002\\u0146\",\r\n    \"B\\u0003\\u0002\\u0002\\u0002\\u0147\\u0148\\u0007U\\u0002\\u0002\\u0148\\u0149\",\r\n    \"\\u0007{\\u0002\\u0002\\u0149\\u014a\\u0007o\\u0002\\u0002\\u014a\\u014b\\u0007\",\r\n    \"d\\u0002\\u0002\\u014b\\u014c\\u0007q\\u0002\\u0002\\u014c\\u0154\\u0007n\\u0002\",\r\n    \"\\u0002\\u014d\\u014e\\u0007u\\u0002\\u0002\\u014e\\u014f\\u0007{\\u0002\\u0002\",\r\n    \"\\u014f\\u0150\\u0007o\\u0002\\u0002\\u0150\\u0151\\u0007d\\u0002\\u0002\\u0151\",\r\n    \"\\u0152\\u0007q\\u0002\\u0002\\u0152\\u0154\\u0007n\\u0002\\u0002\\u0153\\u0147\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0153\\u014d\\u0003\\u0002\\u0002\\u0002\\u0154D\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0155\\u0156\\u0007U\\u0002\\u0002\\u0156\\u0157\",\r\n    \"\\u0007{\\u0002\\u0002\\u0157\\u0158\\u0007n\\u0002\\u0002\\u0158\\u0159\\u0007\",\r\n    \"n\\u0002\\u0002\\u0159\\u015a\\u0007c\\u0002\\u0002\\u015a\\u015b\\u0007d\\u0002\",\r\n    \"\\u0002\\u015b\\u015c\\u0007n\\u0002\\u0002\\u015c\\u015d\\u0007g\\u0002\\u0002\",\r\n    \"\\u015d\\u015e\\u0007u\\u0002\\u0002\\u015eF\\u0003\\u0002\\u0002\\u0002\\u015f\",\r\n    \"\\u0160\\u0007g\\u0002\\u0002\\u0160\\u0161\\u0007z\\u0002\\u0002\\u0161\\u0162\",\r\n    \"\\u0007r\\u0002\\u0002\\u0162\\u0163\\u0007n\\u0002\\u0002\\u0163\\u0164\\u0007\",\r\n    \"k\\u0002\\u0002\\u0164\\u0165\\u0007e\\u0002\\u0002\\u0165\\u0166\\u0007k\\u0002\",\r\n    \"\\u0002\\u0166\\u0167\\u0007v\\u0002\\u0002\\u0167H\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0168\\u0169\\u0007e\\u0002\\u0002\\u0169\\u016a\\u0007n\\u0002\\u0002\\u016a\",\r\n    \"\\u016b\\u0007g\\u0002\\u0002\\u016b\\u016c\\u0007c\\u0002\\u0002\\u016c\\u016d\",\r\n    \"\\u0007t\\u0002\\u0002\\u016dJ\\u0003\\u0002\\u0002\\u0002\\u016e\\u016f\\u0007\",\r\n    \">\\u0002\\u0002\\u016f\\u0170\\u0007U\\u0002\\u0002\\u0170\\u0171\\u0007{\\u0002\",\r\n    \"\\u0002\\u0171\\u0172\\u0007n\\u0002\\u0002\\u0172\\u0179\\u0007@\\u0002\\u0002\",\r\n    \"\\u0173\\u0174\\u0007>\\u0002\\u0002\\u0174\\u0175\\u0007u\\u0002\\u0002\\u0175\",\r\n    \"\\u0176\\u0007{\\u0002\\u0002\\u0176\\u0177\\u0007n\\u0002\\u0002\\u0177\\u0179\",\r\n    \"\\u0007@\\u0002\\u0002\\u0178\\u016e\\u0003\\u0002\\u0002\\u0002\\u0178\\u0173\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0179L\\u0003\\u0002\\u0002\\u0002\\u017a\\u017b\",\r\n    \"\\u0007F\\u0002\\u0002\\u017b\\u017c\\u0007g\\u0002\\u0002\\u017c\\u017d\\u0007\",\r\n    \"t\\u0002\\u0002\\u017d\\u017e\\u0007q\\u0002\\u0002\\u017e\\u017f\\u0007o\\u0002\",\r\n    \"\\u0002\\u017f\\u0180\\u0007c\\u0002\\u0002\\u0180\\u0181\\u0007p\\u0002\\u0002\",\r\n    \"\\u0181\\u0182\\u0007k\\u0002\\u0002\\u0182\\u0183\\u0007|\\u0002\\u0002\\u0183\",\r\n    \"\\u0184\\u0007g\\u0002\\u0002\\u0184\\u0191\\u0007t\\u0002\\u0002\\u0185\\u0186\",\r\n    \"\\u0007f\\u0002\\u0002\\u0186\\u0187\\u0007g\\u0002\\u0002\\u0187\\u0188\\u0007\",\r\n    \"t\\u0002\\u0002\\u0188\\u0189\\u0007q\\u0002\\u0002\\u0189\\u018a\\u0007o\\u0002\",\r\n    \"\\u0002\\u018a\\u018b\\u0007c\\u0002\\u0002\\u018b\\u018c\\u0007p\\u0002\\u0002\",\r\n    \"\\u018c\\u018d\\u0007k\\u0002\\u0002\\u018d\\u018e\\u0007|\\u0002\\u0002\\u018e\",\r\n    \"\\u018f\\u0007g\\u0002\\u0002\\u018f\\u0191\\u0007t\\u0002\\u0002\\u0190\\u017a\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0190\\u0185\\u0003\\u0002\\u0002\\u0002\\u0191N\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0192\\u0193\\u0007T\\u0002\\u0002\\u0193\\u0194\",\r\n    \"\\u0007q\\u0002\\u0002\\u0194\\u0195\\u0007o\\u0002\\u0002\\u0195\\u0196\\u0007\",\r\n    \"c\\u0002\\u0002\\u0196\\u0197\\u0007p\\u0002\\u0002\\u0197\\u0198\\u0007k\\u0002\",\r\n    \"\\u0002\\u0198\\u0199\\u0007|\\u0002\\u0002\\u0199\\u019a\\u0007g\\u0002\\u0002\",\r\n    \"\\u019a\\u01a5\\u0007t\\u0002\\u0002\\u019b\\u019c\\u0007t\\u0002\\u0002\\u019c\",\r\n    \"\\u019d\\u0007q\\u0002\\u0002\\u019d\\u019e\\u0007o\\u0002\\u0002\\u019e\\u019f\",\r\n    \"\\u0007c\\u0002\\u0002\\u019f\\u01a0\\u0007p\\u0002\\u0002\\u01a0\\u01a1\\u0007\",\r\n    \"k\\u0002\\u0002\\u01a1\\u01a2\\u0007|\\u0002\\u0002\\u01a2\\u01a3\\u0007g\\u0002\",\r\n    \"\\u0002\\u01a3\\u01a5\\u0007t\\u0002\\u0002\\u01a4\\u0192\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u01a4\\u019b\\u0003\\u0002\\u0002\\u0002\\u01a5P\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u01a6\\u01a7\\u0007V\\u0002\\u0002\\u01a7\\u01a8\\u0007j\\u0002\\u0002\",\r\n    \"\\u01a8\\u01a9\\u0007g\\u0002\\u0002\\u01a9\\u01af\\u0007p\\u0002\\u0002\\u01aa\",\r\n    \"\\u01ab\\u0007v\\u0002\\u0002\\u01ab\\u01ac\\u0007j\\u0002\\u0002\\u01ac\\u01ad\",\r\n    \"\\u0007g\\u0002\\u0002\\u01ad\\u01af\\u0007p\\u0002\\u0002\\u01ae\\u01a6\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01ae\\u01aa\\u0003\\u0002\\u0002\\u0002\\u01afR\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01b0\\u01b1\\u0007G\\u0002\\u0002\\u01b1\\u01b2\\u0007\",\r\n    \"n\\u0002\\u0002\\u01b2\\u01b3\\u0007u\\u0002\\u0002\\u01b3\\u01b9\\u0007g\\u0002\",\r\n    \"\\u0002\\u01b4\\u01b5\\u0007g\\u0002\\u0002\\u01b5\\u01b6\\u0007n\\u0002\\u0002\",\r\n    \"\\u01b6\\u01b7\\u0007u\\u0002\\u0002\\u01b7\\u01b9\\u0007g\\u0002\\u0002\\u01b8\",\r\n    \"\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b8\\u01b4\\u0003\\u0002\\u0002\\u0002\\u01b9\",\r\n    \"T\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bb\\u0007R\\u0002\\u0002\\u01bb\\u01bc\",\r\n    \"\\u0007t\\u0002\\u0002\\u01bc\\u01bd\\u0007q\\u0002\\u0002\\u01bd\\u01be\\u0007\",\r\n    \"r\\u0002\\u0002\\u01be\\u01bf\\u0007c\\u0002\\u0002\\u01bf\\u01c0\\u0007i\\u0002\",\r\n    \"\\u0002\\u01c0\\u01c1\\u0007c\\u0002\\u0002\\u01c1\\u01c2\\u0007v\\u0002\\u0002\",\r\n    \"\\u01c2\\u01cd\\u0007g\\u0002\\u0002\\u01c3\\u01c4\\u0007r\\u0002\\u0002\\u01c4\",\r\n    \"\\u01c5\\u0007t\\u0002\\u0002\\u01c5\\u01c6\\u0007q\\u0002\\u0002\\u01c6\\u01c7\",\r\n    \"\\u0007r\\u0002\\u0002\\u01c7\\u01c8\\u0007c\\u0002\\u0002\\u01c8\\u01c9\\u0007\",\r\n    \"i\\u0002\\u0002\\u01c9\\u01ca\\u0007c\\u0002\\u0002\\u01ca\\u01cb\\u0007v\\u0002\",\r\n    \"\\u0002\\u01cb\\u01cd\\u0007g\\u0002\\u0002\\u01cc\\u01ba\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u01cc\\u01c3\\u0003\\u0002\\u0002\\u0002\\u01cdV\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u01ce\\u01cf\\u0007N\\u0002\\u0002\\u01cf\\u01d0\\u0007k\\u0002\\u0002\",\r\n    \"\\u01d0\\u01d1\\u0007v\\u0002\\u0002\\u01d1\\u01d2\\u0007g\\u0002\\u0002\\u01d2\",\r\n    \"\\u01d3\\u0007t\\u0002\\u0002\\u01d3\\u01d4\\u0007c\\u0002\\u0002\\u01d4\\u01dd\",\r\n    \"\\u0007n\\u0002\\u0002\\u01d5\\u01d6\\u0007n\\u0002\\u0002\\u01d6\\u01d7\\u0007\",\r\n    \"k\\u0002\\u0002\\u01d7\\u01d8\\u0007v\\u0002\\u0002\\u01d8\\u01d9\\u0007g\\u0002\",\r\n    \"\\u0002\\u01d9\\u01da\\u0007t\\u0002\\u0002\\u01da\\u01db\\u0007c\\u0002\\u0002\",\r\n    \"\\u01db\\u01dd\\u0007n\\u0002\\u0002\\u01dc\\u01ce\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01dc\\u01d5\\u0003\\u0002\\u0002\\u0002\\u01ddX\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01de\\u01df\\u0007W\\u0002\\u0002\\u01df\\u01e0\\u0007p\\u0002\\u0002\\u01e0\",\r\n    \"\\u01e1\\u0007e\\u0002\\u0002\\u01e1\\u01e2\\u0007j\\u0002\\u0002\\u01e2\\u01e3\",\r\n    \"\\u0007c\\u0002\\u0002\\u01e3\\u01e4\\u0007p\\u0002\\u0002\\u01e4\\u01e5\\u0007\",\r\n    \"i\\u0002\\u0002\\u01e5\\u01e6\\u0007g\\u0002\\u0002\\u01e6\\u01f1\\u0007f\\u0002\",\r\n    \"\\u0002\\u01e7\\u01e8\\u0007w\\u0002\\u0002\\u01e8\\u01e9\\u0007p\\u0002\\u0002\",\r\n    \"\\u01e9\\u01ea\\u0007e\\u0002\\u0002\\u01ea\\u01eb\\u0007j\\u0002\\u0002\\u01eb\",\r\n    \"\\u01ec\\u0007c\\u0002\\u0002\\u01ec\\u01ed\\u0007p\\u0002\\u0002\\u01ed\\u01ee\",\r\n    \"\\u0007i\\u0002\\u0002\\u01ee\\u01ef\\u0007g\\u0002\\u0002\\u01ef\\u01f1\\u0007\",\r\n    \"f\\u0002\\u0002\\u01f0\\u01de\\u0003\\u0002\\u0002\\u0002\\u01f0\\u01e7\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01f1Z\\u0003\\u0002\\u0002\\u0002\\u01f2\\u01f4\\u0005\",\r\n    \"e3\\u0002\\u01f3\\u01f2\\u0003\\u0002\\u0002\\u0002\\u01f4\\u01f5\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01f5\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f5\\u01f6\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01f6\\\\\\u0003\\u0002\\u0002\\u0002\\u01f7\\u01f9\\u0005c2\\u0002\",\r\n    \"\\u01f8\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01f9\\u01fa\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01fa\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fa\\u01fb\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01fb^\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01fd\\u0005g4\\u0002\\u01fd`\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01fe\\u0200\\u0005g4\\u0002\\u01ff\\u01fe\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0200\\u0201\\u0003\\u0002\\u0002\\u0002\\u0201\\u01ff\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0201\\u0202\\u0003\\u0002\\u0002\\u0002\\u0202b\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0203\\u0204\\t\\u0004\\u0002\\u0002\\u0204d\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0205\\u0206\\t\\u0005\\u0002\\u0002\\u0206f\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0207\\u0208\\u0007^\\u0002\\u0002\\u0208\\u020b\\u000b\\u0002\\u0002\\u0002\",\r\n    \"\\u0209\\u020b\\n\\u0006\\u0002\\u0002\\u020a\\u0207\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u020a\\u0209\\u0003\\u0002\\u0002\\u0002\\u020bh\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u020c\\u020d\\u0007%\\u0002\\u0002\\u020dj\\u0003\\u0002\\u0002\\u0002$\\u0002\",\r\n    \"lry|\\u0082\\u0085\\u0089\\u008c\\u0092\\u0097\\u009c\\u009f\\u00a4\\u00d3\\u00e3\",\r\n    \"\\u00f9\\u010d\\u011f\\u012f\\u0145\\u0153\\u0178\\u0190\\u01a4\\u01ae\\u01b8\\u01cc\",\r\n    \"\\u01dc\\u01f0\\u01f5\\u01fa\\u0201\\u020a\\u0003\\b\\u0002\\u0002\"].join(\"\");\r\n\r\n\r\nvar atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\r\n\r\nvar decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });\r\n\r\nfunction LscLexer(input) {\r\n\tantlr4.Lexer.call(this, input);\r\n    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());\r\n    return this;\r\n}\r\n\r\nLscLexer.prototype = Object.create(antlr4.Lexer.prototype);\r\nLscLexer.prototype.constructor = LscLexer;\r\n\r\nObject.defineProperty(LscLexer.prototype, \"atn\", {\r\n        get : function() {\r\n                return atn;\r\n        }\r\n});\r\n\r\nLscLexer.EOF = antlr4.Token.EOF;\r\nLscLexer.COMMENT = 1;\r\nLscLexer.SEP = 2;\r\nLscLexer.CHANGE = 3;\r\nLscLexer.CONDITION = 4;\r\nLscLexer.EXCLUSION = 5;\r\nLscLexer.ANCHOR = 6;\r\nLscLexer.NEWLINE = 7;\r\nLscLexer.WHITESPACE = 8;\r\nLscLexer.O_PAREN = 9;\r\nLscLexer.C_PAREN = 10;\r\nLscLexer.NULL = 11;\r\nLscLexer.MATRIX_START = 12;\r\nLscLexer.MATRIX_END = 13;\r\nLscLexer.LIST_START = 14;\r\nLscLexer.LIST_END = 15;\r\nLscLexer.AT_LEAST_ONE = 16;\r\nLscLexer.OPTIONAL = 17;\r\nLscLexer.HYPHEN = 18;\r\nLscLexer.RULE_START = 19;\r\nLscLexer.NEGATION = 20;\r\nLscLexer.SYLLABLE_BOUNDARY = 21;\r\nLscLexer.WORD_BOUNDARY = 22;\r\nLscLexer.BETWEEN_WORDS = 23;\r\nLscLexer.CLASSREF = 24;\r\nLscLexer.INTERSECTION = 25;\r\nLscLexer.CLASS_DECL = 26;\r\nLscLexer.FEATURE_DECL = 27;\r\nLscLexer.SYLLABLE_FEATURE = 28;\r\nLscLexer.DIACRITIC = 29;\r\nLscLexer.DIA_BEFORE = 30;\r\nLscLexer.DIA_FIRST = 31;\r\nLscLexer.DIA_FLOATING = 32;\r\nLscLexer.SYMBOL = 33;\r\nLscLexer.SYLLABLE_DECL = 34;\r\nLscLexer.EXPLICIT_SYLLABLES = 35;\r\nLscLexer.CLEAR_SYLLABLES = 36;\r\nLscLexer.ANY_SYLLABLE = 37;\r\nLscLexer.DEROMANIZER = 38;\r\nLscLexer.ROMANIZER = 39;\r\nLscLexer.ALL_MATCHING = 40;\r\nLscLexer.FIRST_MATCHING = 41;\r\nLscLexer.PROPAGATE = 42;\r\nLscLexer.LITERAL = 43;\r\nLscLexer.UNCHANGED = 44;\r\nLscLexer.NUMBER = 45;\r\nLscLexer.NAME = 46;\r\nLscLexer.STR1 = 47;\r\nLscLexer.STR = 48;\r\n\r\nLscLexer.prototype.channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\r\n\r\nLscLexer.prototype.modeNames = [ \"DEFAULT_MODE\" ];\r\n\r\nLscLexer.prototype.literalNames = [ null, null, null, null, null, null, \r\n                                    \"'_'\", null, null, \"'('\", \"')'\", \"'*'\", \r\n                                    \"'['\", \"']'\", \"'{'\", \"'}'\", \"'+'\", \"'?'\", \r\n                                    \"'-'\", \"':'\", \"'!'\", \"'.'\", \"'$'\", \"'$$'\", \r\n                                    \"'@'\", \"'&'\", null, null, null, null, \r\n                                    null, null, null, null, \"'Syllables'\", \r\n                                    \"'explicit'\", \"'clear'\" ];\r\n\r\nLscLexer.prototype.symbolicNames = [ null, \"COMMENT\", \"SEP\", \"CHANGE\", \"CONDITION\", \r\n                                     \"EXCLUSION\", \"ANCHOR\", \"NEWLINE\", \"WHITESPACE\", \r\n                                     \"O_PAREN\", \"C_PAREN\", \"NULL\", \"MATRIX_START\", \r\n                                     \"MATRIX_END\", \"LIST_START\", \"LIST_END\", \r\n                                     \"AT_LEAST_ONE\", \"OPTIONAL\", \"HYPHEN\", \r\n                                     \"RULE_START\", \"NEGATION\", \"SYLLABLE_BOUNDARY\", \r\n                                     \"WORD_BOUNDARY\", \"BETWEEN_WORDS\", \"CLASSREF\", \r\n                                     \"INTERSECTION\", \"CLASS_DECL\", \"FEATURE_DECL\", \r\n                                     \"SYLLABLE_FEATURE\", \"DIACRITIC\", \"DIA_BEFORE\", \r\n                                     \"DIA_FIRST\", \"DIA_FLOATING\", \"SYMBOL\", \r\n                                     \"SYLLABLE_DECL\", \"EXPLICIT_SYLLABLES\", \r\n                                     \"CLEAR_SYLLABLES\", \"ANY_SYLLABLE\", \r\n                                     \"DEROMANIZER\", \"ROMANIZER\", \"ALL_MATCHING\", \r\n                                     \"FIRST_MATCHING\", \"PROPAGATE\", \"LITERAL\", \r\n                                     \"UNCHANGED\", \"NUMBER\", \"NAME\", \"STR1\", \r\n                                     \"STR\" ];\r\n\r\nLscLexer.prototype.ruleNames = [ \"COMMENT\", \"SEP\", \"CHANGE\", \"CONDITION\", \r\n                                 \"EXCLUSION\", \"ANCHOR\", \"NEWLINE\", \"WHITESPACE\", \r\n                                 \"O_PAREN\", \"C_PAREN\", \"NULL\", \"MATRIX_START\", \r\n                                 \"MATRIX_END\", \"LIST_START\", \"LIST_END\", \r\n                                 \"AT_LEAST_ONE\", \"OPTIONAL\", \"HYPHEN\", \"RULE_START\", \r\n                                 \"NEGATION\", \"SYLLABLE_BOUNDARY\", \"WORD_BOUNDARY\", \r\n                                 \"BETWEEN_WORDS\", \"CLASSREF\", \"INTERSECTION\", \r\n                                 \"CLASS_DECL\", \"FEATURE_DECL\", \"SYLLABLE_FEATURE\", \r\n                                 \"DIACRITIC\", \"DIA_BEFORE\", \"DIA_FIRST\", \r\n                                 \"DIA_FLOATING\", \"SYMBOL\", \"SYLLABLE_DECL\", \r\n                                 \"EXPLICIT_SYLLABLES\", \"CLEAR_SYLLABLES\", \r\n                                 \"ANY_SYLLABLE\", \"DEROMANIZER\", \"ROMANIZER\", \r\n                                 \"ALL_MATCHING\", \"FIRST_MATCHING\", \"PROPAGATE\", \r\n                                 \"LITERAL\", \"UNCHANGED\", \"NUMBER\", \"NAME\", \r\n                                 \"STR1\", \"STR\", \"CHAR\", \"DIGIT\", \"ANY\", \r\n                                 \"COMMENT_START\" ];\r\n\r\nLscLexer.prototype.grammarFileName = \"Lsc.g4\";\r\n\r\n\r\n\r\nexports.LscLexer = LscLexer;\r\n\r\n","// Generated from Lsc.g4 by ANTLR 4.7.2\r\n// jshint ignore: start\r\nvar antlr4 = require('antlr4/index');\r\nvar LscVisitor = require('./LscVisitor').LscVisitor;\r\n\r\nvar grammarFileName = \"Lsc.g4\";\r\n\r\n\r\nvar serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\",\r\n    \"\\u00032\\u02a2\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\\t\",\r\n    \"\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\\u0004\",\r\n    \"\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\\u0004\",\r\n    \"\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\\u0004\",\r\n    \"\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\\u0004\\u0014\\t\",\r\n    \"\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\\t\\u0017\\u0004\",\r\n    \"\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\\u0004\\u001b\\t\",\r\n    \"\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\\t\\u001e\\u0004\",\r\n    \"\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\\t#\\u0004$\\t$\\u0004\",\r\n    \"%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004*\\t*\\u0004+\\t+\\u0004\",\r\n    \",\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u00041\\t1\\u00042\\t2\\u0004\",\r\n    \"3\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u00047\\t7\\u00048\\t8\\u00049\\t9\\u0004\",\r\n    \":\\t:\\u0004;\\t;\\u0004<\\t<\\u0004=\\t=\\u0004>\\t>\\u0004?\\t?\\u0004@\\t@\\u0004\",\r\n    \"A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004D\\tD\\u0004E\\tE\\u0003\\u0002\\u0003\\u0002\",\r\n    \"\\u0007\\u0002\\u008d\\n\\u0002\\f\\u0002\\u000e\\u0002\\u0090\\u000b\\u0002\\u0003\",\r\n    \"\\u0002\\u0005\\u0002\\u0093\\n\\u0002\\u0003\\u0002\\u0006\\u0002\\u0096\\n\\u0002\",\r\n    \"\\r\\u0002\\u000e\\u0002\\u0097\\u0003\\u0002\\u0007\\u0002\\u009b\\n\\u0002\\f\\u0002\",\r\n    \"\\u000e\\u0002\\u009e\\u000b\\u0002\\u0003\\u0002\\u0007\\u0002\\u00a1\\n\\u0002\",\r\n    \"\\f\\u0002\\u000e\\u0002\\u00a4\\u000b\\u0002\\u0003\\u0002\\u0005\\u0002\\u00a7\",\r\n    \"\\n\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\r\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0005\\u0003\\u00b2\\n\",\r\n    \"\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\",\r\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0007\\u0004\\u00bc\\n\\u0004\\f\\u0004\\u000e\",\r\n    \"\\u0004\\u00bf\\u000b\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\\u0005\",\r\n    \"\\u0005\\u0005\\u00c5\\n\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0006\\u0003\",\r\n    \"\\u0006\\u0003\\u0006\\u0007\\u0006\\u00cc\\n\\u0006\\f\\u0006\\u000e\\u0006\\u00cf\",\r\n    \"\\u000b\\u0006\\u0003\\u0006\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006\\u00d4\\n\",\r\n    \"\\u0006\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006\\u00d8\\n\\u0006\\u0003\\u0006\",\r\n    \"\\u0003\\u0006\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006\\u00de\\n\\u0006\\u0003\",\r\n    \"\\u0006\\u0003\\u0006\\u0003\\u0006\\u0007\\u0006\\u00e3\\n\\u0006\\f\\u0006\\u000e\",\r\n    \"\\u0006\\u00e6\\u000b\\u0006\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006\\u00ea\\n\",\r\n    \"\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\\b\\u0003\\b\\u0005\\b\\u00f1\",\r\n    \"\\n\\b\\u0003\\b\\u0005\\b\\u00f4\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\",\r\n    \"\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0007\\n\\u0102\",\r\n    \"\\n\\n\\f\\n\\u000e\\n\\u0105\\u000b\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0007\\n\\u010a\",\r\n    \"\\n\\n\\f\\n\\u000e\\n\\u010d\\u000b\\n\\u0003\\u000b\\u0003\\u000b\\u0003\\f\\u0003\",\r\n    \"\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0007\\f\\u0116\\n\\f\\f\\f\\u000e\\f\\u0119\\u000b\",\r\n    \"\\f\\u0003\\f\\u0003\\f\\u0005\\f\\u011d\\n\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\",\r\n    \"\\u000e\\u0003\\u000e\\u0006\\u000e\\u0124\\n\\u000e\\r\\u000e\\u000e\\u000e\\u0125\",\r\n    \"\\u0003\\u000e\\u0003\\u000e\\u0006\\u000e\\u012a\\n\\u000e\\r\\u000e\\u000e\\u000e\",\r\n    \"\\u012b\\u0003\\u000e\\u0006\\u000e\\u012f\\n\\u000e\\r\\u000e\\u000e\\u000e\\u0130\",\r\n    \"\\u0005\\u000e\\u0133\\n\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u000f\\u0005\",\r\n    \"\\u000f\\u0138\\n\\u000f\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\",\r\n    \"\\u0003\\u0010\\u0005\\u0010\\u013f\\n\\u0010\\u0003\\u0010\\u0003\\u0010\\u0006\",\r\n    \"\\u0010\\u0143\\n\\u0010\\r\\u0010\\u000e\\u0010\\u0144\\u0003\\u0010\\u0003\\u0010\",\r\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0005\\u0011\\u014c\\n\\u0011\\u0003\",\r\n    \"\\u0011\\u0003\\u0011\\u0006\\u0011\\u0150\\n\\u0011\\r\\u0011\\u000e\\u0011\\u0151\",\r\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\",\r\n    \"\\u0003\\u0012\\u0005\\u0012\\u015b\\n\\u0012\\u0003\\u0012\\u0003\\u0012\\u0006\",\r\n    \"\\u0012\\u015f\\n\\u0012\\r\\u0012\\u000e\\u0012\\u0160\\u0003\\u0012\\u0003\\u0012\",\r\n    \"\\u0003\\u0013\\u0003\\u0013\\u0003\\u0013\\u0007\\u0013\\u0168\\n\\u0013\\f\\u0013\",\r\n    \"\\u000e\\u0013\\u016b\\u000b\\u0013\\u0003\\u0013\\u0005\\u0013\\u016e\\n\\u0013\",\r\n    \"\\u0003\\u0013\\u0006\\u0013\\u0171\\n\\u0013\\r\\u0013\\u000e\\u0013\\u0172\\u0003\",\r\n    \"\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0005\\u0014\\u0179\\n\\u0014\",\r\n    \"\\u0003\\u0015\\u0003\\u0015\\u0005\\u0015\\u017d\\n\\u0015\\u0003\\u0016\\u0003\",\r\n    \"\\u0016\\u0006\\u0016\\u0181\\n\\u0016\\r\\u0016\\u000e\\u0016\\u0182\\u0003\\u0016\",\r\n    \"\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0006\\u0016\\u0189\\n\\u0016\\r\\u0016\",\r\n    \"\\u000e\\u0016\\u018a\\u0005\\u0016\\u018d\\n\\u0016\\u0003\\u0016\\u0003\\u0016\",\r\n    \"\\u0007\\u0016\\u0191\\n\\u0016\\f\\u0016\\u000e\\u0016\\u0194\\u000b\\u0016\\u0003\",\r\n    \"\\u0017\\u0003\\u0017\\u0003\\u0017\\u0007\\u0017\\u0199\\n\\u0017\\f\\u0017\\u000e\",\r\n    \"\\u0017\\u019c\\u000b\\u0017\\u0003\\u0017\\u0003\\u0017\\u0007\\u0017\\u01a0\\n\",\r\n    \"\\u0017\\f\\u0017\\u000e\\u0017\\u01a3\\u000b\\u0017\\u0003\\u0017\\u0003\\u0017\",\r\n    \"\\u0005\\u0017\\u01a7\\n\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0005\",\r\n    \"\\u0018\\u01ac\\n\\u0018\\u0003\\u0019\\u0003\\u0019\\u0006\\u0019\\u01b0\\n\\u0019\",\r\n    \"\\r\\u0019\\u000e\\u0019\\u01b1\\u0003\\u0019\\u0007\\u0019\\u01b5\\n\\u0019\\f\\u0019\",\r\n    \"\\u000e\\u0019\\u01b8\\u000b\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0007\",\r\n    \"\\u001a\\u01bd\\n\\u001a\\f\\u001a\\u000e\\u001a\\u01c0\\u000b\\u001a\\u0003\\u001b\",\r\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0005\\u001b\",\r\n    \"\\u01c8\\n\\u001b\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\\u0003\\u001d\\u0003\",\r\n    \"\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0005\",\r\n    \"\\u001e\\u01d4\\n\\u001e\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0005\\u001f\",\r\n    \"\\u01d9\\n\\u001f\\u0003 \\u0003 \\u0003 \\u0003 \\u0003!\\u0003!\\u0003!\\u0003\",\r\n    \"!\\u0007!\\u01e3\\n!\\f!\\u000e!\\u01e6\\u000b!\\u0003!\\u0003!\\u0003\\\"\\u0003\",\r\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003#\\u0006#\\u01f2\\n#\\r#\\u000e\",\r\n    \"#\\u01f3\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0005$\\u01fb\\n$\\u0003%\\u0003\",\r\n    \"%\\u0005%\\u01ff\\n%\\u0003%\\u0003%\\u0005%\\u0203\\n%\\u0003&\\u0003&\\u0005\",\r\n    \"&\\u0207\\n&\\u0003\\'\\u0003\\'\\u0005\\'\\u020b\\n\\'\\u0003(\\u0003(\\u0003(\\u0003\",\r\n    \"(\\u0007(\\u0211\\n(\\f(\\u000e(\\u0214\\u000b(\\u0003(\\u0003(\\u0003)\\u0003\",\r\n    \")\\u0003)\\u0005)\\u021b\\n)\\u0003)\\u0003)\\u0003)\\u0005)\\u0220\\n)\\u0003\",\r\n    \")\\u0005)\\u0223\\n)\\u0005)\\u0225\\n)\\u0003*\\u0003*\\u0003+\\u0003+\\u0003\",\r\n    \",\\u0003,\\u0003,\\u0006,\\u022e\\n,\\r,\\u000e,\\u022f\\u0003-\\u0003-\\u0003\",\r\n    \"-\\u0003-\\u0005-\\u0236\\n-\\u0003.\\u0003.\\u0003.\\u0003/\\u0003/\\u0005/\\u023d\",\r\n    \"\\n/\\u00030\\u00030\\u00030\\u00050\\u0242\\n0\\u00030\\u00030\\u00031\\u0003\",\r\n    \"1\\u00051\\u0248\\n1\\u00031\\u00031\\u00032\\u00032\\u00032\\u00032\\u00032\\u0003\",\r\n    \"2\\u00032\\u00032\\u00032\\u00052\\u0255\\n2\\u00033\\u00033\\u00034\\u00034\\u0003\",\r\n    \"4\\u00035\\u00035\\u00035\\u00036\\u00036\\u00056\\u0261\\n6\\u00036\\u00036\\u0007\",\r\n    \"6\\u0265\\n6\\f6\\u000e6\\u0268\\u000b6\\u00036\\u00036\\u00037\\u00037\\u0003\",\r\n    \"7\\u00037\\u00037\\u00057\\u0271\\n7\\u00038\\u00038\\u00038\\u00039\\u00039\\u0003\",\r\n    \"9\\u0003:\\u0003:\\u0003:\\u0003;\\u0003;\\u0003<\\u0003<\\u0003=\\u0003=\\u0003\",\r\n    \">\\u0003>\\u0003?\\u0003?\\u0003@\\u0003@\\u0005@\\u0288\\n@\\u0003@\\u0003@\\u0007\",\r\n    \"@\\u028c\\n@\\f@\\u000e@\\u028f\\u000b@\\u0003@\\u0003@\\u0003A\\u0003A\\u0005\",\r\n    \"A\\u0295\\nA\\u0003B\\u0003B\\u0003B\\u0003C\\u0003C\\u0003D\\u0003D\\u0003E\\u0003\",\r\n    \"E\\u0005E\\u02a0\\nE\\u0003E\\u0002\\u0002F\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\",\r\n    \"\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\\u001e \\\"$&(*,.02468:<>@B\",\r\n    \"DFHJLNPRTVXZ\\\\^`bdfhjlnprtvxz|~\\u0080\\u0082\\u0084\\u0086\\u0088\\u0002\",\r\n    \"\\t\\u0003\\u0002 \\\"\\u0003\\u0002%&\\u0003\\u0002*+\\u0003\\u0002/0\\u0004\\u0002\",\r\n    \"\\r\\r\\u0012\\u0013\\u0004\\u0002\\u0012\\u0012\\u0014\\u0014\\u0003\\u000202\\u0002\",\r\n    \"\\u02c5\\u0002\\u00a6\\u0003\\u0002\\u0002\\u0002\\u0004\\u00b1\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0006\\u00b3\\u0003\\u0002\\u0002\\u0002\\b\\u00c4\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\n\\u00c6\\u0003\\u0002\\u0002\\u0002\\f\\u00eb\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u000e\\u00f0\\u0003\\u0002\\u0002\\u0002\\u0010\\u00f7\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0012\\u00fa\\u0003\\u0002\\u0002\\u0002\\u0014\\u010e\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0016\\u0110\\u0003\\u0002\\u0002\\u0002\\u0018\\u011e\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u001a\\u0120\\u0003\\u0002\\u0002\\u0002\\u001c\\u0134\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u001e\\u013b\\u0003\\u0002\\u0002\\u0002 \\u0148\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\\"\\u0155\\u0003\\u0002\\u0002\\u0002$\\u0164\\u0003\\u0002\\u0002\\u0002&\\u0178\",\r\n    \"\\u0003\\u0002\\u0002\\u0002(\\u017c\\u0003\\u0002\\u0002\\u0002*\\u017e\\u0003\",\r\n    \"\\u0002\\u0002\\u0002,\\u01a6\\u0003\\u0002\\u0002\\u0002.\\u01a8\\u0003\\u0002\",\r\n    \"\\u0002\\u00020\\u01ad\\u0003\\u0002\\u0002\\u00022\\u01b9\\u0003\\u0002\\u0002\",\r\n    \"\\u00024\\u01c7\\u0003\\u0002\\u0002\\u00026\\u01c9\\u0003\\u0002\\u0002\\u0002\",\r\n    \"8\\u01cb\\u0003\\u0002\\u0002\\u0002:\\u01d3\\u0003\\u0002\\u0002\\u0002<\\u01d8\",\r\n    \"\\u0003\\u0002\\u0002\\u0002>\\u01da\\u0003\\u0002\\u0002\\u0002@\\u01de\\u0003\",\r\n    \"\\u0002\\u0002\\u0002B\\u01e9\\u0003\\u0002\\u0002\\u0002D\\u01ee\\u0003\\u0002\",\r\n    \"\\u0002\\u0002F\\u01fa\\u0003\\u0002\\u0002\\u0002H\\u01fe\\u0003\\u0002\\u0002\",\r\n    \"\\u0002J\\u0206\\u0003\\u0002\\u0002\\u0002L\\u020a\\u0003\\u0002\\u0002\\u0002\",\r\n    \"N\\u020c\\u0003\\u0002\\u0002\\u0002P\\u0224\\u0003\\u0002\\u0002\\u0002R\\u0226\",\r\n    \"\\u0003\\u0002\\u0002\\u0002T\\u0228\\u0003\\u0002\\u0002\\u0002V\\u022a\\u0003\",\r\n    \"\\u0002\\u0002\\u0002X\\u0235\\u0003\\u0002\\u0002\\u0002Z\\u0237\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\\\\\u023c\\u0003\\u0002\\u0002\\u0002^\\u0241\\u0003\\u0002\\u0002\",\r\n    \"\\u0002`\\u0247\\u0003\\u0002\\u0002\\u0002b\\u0254\\u0003\\u0002\\u0002\\u0002\",\r\n    \"d\\u0256\\u0003\\u0002\\u0002\\u0002f\\u0258\\u0003\\u0002\\u0002\\u0002h\\u025b\",\r\n    \"\\u0003\\u0002\\u0002\\u0002j\\u025e\\u0003\\u0002\\u0002\\u0002l\\u0270\\u0003\",\r\n    \"\\u0002\\u0002\\u0002n\\u0272\\u0003\\u0002\\u0002\\u0002p\\u0275\\u0003\\u0002\",\r\n    \"\\u0002\\u0002r\\u0278\\u0003\\u0002\\u0002\\u0002t\\u027b\\u0003\\u0002\\u0002\",\r\n    \"\\u0002v\\u027d\\u0003\\u0002\\u0002\\u0002x\\u027f\\u0003\\u0002\\u0002\\u0002\",\r\n    \"z\\u0281\\u0003\\u0002\\u0002\\u0002|\\u0283\\u0003\\u0002\\u0002\\u0002~\\u0285\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0080\\u0294\\u0003\\u0002\\u0002\\u0002\\u0082\\u0296\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0084\\u0299\\u0003\\u0002\\u0002\\u0002\\u0086\\u029b\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0088\\u029d\\u0003\\u0002\\u0002\\u0002\\u008a\\u00a7\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u008b\\u008d\\u0007\\t\\u0002\\u0002\\u008c\\u008b\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u008d\\u0090\\u0003\\u0002\\u0002\\u0002\\u008e\\u008c\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u008e\\u008f\\u0003\\u0002\\u0002\\u0002\\u008f\\u0092\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0090\\u008e\\u0003\\u0002\\u0002\\u0002\\u0091\\u0093\\u0005\",\r\n    \"\\u0004\\u0003\\u0002\\u0092\\u0091\\u0003\\u0002\\u0002\\u0002\\u0092\\u0093\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0093\\u009c\\u0003\\u0002\\u0002\\u0002\\u0094\\u0096\\u0007\",\r\n    \"\\t\\u0002\\u0002\\u0095\\u0094\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0097\\u0095\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0098\\u0099\\u0003\\u0002\\u0002\\u0002\\u0099\\u009b\\u0005\",\r\n    \"\\u0004\\u0003\\u0002\\u009a\\u0095\\u0003\\u0002\\u0002\\u0002\\u009b\\u009e\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u009c\\u009a\\u0003\\u0002\\u0002\\u0002\\u009c\\u009d\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u009d\\u00a2\\u0003\\u0002\\u0002\\u0002\\u009e\\u009c\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u009f\\u00a1\\u0007\\t\\u0002\\u0002\\u00a0\\u009f\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00a1\\u00a4\\u0003\\u0002\\u0002\\u0002\\u00a2\\u00a0\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00a2\\u00a3\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a5\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00a4\\u00a2\\u0003\\u0002\\u0002\\u0002\\u00a5\\u00a7\\u0007\",\r\n    \"\\u0002\\u0002\\u0003\\u00a6\\u008a\\u0003\\u0002\\u0002\\u0002\\u00a6\\u008e\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00a7\\u0003\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00b2\\u0005\",\r\n    \"\\n\\u0006\\u0002\\u00a9\\u00b2\\u0005\\u0012\\n\\u0002\\u00aa\\u00b2\\u0005\\u0016\",\r\n    \"\\f\\u0002\\u00ab\\u00b2\\u0005\\u0006\\u0004\\u0002\\u00ac\\u00b2\\u0005\\u001a\",\r\n    \"\\u000e\\u0002\\u00ad\\u00b2\\u0005\\u001e\\u0010\\u0002\\u00ae\\u00b2\\u0005$\",\r\n    \"\\u0013\\u0002\\u00af\\u00b2\\u0005\\\"\\u0012\\u0002\\u00b0\\u00b2\\u0005 \\u0011\",\r\n    \"\\u0002\\u00b1\\u00a8\\u0003\\u0002\\u0002\\u0002\\u00b1\\u00a9\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b1\\u00aa\\u0003\\u0002\\u0002\\u0002\\u00b1\\u00ab\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b1\\u00ac\\u0003\\u0002\\u0002\\u0002\\u00b1\\u00ad\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b1\\u00ae\\u0003\\u0002\\u0002\\u0002\\u00b1\\u00af\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b1\\u00b0\\u0003\\u0002\\u0002\\u0002\\u00b2\\u0005\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00b3\\u00b4\\u0007\\u001c\\u0002\\u0002\\u00b4\\u00b5\\u0007\\n\\u0002\",\r\n    \"\\u0002\\u00b5\\u00b6\\u0005\\u0086D\\u0002\\u00b6\\u00b7\\u0007\\n\\u0002\\u0002\",\r\n    \"\\u00b7\\u00b8\\u0007\\u0010\\u0002\\u0002\\u00b8\\u00bd\\u0005\\b\\u0005\\u0002\",\r\n    \"\\u00b9\\u00ba\\u0007\\u0004\\u0002\\u0002\\u00ba\\u00bc\\u0005\\b\\u0005\\u0002\",\r\n    \"\\u00bb\\u00b9\\u0003\\u0002\\u0002\\u0002\\u00bc\\u00bf\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00bd\\u00bb\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00be\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00be\\u00c0\\u0003\\u0002\\u0002\\u0002\\u00bf\\u00bd\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00c0\\u00c1\\u0007\\u0011\\u0002\\u0002\\u00c1\\u0007\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00c2\\u00c5\\u0005f4\\u0002\\u00c3\\u00c5\\u0005\\u0088E\\u0002\\u00c4\\u00c2\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u00c4\\u00c3\\u0003\\u0002\\u0002\\u0002\\u00c5\\t\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u00c6\\u00c7\\u0007\\u001d\\u0002\\u0002\\u00c7\\u00e9\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u00c8\\u00cd\\u0005\\u000e\\b\\u0002\\u00c9\\u00ca\\u0007\",\r\n    \"\\u0004\\u0002\\u0002\\u00ca\\u00cc\\u0005\\u000e\\b\\u0002\\u00cb\\u00c9\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00cc\\u00cf\\u0003\\u0002\\u0002\\u0002\\u00cd\\u00cb\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00cd\\u00ce\\u0003\\u0002\\u0002\\u0002\\u00ce\\u00ea\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u00cf\\u00cd\\u0003\\u0002\\u0002\\u0002\\u00d0\\u00d1\\u0005\",\r\n    \"\\f\\u0007\\u0002\\u00d1\\u00d2\\u0007\\n\\u0002\\u0002\\u00d2\\u00d4\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00d3\\u00d0\\u0003\\u0002\\u0002\\u0002\\u00d3\\u00d4\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u00d4\\u00d5\\u0003\\u0002\\u0002\\u0002\\u00d5\\u00d7\\u0005\\u0086\",\r\n    \"D\\u0002\\u00d6\\u00d8\\u0007\\n\\u0002\\u0002\\u00d7\\u00d6\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00d7\\u00d8\\u0003\\u0002\\u0002\\u0002\\u00d8\\u00d9\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00d9\\u00dd\\u0007\\u000b\\u0002\\u0002\\u00da\\u00db\\u0005\\u0010\\t\",\r\n    \"\\u0002\\u00db\\u00dc\\u0007\\u0004\\u0002\\u0002\\u00dc\\u00de\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00dd\\u00da\\u0003\\u0002\\u0002\\u0002\\u00dd\\u00de\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00de\\u00df\\u0003\\u0002\\u0002\\u0002\\u00df\\u00e4\\u0005\\u0084C\",\r\n    \"\\u0002\\u00e0\\u00e1\\u0007\\u0004\\u0002\\u0002\\u00e1\\u00e3\\u0005\\u0084C\",\r\n    \"\\u0002\\u00e2\\u00e0\\u0003\\u0002\\u0002\\u0002\\u00e3\\u00e6\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00e4\\u00e2\\u0003\\u0002\\u0002\\u0002\\u00e4\\u00e5\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00e5\\u00e7\\u0003\\u0002\\u0002\\u0002\\u00e6\\u00e4\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00e7\\u00e8\\u0007\\f\\u0002\\u0002\\u00e8\\u00ea\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00e9\\u00c8\\u0003\\u0002\\u0002\\u0002\\u00e9\\u00d3\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u00ea\\u000b\\u0003\\u0002\\u0002\\u0002\\u00eb\\u00ec\\u0007\\u001e\\u0002\",\r\n    \"\\u0002\\u00ec\\r\\u0003\\u0002\\u0002\\u0002\\u00ed\\u00ee\\u0005\\f\\u0007\\u0002\",\r\n    \"\\u00ee\\u00ef\\u0007\\n\\u0002\\u0002\\u00ef\\u00f1\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00f0\\u00ed\\u0003\\u0002\\u0002\\u0002\\u00f0\\u00f1\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00f1\\u00f3\\u0003\\u0002\\u0002\\u0002\\u00f2\\u00f4\\u0007\\u0012\\u0002\\u0002\",\r\n    \"\\u00f3\\u00f2\\u0003\\u0002\\u0002\\u0002\\u00f3\\u00f4\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00f4\\u00f5\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00f6\\u0005\\u0086D\\u0002\",\r\n    \"\\u00f6\\u000f\\u0003\\u0002\\u0002\\u0002\\u00f7\\u00f8\\u0007\\r\\u0002\\u0002\",\r\n    \"\\u00f8\\u00f9\\u0005\\u0084C\\u0002\\u00f9\\u0011\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u00fa\\u00fb\\u0007\\u001f\\u0002\\u0002\\u00fb\\u00fc\\u0007\\n\\u0002\\u0002\",\r\n    \"\\u00fc\\u00fd\\u0005\\u0088E\\u0002\\u00fd\\u0103\\u0007\\n\\u0002\\u0002\\u00fe\",\r\n    \"\\u00ff\\u0005\\u0014\\u000b\\u0002\\u00ff\\u0100\\u0007\\n\\u0002\\u0002\\u0100\",\r\n    \"\\u0102\\u0003\\u0002\\u0002\\u0002\\u0101\\u00fe\\u0003\\u0002\\u0002\\u0002\\u0102\",\r\n    \"\\u0105\\u0003\\u0002\\u0002\\u0002\\u0103\\u0101\\u0003\\u0002\\u0002\\u0002\\u0103\",\r\n    \"\\u0104\\u0003\\u0002\\u0002\\u0002\\u0104\\u0106\\u0003\\u0002\\u0002\\u0002\\u0105\",\r\n    \"\\u0103\\u0003\\u0002\\u0002\\u0002\\u0106\\u010b\\u0005~@\\u0002\\u0107\\u0108\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u0108\\u010a\\u0005\\u0014\\u000b\\u0002\\u0109\\u0107\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u010a\\u010d\\u0003\\u0002\\u0002\\u0002\\u010b\\u0109\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u010b\\u010c\\u0003\\u0002\\u0002\\u0002\\u010c\\u0013\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u010d\\u010b\\u0003\\u0002\\u0002\\u0002\\u010e\\u010f\",\r\n    \"\\t\\u0002\\u0002\\u0002\\u010f\\u0015\\u0003\\u0002\\u0002\\u0002\\u0110\\u0111\",\r\n    \"\\u0007#\\u0002\\u0002\\u0111\\u0112\\u0007\\n\\u0002\\u0002\\u0112\\u011c\\u0005\",\r\n    \"\\u0018\\r\\u0002\\u0113\\u0114\\u0007\\u0004\\u0002\\u0002\\u0114\\u0116\\u0005\",\r\n    \"\\u0018\\r\\u0002\\u0115\\u0113\\u0003\\u0002\\u0002\\u0002\\u0116\\u0119\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0117\\u0115\\u0003\\u0002\\u0002\\u0002\\u0117\\u0118\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0118\\u011d\\u0003\\u0002\\u0002\\u0002\\u0119\\u0117\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u011a\\u011b\\u0007\\n\\u0002\\u0002\\u011b\\u011d\\u0005\",\r\n    \"~@\\u0002\\u011c\\u0117\\u0003\\u0002\\u0002\\u0002\\u011c\\u011a\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u011d\\u0017\\u0003\\u0002\\u0002\\u0002\\u011e\\u011f\\u0005\\u0088\",\r\n    \"E\\u0002\\u011f\\u0019\\u0003\\u0002\\u0002\\u0002\\u0120\\u0121\\u0007$\\u0002\",\r\n    \"\\u0002\\u0121\\u0132\\u0007\\u0015\\u0002\\u0002\\u0122\\u0124\\u0007\\t\\u0002\",\r\n    \"\\u0002\\u0123\\u0122\\u0003\\u0002\\u0002\\u0002\\u0124\\u0125\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0125\\u0123\\u0003\\u0002\\u0002\\u0002\\u0125\\u0126\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0126\\u0127\\u0003\\u0002\\u0002\\u0002\\u0127\\u0133\\t\\u0003\\u0002\",\r\n    \"\\u0002\\u0128\\u012a\\u0007\\t\\u0002\\u0002\\u0129\\u0128\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u012a\\u012b\\u0003\\u0002\\u0002\\u0002\\u012b\\u0129\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u012b\\u012c\\u0003\\u0002\\u0002\\u0002\\u012c\\u012d\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u012d\\u012f\\u0005\\u001c\\u000f\\u0002\\u012e\\u0129\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u012f\\u0130\\u0003\\u0002\\u0002\\u0002\\u0130\\u012e\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0130\\u0131\\u0003\\u0002\\u0002\\u0002\\u0131\\u0133\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0132\\u0123\\u0003\\u0002\\u0002\\u0002\\u0132\\u012e\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0133\\u001b\\u0003\\u0002\\u0002\\u0002\\u0134\\u0137\\u0005:\\u001e\",\r\n    \"\\u0002\\u0135\\u0136\\u0007\\u0005\\u0002\\u0002\\u0136\\u0138\\u0005~@\\u0002\",\r\n    \"\\u0137\\u0135\\u0003\\u0002\\u0002\\u0002\\u0137\\u0138\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0138\\u0139\\u0003\\u0002\\u0002\\u0002\\u0139\\u013a\\u0005H%\\u0002\\u013a\",\r\n    \"\\u001d\\u0003\\u0002\\u0002\\u0002\\u013b\\u013e\\u0007(\\u0002\\u0002\\u013c\",\r\n    \"\\u013d\\u0007\\n\\u0002\\u0002\\u013d\\u013f\\u0007-\\u0002\\u0002\\u013e\\u013c\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u013e\\u013f\\u0003\\u0002\\u0002\\u0002\\u013f\\u0140\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0140\\u0142\\u0007\\u0015\\u0002\\u0002\\u0141\\u0143\",\r\n    \"\\u0007\\t\\u0002\\u0002\\u0142\\u0141\\u0003\\u0002\\u0002\\u0002\\u0143\\u0144\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0144\\u0142\\u0003\\u0002\\u0002\\u0002\\u0144\\u0145\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0145\\u0146\\u0003\\u0002\\u0002\\u0002\\u0146\\u0147\",\r\n    \"\\u0005*\\u0016\\u0002\\u0147\\u001f\\u0003\\u0002\\u0002\\u0002\\u0148\\u014b\",\r\n    \"\\u0007)\\u0002\\u0002\\u0149\\u014a\\u0007\\n\\u0002\\u0002\\u014a\\u014c\\u0007\",\r\n    \"-\\u0002\\u0002\\u014b\\u0149\\u0003\\u0002\\u0002\\u0002\\u014b\\u014c\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u014c\\u014d\\u0003\\u0002\\u0002\\u0002\\u014d\\u014f\\u0007\",\r\n    \"\\u0015\\u0002\\u0002\\u014e\\u0150\\u0007\\t\\u0002\\u0002\\u014f\\u014e\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0150\\u0151\\u0003\\u0002\\u0002\\u0002\\u0151\\u014f\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0151\\u0152\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0153\\u0154\\u0005*\\u0016\\u0002\\u0154!\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0155\\u0156\\u0007)\\u0002\\u0002\\u0156\\u0157\\u0007\\u0014\",\r\n    \"\\u0002\\u0002\\u0157\\u015a\\u00052\\u001a\\u0002\\u0158\\u0159\\u0007\\n\\u0002\",\r\n    \"\\u0002\\u0159\\u015b\\u0007-\\u0002\\u0002\\u015a\\u0158\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u015a\\u015b\\u0003\\u0002\\u0002\\u0002\\u015b\\u015c\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u015c\\u015e\\u0007\\u0015\\u0002\\u0002\\u015d\\u015f\\u0007\\t\\u0002\",\r\n    \"\\u0002\\u015e\\u015d\\u0003\\u0002\\u0002\\u0002\\u015f\\u0160\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0160\\u015e\\u0003\\u0002\\u0002\\u0002\\u0160\\u0161\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0161\\u0162\\u0003\\u0002\\u0002\\u0002\\u0162\\u0163\\u0005*\\u0016\",\r\n    \"\\u0002\\u0163#\\u0003\\u0002\\u0002\\u0002\\u0164\\u0169\\u00052\\u001a\\u0002\",\r\n    \"\\u0165\\u0166\\u0007\\n\\u0002\\u0002\\u0166\\u0168\\u0005&\\u0014\\u0002\\u0167\",\r\n    \"\\u0165\\u0003\\u0002\\u0002\\u0002\\u0168\\u016b\\u0003\\u0002\\u0002\\u0002\\u0169\",\r\n    \"\\u0167\\u0003\\u0002\\u0002\\u0002\\u0169\\u016a\\u0003\\u0002\\u0002\\u0002\\u016a\",\r\n    \"\\u016d\\u0003\\u0002\\u0002\\u0002\\u016b\\u0169\\u0003\\u0002\\u0002\\u0002\\u016c\",\r\n    \"\\u016e\\u0007\\u0015\\u0002\\u0002\\u016d\\u016c\\u0003\\u0002\\u0002\\u0002\\u016d\",\r\n    \"\\u016e\\u0003\\u0002\\u0002\\u0002\\u016e\\u0170\\u0003\\u0002\\u0002\\u0002\\u016f\",\r\n    \"\\u0171\\u0007\\t\\u0002\\u0002\\u0170\\u016f\\u0003\\u0002\\u0002\\u0002\\u0171\",\r\n    \"\\u0172\\u0003\\u0002\\u0002\\u0002\\u0172\\u0170\\u0003\\u0002\\u0002\\u0002\\u0172\",\r\n    \"\\u0173\\u0003\\u0002\\u0002\\u0002\\u0173\\u0174\\u0003\\u0002\\u0002\\u0002\\u0174\",\r\n    \"\\u0175\\u0005*\\u0016\\u0002\\u0175%\\u0003\\u0002\\u0002\\u0002\\u0176\\u0179\",\r\n    \"\\u0005(\\u0015\\u0002\\u0177\\u0179\\u0007,\\u0002\\u0002\\u0178\\u0176\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0178\\u0177\\u0003\\u0002\\u0002\\u0002\\u0179\\'\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u017a\\u017d\\u0005f4\\u0002\\u017b\\u017d\\u0005j6\\u0002\",\r\n    \"\\u017c\\u017a\\u0003\\u0002\\u0002\\u0002\\u017c\\u017b\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u017d)\\u0003\\u0002\\u0002\\u0002\\u017e\\u0192\\u0005,\\u0017\\u0002\\u017f\",\r\n    \"\\u0181\\u0007\\t\\u0002\\u0002\\u0180\\u017f\\u0003\\u0002\\u0002\\u0002\\u0181\",\r\n    \"\\u0182\\u0003\\u0002\\u0002\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0182\",\r\n    \"\\u0183\\u0003\\u0002\\u0002\\u0002\\u0183\\u0184\\u0003\\u0002\\u0002\\u0002\\u0184\",\r\n    \"\\u0185\\u0005.\\u0018\\u0002\\u0185\\u018c\\u0007\\u0015\\u0002\\u0002\\u0186\",\r\n    \"\\u018d\\u0007\\n\\u0002\\u0002\\u0187\\u0189\\u0007\\t\\u0002\\u0002\\u0188\\u0187\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0189\\u018a\\u0003\\u0002\\u0002\\u0002\\u018a\\u0188\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u018a\\u018b\\u0003\\u0002\\u0002\\u0002\\u018b\\u018d\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u018c\\u0186\\u0003\\u0002\\u0002\\u0002\\u018c\\u0188\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u018d\\u018e\\u0003\\u0002\\u0002\\u0002\\u018e\\u018f\",\r\n    \"\\u0005,\\u0017\\u0002\\u018f\\u0191\\u0003\\u0002\\u0002\\u0002\\u0190\\u0180\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0191\\u0194\\u0003\\u0002\\u0002\\u0002\\u0192\\u0190\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0192\\u0193\\u0003\\u0002\\u0002\\u0002\\u0193+\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0194\\u0192\\u0003\\u0002\\u0002\\u0002\\u0195\\u01a7\",\r\n    \"\\u00050\\u0019\\u0002\\u0196\\u019a\\u0007\\u000b\\u0002\\u0002\\u0197\\u0199\",\r\n    \"\\u0007\\t\\u0002\\u0002\\u0198\\u0197\\u0003\\u0002\\u0002\\u0002\\u0199\\u019c\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u019a\\u0198\\u0003\\u0002\\u0002\\u0002\\u019a\\u019b\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u019b\\u019d\\u0003\\u0002\\u0002\\u0002\\u019c\\u019a\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u019d\\u01a1\\u0005*\\u0016\\u0002\\u019e\\u01a0\",\r\n    \"\\u0007\\t\\u0002\\u0002\\u019f\\u019e\\u0003\\u0002\\u0002\\u0002\\u01a0\\u01a3\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01a1\\u019f\\u0003\\u0002\\u0002\\u0002\\u01a1\\u01a2\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01a4\\u0003\\u0002\\u0002\\u0002\\u01a3\\u01a1\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01a4\\u01a5\\u0007\\f\\u0002\\u0002\\u01a5\\u01a7\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01a6\\u0195\\u0003\\u0002\\u0002\\u0002\\u01a6\\u0196\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01a7-\\u0003\\u0002\\u0002\\u0002\\u01a8\\u01ab\",\r\n    \"\\t\\u0004\\u0002\\u0002\\u01a9\\u01aa\\u0007\\n\\u0002\\u0002\\u01aa\\u01ac\\u0007\",\r\n    \",\\u0002\\u0002\\u01ab\\u01a9\\u0003\\u0002\\u0002\\u0002\\u01ab\\u01ac\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01ac/\\u0003\\u0002\\u0002\\u0002\\u01ad\\u01b6\\u0005\",\r\n    \"4\\u001b\\u0002\\u01ae\\u01b0\\u0007\\t\\u0002\\u0002\\u01af\\u01ae\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b0\\u01b1\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01af\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b1\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01b2\\u01b3\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b3\\u01b5\\u00054\\u001b\\u0002\\u01b4\\u01af\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b5\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01b6\\u01b4\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b6\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01b71\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01b8\\u01b6\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01be\\u00070\",\r\n    \"\\u0002\\u0002\\u01ba\\u01bb\\u0007\\u0014\\u0002\\u0002\\u01bb\\u01bd\\t\\u0005\",\r\n    \"\\u0002\\u0002\\u01bc\\u01ba\\u0003\\u0002\\u0002\\u0002\\u01bd\\u01c0\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01be\\u01bc\\u0003\\u0002\\u0002\\u0002\\u01be\\u01bf\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01bf3\\u0003\\u0002\\u0002\\u0002\\u01c0\\u01be\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01c1\\u01c8\\u0007.\\u0002\\u0002\\u01c2\\u01c3\\u00056\\u001c\",\r\n    \"\\u0002\\u01c3\\u01c4\\u0007\\u0005\\u0002\\u0002\\u01c4\\u01c5\\u00058\\u001d\",\r\n    \"\\u0002\\u01c5\\u01c6\\u0005H%\\u0002\\u01c6\\u01c8\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01c7\\u01c1\\u0003\\u0002\\u0002\\u0002\\u01c7\\u01c2\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u01c85\\u0003\\u0002\\u0002\\u0002\\u01c9\\u01ca\\u0005:\\u001e\\u0002\\u01ca\",\r\n    \"7\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\\u0005:\\u001e\\u0002\\u01cc9\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u01cd\\u01d4\\u0005<\\u001f\\u0002\\u01ce\\u01d4\\u0005\",\r\n    \"V,\\u0002\\u01cf\\u01d4\\u0005Z.\\u0002\\u01d0\\u01d4\\u0005\\\\/\\u0002\\u01d1\",\r\n    \"\\u01d4\\u0005b2\\u0002\\u01d2\\u01d4\\u0005D#\\u0002\\u01d3\\u01cd\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01d3\\u01ce\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01cf\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01d3\\u01d0\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d1\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01d3\\u01d2\\u0003\\u0002\\u0002\\u0002\\u01d4;\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01d5\\u01d9\\u0005> \\u0002\\u01d6\\u01d9\\u0005@!\\u0002\\u01d7\",\r\n    \"\\u01d9\\u0005B\\\"\\u0002\\u01d8\\u01d5\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d6\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d7\\u0003\\u0002\\u0002\\u0002\\u01d9=\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u01da\\u01db\\u0007\\u000b\\u0002\\u0002\\u01db\\u01dc\",\r\n    \"\\u0005:\\u001e\\u0002\\u01dc\\u01dd\\u0007\\f\\u0002\\u0002\\u01dd?\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01de\\u01df\\u0007\\u0010\\u0002\\u0002\\u01df\\u01e4\\u0005:\",\r\n    \"\\u001e\\u0002\\u01e0\\u01e1\\u0007\\u0004\\u0002\\u0002\\u01e1\\u01e3\\u0005:\",\r\n    \"\\u001e\\u0002\\u01e2\\u01e0\\u0003\\u0002\\u0002\\u0002\\u01e3\\u01e6\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01e4\\u01e2\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e5\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01e5\\u01e7\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e4\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01e7\\u01e8\\u0007\\u0011\\u0002\\u0002\\u01e8A\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01e9\\u01ea\\u0007\\u000b\\u0002\\u0002\\u01ea\\u01eb\\u0005:\",\r\n    \"\\u001e\\u0002\\u01eb\\u01ec\\u0005H%\\u0002\\u01ec\\u01ed\\u0007\\f\\u0002\\u0002\",\r\n    \"\\u01edC\\u0003\\u0002\\u0002\\u0002\\u01ee\\u01f1\\u0005F$\\u0002\\u01ef\\u01f0\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u01f0\\u01f2\\u0005F$\\u0002\\u01f1\\u01ef\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01f2\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f3\\u01f1\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01f3\\u01f4\\u0003\\u0002\\u0002\\u0002\\u01f4E\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01f5\\u01fb\\u0005<\\u001f\\u0002\\u01f6\\u01fb\\u0005V,\\u0002\",\r\n    \"\\u01f7\\u01fb\\u0005Z.\\u0002\\u01f8\\u01fb\\u0005\\\\/\\u0002\\u01f9\\u01fb\\u0005\",\r\n    \"b2\\u0002\\u01fa\\u01f5\\u0003\\u0002\\u0002\\u0002\\u01fa\\u01f6\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01fa\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01fa\\u01f8\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01fa\\u01f9\\u0003\\u0002\\u0002\\u0002\\u01fbG\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01fc\\u01fd\\u0007\\u0006\\u0002\\u0002\\u01fd\\u01ff\\u0005J\",\r\n    \"&\\u0002\\u01fe\\u01fc\\u0003\\u0002\\u0002\\u0002\\u01fe\\u01ff\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u01ff\\u0202\\u0003\\u0002\\u0002\\u0002\\u0200\\u0201\\u0007\\u0007\",\r\n    \"\\u0002\\u0002\\u0201\\u0203\\u0005L\\'\\u0002\\u0202\\u0200\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0202\\u0203\\u0003\\u0002\\u0002\\u0002\\u0203I\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0204\\u0207\\u0005P)\\u0002\\u0205\\u0207\\u0005N(\\u0002\\u0206\\u0204\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0206\\u0205\\u0003\\u0002\\u0002\\u0002\\u0207K\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u0208\\u020b\\u0005P)\\u0002\\u0209\\u020b\\u0005\",\r\n    \"N(\\u0002\\u020a\\u0208\\u0003\\u0002\\u0002\\u0002\\u020a\\u0209\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u020bM\\u0003\\u0002\\u0002\\u0002\\u020c\\u020d\\u0007\\u0010\",\r\n    \"\\u0002\\u0002\\u020d\\u0212\\u0005P)\\u0002\\u020e\\u020f\\u0007\\u0004\\u0002\",\r\n    \"\\u0002\\u020f\\u0211\\u0005P)\\u0002\\u0210\\u020e\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0211\\u0214\\u0003\\u0002\\u0002\\u0002\\u0212\\u0210\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0212\\u0213\\u0003\\u0002\\u0002\\u0002\\u0213\\u0215\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0214\\u0212\\u0003\\u0002\\u0002\\u0002\\u0215\\u0216\\u0007\\u0011\\u0002\\u0002\",\r\n    \"\\u0216O\\u0003\\u0002\\u0002\\u0002\\u0217\\u0218\\u0005R*\\u0002\\u0218\\u0219\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u0219\\u021b\\u0003\\u0002\\u0002\\u0002\\u021a\\u0217\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u021a\\u021b\\u0003\\u0002\\u0002\\u0002\\u021b\\u021c\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u021c\\u021f\\u0007\\b\\u0002\\u0002\\u021d\\u021e\",\r\n    \"\\u0007\\n\\u0002\\u0002\\u021e\\u0220\\u0005T+\\u0002\\u021f\\u021d\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u021f\\u0220\\u0003\\u0002\\u0002\\u0002\\u0220\\u0225\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0221\\u0223\\u0005R*\\u0002\\u0222\\u0221\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0222\\u0223\\u0003\\u0002\\u0002\\u0002\\u0223\\u0225\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0224\\u021a\\u0003\\u0002\\u0002\\u0002\\u0224\\u0222\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u0225Q\\u0003\\u0002\\u0002\\u0002\\u0226\\u0227\\u0005:\\u001e\\u0002\",\r\n    \"\\u0227S\\u0003\\u0002\\u0002\\u0002\\u0228\\u0229\\u0005:\\u001e\\u0002\\u0229\",\r\n    \"U\\u0003\\u0002\\u0002\\u0002\\u022a\\u022d\\u0005X-\\u0002\\u022b\\u022c\\u0007\",\r\n    \"\\u001b\\u0002\\u0002\\u022c\\u022e\\u0005X-\\u0002\\u022d\\u022b\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u022e\\u022f\\u0003\\u0002\\u0002\\u0002\\u022f\\u022d\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u022f\\u0230\\u0003\\u0002\\u0002\\u0002\\u0230W\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0231\\u0236\\u0005<\\u001f\\u0002\\u0232\\u0236\\u0005Z.\\u0002\",\r\n    \"\\u0233\\u0236\\u0005\\\\/\\u0002\\u0234\\u0236\\u0005b2\\u0002\\u0235\\u0231\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0235\\u0232\\u0003\\u0002\\u0002\\u0002\\u0235\\u0233\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0235\\u0234\\u0003\\u0002\\u0002\\u0002\\u0236Y\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0237\\u0238\\u0007\\u0016\\u0002\\u0002\\u0238\\u0239\\u0005\",\r\n    \"b2\\u0002\\u0239[\\u0003\\u0002\\u0002\\u0002\\u023a\\u023d\\u0005^0\\u0002\\u023b\",\r\n    \"\\u023d\\u0005`1\\u0002\\u023c\\u023a\\u0003\\u0002\\u0002\\u0002\\u023c\\u023b\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u023d]\\u0003\\u0002\\u0002\\u0002\\u023e\\u0242\",\r\n    \"\\u0005<\\u001f\\u0002\\u023f\\u0242\\u0005Z.\\u0002\\u0240\\u0242\\u0005b2\\u0002\",\r\n    \"\\u0241\\u023e\\u0003\\u0002\\u0002\\u0002\\u0241\\u023f\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0241\\u0240\\u0003\\u0002\\u0002\\u0002\\u0242\\u0243\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0243\\u0244\\u0005h5\\u0002\\u0244_\\u0003\\u0002\\u0002\\u0002\\u0245\\u0248\",\r\n    \"\\u0005<\\u001f\\u0002\\u0246\\u0248\\u0005b2\\u0002\\u0247\\u0245\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0247\\u0246\\u0003\\u0002\\u0002\\u0002\\u0248\\u0249\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0249\\u024a\\u0005|?\\u0002\\u024aa\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u024b\\u0255\\u0005d3\\u0002\\u024c\\u0255\\u0005f4\\u0002\\u024d\\u0255\\u0005\",\r\n    \"h5\\u0002\\u024e\\u0255\\u0005j6\\u0002\\u024f\\u0255\\u0005t;\\u0002\\u0250\\u0255\",\r\n    \"\\u0005v<\\u0002\\u0251\\u0255\\u0005x=\\u0002\\u0252\\u0255\\u0005z>\\u0002\\u0253\",\r\n    \"\\u0255\\u0005\\u0088E\\u0002\\u0254\\u024b\\u0003\\u0002\\u0002\\u0002\\u0254\",\r\n    \"\\u024c\\u0003\\u0002\\u0002\\u0002\\u0254\\u024d\\u0003\\u0002\\u0002\\u0002\\u0254\",\r\n    \"\\u024e\\u0003\\u0002\\u0002\\u0002\\u0254\\u024f\\u0003\\u0002\\u0002\\u0002\\u0254\",\r\n    \"\\u0250\\u0003\\u0002\\u0002\\u0002\\u0254\\u0251\\u0003\\u0002\\u0002\\u0002\\u0254\",\r\n    \"\\u0252\\u0003\\u0002\\u0002\\u0002\\u0254\\u0253\\u0003\\u0002\\u0002\\u0002\\u0255\",\r\n    \"c\\u0003\\u0002\\u0002\\u0002\\u0256\\u0257\\u0007\\'\\u0002\\u0002\\u0257e\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0258\\u0259\\u0007\\u001a\\u0002\\u0002\\u0259\\u025a\\u0005\",\r\n    \"\\u0086D\\u0002\\u025ag\\u0003\\u0002\\u0002\\u0002\\u025b\\u025c\\u0007\\u0018\",\r\n    \"\\u0002\\u0002\\u025c\\u025d\\u0007/\\u0002\\u0002\\u025di\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u025e\\u0260\\u0007\\u000e\\u0002\\u0002\\u025f\\u0261\\u0005l7\\u0002\",\r\n    \"\\u0260\\u025f\\u0003\\u0002\\u0002\\u0002\\u0260\\u0261\\u0003\\u0002\\u0002\\u0002\",\r\n    \"\\u0261\\u0266\\u0003\\u0002\\u0002\\u0002\\u0262\\u0263\\u0007\\n\\u0002\\u0002\",\r\n    \"\\u0263\\u0265\\u0005l7\\u0002\\u0264\\u0262\\u0003\\u0002\\u0002\\u0002\\u0265\",\r\n    \"\\u0268\\u0003\\u0002\\u0002\\u0002\\u0266\\u0264\\u0003\\u0002\\u0002\\u0002\\u0266\",\r\n    \"\\u0267\\u0003\\u0002\\u0002\\u0002\\u0267\\u0269\\u0003\\u0002\\u0002\\u0002\\u0268\",\r\n    \"\\u0266\\u0003\\u0002\\u0002\\u0002\\u0269\\u026a\\u0007\\u000f\\u0002\\u0002\\u026a\",\r\n    \"k\\u0003\\u0002\\u0002\\u0002\\u026b\\u0271\\u0005\\u0082B\\u0002\\u026c\\u0271\",\r\n    \"\\u0005\\u0084C\\u0002\\u026d\\u0271\\u0005n8\\u0002\\u026e\\u0271\\u0005p9\\u0002\",\r\n    \"\\u026f\\u0271\\u0005r:\\u0002\\u0270\\u026b\\u0003\\u0002\\u0002\\u0002\\u0270\",\r\n    \"\\u026c\\u0003\\u0002\\u0002\\u0002\\u0270\\u026d\\u0003\\u0002\\u0002\\u0002\\u0270\",\r\n    \"\\u026e\\u0003\\u0002\\u0002\\u0002\\u0270\\u026f\\u0003\\u0002\\u0002\\u0002\\u0271\",\r\n    \"m\\u0003\\u0002\\u0002\\u0002\\u0272\\u0273\\u0007\\u0016\\u0002\\u0002\\u0273\",\r\n    \"\\u0274\\u0005\\u0086D\\u0002\\u0274o\\u0003\\u0002\\u0002\\u0002\\u0275\\u0276\",\r\n    \"\\u0007\\r\\u0002\\u0002\\u0276\\u0277\\u0005\\u0086D\\u0002\\u0277q\\u0003\\u0002\",\r\n    \"\\u0002\\u0002\\u0278\\u0279\\u0007\\u0018\\u0002\\u0002\\u0279\\u027a\\u0005\\u0086\",\r\n    \"D\\u0002\\u027as\\u0003\\u0002\\u0002\\u0002\\u027b\\u027c\\u0007\\r\\u0002\\u0002\",\r\n    \"\\u027cu\\u0003\\u0002\\u0002\\u0002\\u027d\\u027e\\u0007\\u0017\\u0002\\u0002\",\r\n    \"\\u027ew\\u0003\\u0002\\u0002\\u0002\\u027f\\u0280\\u0007\\u0018\\u0002\\u0002\",\r\n    \"\\u0280y\\u0003\\u0002\\u0002\\u0002\\u0281\\u0282\\u0007\\u0019\\u0002\\u0002\",\r\n    \"\\u0282{\\u0003\\u0002\\u0002\\u0002\\u0283\\u0284\\t\\u0006\\u0002\\u0002\\u0284\",\r\n    \"}\\u0003\\u0002\\u0002\\u0002\\u0285\\u0287\\u0007\\u000e\\u0002\\u0002\\u0286\",\r\n    \"\\u0288\\u0005\\u0080A\\u0002\\u0287\\u0286\\u0003\\u0002\\u0002\\u0002\\u0287\",\r\n    \"\\u0288\\u0003\\u0002\\u0002\\u0002\\u0288\\u028d\\u0003\\u0002\\u0002\\u0002\\u0289\",\r\n    \"\\u028a\\u0007\\n\\u0002\\u0002\\u028a\\u028c\\u0005\\u0080A\\u0002\\u028b\\u0289\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u028c\\u028f\\u0003\\u0002\\u0002\\u0002\\u028d\\u028b\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u028d\\u028e\\u0003\\u0002\\u0002\\u0002\\u028e\\u0290\",\r\n    \"\\u0003\\u0002\\u0002\\u0002\\u028f\\u028d\\u0003\\u0002\\u0002\\u0002\\u0290\\u0291\",\r\n    \"\\u0007\\u000f\\u0002\\u0002\\u0291\\u007f\\u0003\\u0002\\u0002\\u0002\\u0292\\u0295\",\r\n    \"\\u0005\\u0082B\\u0002\\u0293\\u0295\\u0005\\u0084C\\u0002\\u0294\\u0292\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0294\\u0293\\u0003\\u0002\\u0002\\u0002\\u0295\\u0081\\u0003\",\r\n    \"\\u0002\\u0002\\u0002\\u0296\\u0297\\t\\u0007\\u0002\\u0002\\u0297\\u0298\\u0005\",\r\n    \"\\u0086D\\u0002\\u0298\\u0083\\u0003\\u0002\\u0002\\u0002\\u0299\\u029a\\u0005\",\r\n    \"\\u0086D\\u0002\\u029a\\u0085\\u0003\\u0002\\u0002\\u0002\\u029b\\u029c\\u0007\",\r\n    \"0\\u0002\\u0002\\u029c\\u0087\\u0003\\u0002\\u0002\\u0002\\u029d\\u029f\\t\\b\\u0002\",\r\n    \"\\u0002\\u029e\\u02a0\\u0007\\u0016\\u0002\\u0002\\u029f\\u029e\\u0003\\u0002\\u0002\",\r\n    \"\\u0002\\u029f\\u02a0\\u0003\\u0002\\u0002\\u0002\\u02a0\\u0089\\u0003\\u0002\\u0002\",\r\n    \"\\u0002N\\u008e\\u0092\\u0097\\u009c\\u00a2\\u00a6\\u00b1\\u00bd\\u00c4\\u00cd\",\r\n    \"\\u00d3\\u00d7\\u00dd\\u00e4\\u00e9\\u00f0\\u00f3\\u0103\\u010b\\u0117\\u011c\\u0125\",\r\n    \"\\u012b\\u0130\\u0132\\u0137\\u013e\\u0144\\u014b\\u0151\\u015a\\u0160\\u0169\\u016d\",\r\n    \"\\u0172\\u0178\\u017c\\u0182\\u018a\\u018c\\u0192\\u019a\\u01a1\\u01a6\\u01ab\\u01b1\",\r\n    \"\\u01b6\\u01be\\u01c7\\u01d3\\u01d8\\u01e4\\u01f3\\u01fa\\u01fe\\u0202\\u0206\\u020a\",\r\n    \"\\u0212\\u021a\\u021f\\u0222\\u0224\\u022f\\u0235\\u023c\\u0241\\u0247\\u0254\\u0260\",\r\n    \"\\u0266\\u0270\\u0287\\u028d\\u0294\\u029f\"].join(\"\");\r\n\r\n\r\nvar atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\r\n\r\nvar decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });\r\n\r\nvar sharedContextCache = new antlr4.PredictionContextCache();\r\n\r\nvar literalNames = [ null, null, null, null, null, null, \"'_'\", null, null, \r\n                     \"'('\", \"')'\", \"'*'\", \"'['\", \"']'\", \"'{'\", \"'}'\", \"'+'\", \r\n                     \"'?'\", \"'-'\", \"':'\", \"'!'\", \"'.'\", \"'$'\", \"'$$'\", \"'@'\", \r\n                     \"'&'\", null, null, null, null, null, null, null, null, \r\n                     \"'Syllables'\", \"'explicit'\", \"'clear'\" ];\r\n\r\nvar symbolicNames = [ null, \"COMMENT\", \"SEP\", \"CHANGE\", \"CONDITION\", \"EXCLUSION\", \r\n                      \"ANCHOR\", \"NEWLINE\", \"WHITESPACE\", \"O_PAREN\", \"C_PAREN\", \r\n                      \"NULL\", \"MATRIX_START\", \"MATRIX_END\", \"LIST_START\", \r\n                      \"LIST_END\", \"AT_LEAST_ONE\", \"OPTIONAL\", \"HYPHEN\", \r\n                      \"RULE_START\", \"NEGATION\", \"SYLLABLE_BOUNDARY\", \"WORD_BOUNDARY\", \r\n                      \"BETWEEN_WORDS\", \"CLASSREF\", \"INTERSECTION\", \"CLASS_DECL\", \r\n                      \"FEATURE_DECL\", \"SYLLABLE_FEATURE\", \"DIACRITIC\", \"DIA_BEFORE\", \r\n                      \"DIA_FIRST\", \"DIA_FLOATING\", \"SYMBOL\", \"SYLLABLE_DECL\", \r\n                      \"EXPLICIT_SYLLABLES\", \"CLEAR_SYLLABLES\", \"ANY_SYLLABLE\", \r\n                      \"DEROMANIZER\", \"ROMANIZER\", \"ALL_MATCHING\", \"FIRST_MATCHING\", \r\n                      \"PROPAGATE\", \"LITERAL\", \"UNCHANGED\", \"NUMBER\", \"NAME\", \r\n                      \"STR1\", \"STR\" ];\r\n\r\nvar ruleNames =  [ \"lscFile\", \"statement\", \"classDecl\", \"classElement\", \r\n                   \"featureDecl\", \"featureModifier\", \"plusFeature\", \"nullAlias\", \r\n                   \"diacriticDecl\", \"diacriticModifier\", \"symbolDecl\", \"symbolName\", \r\n                   \"syllableDecl\", \"syllablePattern\", \"deromanizer\", \"romanizer\", \r\n                   \"interRomanizer\", \"changeRule\", \"changeRuleModifier\", \r\n                   \"filter\", \"block\", \"blockElement\", \"blockType\", \"expressionList\", \r\n                   \"ruleName\", \"expression\", \"from\", \"to\", \"ruleElement\", \r\n                   \"bounded\", \"group\", \"list\", \"lookaround\", \"sequence\", \r\n                   \"freeElement\", \"compoundEnvironment\", \"condition\", \"exclusion\", \r\n                   \"environmentList\", \"environment\", \"environmentBefore\", \r\n                   \"environmentAfter\", \"intersection\", \"interfixElement\", \r\n                   \"negated\", \"postfix\", \"capture\", \"repeater\", \"simple\", \r\n                   \"anySyllable\", \"classRef\", \"captureRef\", \"fancyMatrix\", \r\n                   \"fancyValue\", \"negatedValue\", \"absentFeature\", \"featureVariable\", \r\n                   \"empty\", \"sylBoundary\", \"boundary\", \"betweenWords\", \"repeaterType\", \r\n                   \"matrix\", \"matrixValue\", \"plusFeatureValue\", \"featureValue\", \r\n                   \"name\", \"text\" ];\r\n\r\nfunction LscParser (input) {\r\n\tantlr4.Parser.call(this, input);\r\n    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\r\n    this.ruleNames = ruleNames;\r\n    this.literalNames = literalNames;\r\n    this.symbolicNames = symbolicNames;\r\n    return this;\r\n}\r\n\r\nLscParser.prototype = Object.create(antlr4.Parser.prototype);\r\nLscParser.prototype.constructor = LscParser;\r\n\r\nObject.defineProperty(LscParser.prototype, \"atn\", {\r\n\tget : function() {\r\n\t\treturn atn;\r\n\t}\r\n});\r\n\r\nLscParser.EOF = antlr4.Token.EOF;\r\nLscParser.COMMENT = 1;\r\nLscParser.SEP = 2;\r\nLscParser.CHANGE = 3;\r\nLscParser.CONDITION = 4;\r\nLscParser.EXCLUSION = 5;\r\nLscParser.ANCHOR = 6;\r\nLscParser.NEWLINE = 7;\r\nLscParser.WHITESPACE = 8;\r\nLscParser.O_PAREN = 9;\r\nLscParser.C_PAREN = 10;\r\nLscParser.NULL = 11;\r\nLscParser.MATRIX_START = 12;\r\nLscParser.MATRIX_END = 13;\r\nLscParser.LIST_START = 14;\r\nLscParser.LIST_END = 15;\r\nLscParser.AT_LEAST_ONE = 16;\r\nLscParser.OPTIONAL = 17;\r\nLscParser.HYPHEN = 18;\r\nLscParser.RULE_START = 19;\r\nLscParser.NEGATION = 20;\r\nLscParser.SYLLABLE_BOUNDARY = 21;\r\nLscParser.WORD_BOUNDARY = 22;\r\nLscParser.BETWEEN_WORDS = 23;\r\nLscParser.CLASSREF = 24;\r\nLscParser.INTERSECTION = 25;\r\nLscParser.CLASS_DECL = 26;\r\nLscParser.FEATURE_DECL = 27;\r\nLscParser.SYLLABLE_FEATURE = 28;\r\nLscParser.DIACRITIC = 29;\r\nLscParser.DIA_BEFORE = 30;\r\nLscParser.DIA_FIRST = 31;\r\nLscParser.DIA_FLOATING = 32;\r\nLscParser.SYMBOL = 33;\r\nLscParser.SYLLABLE_DECL = 34;\r\nLscParser.EXPLICIT_SYLLABLES = 35;\r\nLscParser.CLEAR_SYLLABLES = 36;\r\nLscParser.ANY_SYLLABLE = 37;\r\nLscParser.DEROMANIZER = 38;\r\nLscParser.ROMANIZER = 39;\r\nLscParser.ALL_MATCHING = 40;\r\nLscParser.FIRST_MATCHING = 41;\r\nLscParser.PROPAGATE = 42;\r\nLscParser.LITERAL = 43;\r\nLscParser.UNCHANGED = 44;\r\nLscParser.NUMBER = 45;\r\nLscParser.NAME = 46;\r\nLscParser.STR1 = 47;\r\nLscParser.STR = 48;\r\n\r\nLscParser.RULE_lscFile = 0;\r\nLscParser.RULE_statement = 1;\r\nLscParser.RULE_classDecl = 2;\r\nLscParser.RULE_classElement = 3;\r\nLscParser.RULE_featureDecl = 4;\r\nLscParser.RULE_featureModifier = 5;\r\nLscParser.RULE_plusFeature = 6;\r\nLscParser.RULE_nullAlias = 7;\r\nLscParser.RULE_diacriticDecl = 8;\r\nLscParser.RULE_diacriticModifier = 9;\r\nLscParser.RULE_symbolDecl = 10;\r\nLscParser.RULE_symbolName = 11;\r\nLscParser.RULE_syllableDecl = 12;\r\nLscParser.RULE_syllablePattern = 13;\r\nLscParser.RULE_deromanizer = 14;\r\nLscParser.RULE_romanizer = 15;\r\nLscParser.RULE_interRomanizer = 16;\r\nLscParser.RULE_changeRule = 17;\r\nLscParser.RULE_changeRuleModifier = 18;\r\nLscParser.RULE_filter = 19;\r\nLscParser.RULE_block = 20;\r\nLscParser.RULE_blockElement = 21;\r\nLscParser.RULE_blockType = 22;\r\nLscParser.RULE_expressionList = 23;\r\nLscParser.RULE_ruleName = 24;\r\nLscParser.RULE_expression = 25;\r\nLscParser.RULE_from = 26;\r\nLscParser.RULE_to = 27;\r\nLscParser.RULE_ruleElement = 28;\r\nLscParser.RULE_bounded = 29;\r\nLscParser.RULE_group = 30;\r\nLscParser.RULE_list = 31;\r\nLscParser.RULE_lookaround = 32;\r\nLscParser.RULE_sequence = 33;\r\nLscParser.RULE_freeElement = 34;\r\nLscParser.RULE_compoundEnvironment = 35;\r\nLscParser.RULE_condition = 36;\r\nLscParser.RULE_exclusion = 37;\r\nLscParser.RULE_environmentList = 38;\r\nLscParser.RULE_environment = 39;\r\nLscParser.RULE_environmentBefore = 40;\r\nLscParser.RULE_environmentAfter = 41;\r\nLscParser.RULE_intersection = 42;\r\nLscParser.RULE_interfixElement = 43;\r\nLscParser.RULE_negated = 44;\r\nLscParser.RULE_postfix = 45;\r\nLscParser.RULE_capture = 46;\r\nLscParser.RULE_repeater = 47;\r\nLscParser.RULE_simple = 48;\r\nLscParser.RULE_anySyllable = 49;\r\nLscParser.RULE_classRef = 50;\r\nLscParser.RULE_captureRef = 51;\r\nLscParser.RULE_fancyMatrix = 52;\r\nLscParser.RULE_fancyValue = 53;\r\nLscParser.RULE_negatedValue = 54;\r\nLscParser.RULE_absentFeature = 55;\r\nLscParser.RULE_featureVariable = 56;\r\nLscParser.RULE_empty = 57;\r\nLscParser.RULE_sylBoundary = 58;\r\nLscParser.RULE_boundary = 59;\r\nLscParser.RULE_betweenWords = 60;\r\nLscParser.RULE_repeaterType = 61;\r\nLscParser.RULE_matrix = 62;\r\nLscParser.RULE_matrixValue = 63;\r\nLscParser.RULE_plusFeatureValue = 64;\r\nLscParser.RULE_featureValue = 65;\r\nLscParser.RULE_name = 66;\r\nLscParser.RULE_text = 67;\r\n\r\n\r\nfunction LscFileContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_lscFile;\r\n    return this;\r\n}\r\n\r\nLscFileContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nLscFileContext.prototype.constructor = LscFileContext;\r\n\r\nLscFileContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nLscFileContext.prototype.EOF = function() {\r\n    return this.getToken(LscParser.EOF, 0);\r\n};\r\n\r\nLscFileContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nLscFileContext.prototype.statement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(StatementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(StatementContext,i);\r\n    }\r\n};\r\n\r\nLscFileContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitLscFile(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.LscFileContext = LscFileContext;\r\n\r\nLscParser.prototype.lscFile = function() {\r\n\r\n    var localctx = new LscFileContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 0, LscParser.RULE_lscFile);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.state = 164;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.WHITESPACE:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 136;\r\n            this.match(LscParser.WHITESPACE);\r\n            break;\r\n        case LscParser.EOF:\r\n        case LscParser.NEWLINE:\r\n        case LscParser.CLASS_DECL:\r\n        case LscParser.FEATURE_DECL:\r\n        case LscParser.DIACRITIC:\r\n        case LscParser.SYMBOL:\r\n        case LscParser.SYLLABLE_DECL:\r\n        case LscParser.DEROMANIZER:\r\n        case LscParser.ROMANIZER:\r\n        case LscParser.NAME:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 140;\r\n            this._errHandler.sync(this);\r\n            var _alt = this._interp.adaptivePredict(this._input,0,this._ctx)\r\n            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\r\n                if(_alt===1) {\r\n                    this.state = 137;\r\n                    this.match(LscParser.NEWLINE); \r\n                }\r\n                this.state = 142;\r\n                this._errHandler.sync(this);\r\n                _alt = this._interp.adaptivePredict(this._input,0,this._ctx);\r\n            }\r\n\r\n            this.state = 144;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if(((((_la - 26)) & ~0x1f) == 0 && ((1 << (_la - 26)) & ((1 << (LscParser.CLASS_DECL - 26)) | (1 << (LscParser.FEATURE_DECL - 26)) | (1 << (LscParser.DIACRITIC - 26)) | (1 << (LscParser.SYMBOL - 26)) | (1 << (LscParser.SYLLABLE_DECL - 26)) | (1 << (LscParser.DEROMANIZER - 26)) | (1 << (LscParser.ROMANIZER - 26)) | (1 << (LscParser.NAME - 26)))) !== 0)) {\r\n                this.state = 143;\r\n                this.statement();\r\n            }\r\n\r\n            this.state = 154;\r\n            this._errHandler.sync(this);\r\n            var _alt = this._interp.adaptivePredict(this._input,3,this._ctx)\r\n            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\r\n                if(_alt===1) {\r\n                    this.state = 147; \r\n                    this._errHandler.sync(this);\r\n                    _la = this._input.LA(1);\r\n                    do {\r\n                        this.state = 146;\r\n                        this.match(LscParser.NEWLINE);\r\n                        this.state = 149; \r\n                        this._errHandler.sync(this);\r\n                        _la = this._input.LA(1);\r\n                    } while(_la===LscParser.NEWLINE);\r\n                    this.state = 151;\r\n                    this.statement(); \r\n                }\r\n                this.state = 156;\r\n                this._errHandler.sync(this);\r\n                _alt = this._interp.adaptivePredict(this._input,3,this._ctx);\r\n            }\r\n\r\n            this.state = 160;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.NEWLINE) {\r\n                this.state = 157;\r\n                this.match(LscParser.NEWLINE);\r\n                this.state = 162;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            this.state = 163;\r\n            this.match(LscParser.EOF);\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction StatementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_statement;\r\n    return this;\r\n}\r\n\r\nStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nStatementContext.prototype.constructor = StatementContext;\r\n\r\nStatementContext.prototype.featureDecl = function() {\r\n    return this.getTypedRuleContext(FeatureDeclContext,0);\r\n};\r\n\r\nStatementContext.prototype.diacriticDecl = function() {\r\n    return this.getTypedRuleContext(DiacriticDeclContext,0);\r\n};\r\n\r\nStatementContext.prototype.symbolDecl = function() {\r\n    return this.getTypedRuleContext(SymbolDeclContext,0);\r\n};\r\n\r\nStatementContext.prototype.classDecl = function() {\r\n    return this.getTypedRuleContext(ClassDeclContext,0);\r\n};\r\n\r\nStatementContext.prototype.syllableDecl = function() {\r\n    return this.getTypedRuleContext(SyllableDeclContext,0);\r\n};\r\n\r\nStatementContext.prototype.deromanizer = function() {\r\n    return this.getTypedRuleContext(DeromanizerContext,0);\r\n};\r\n\r\nStatementContext.prototype.changeRule = function() {\r\n    return this.getTypedRuleContext(ChangeRuleContext,0);\r\n};\r\n\r\nStatementContext.prototype.interRomanizer = function() {\r\n    return this.getTypedRuleContext(InterRomanizerContext,0);\r\n};\r\n\r\nStatementContext.prototype.romanizer = function() {\r\n    return this.getTypedRuleContext(RomanizerContext,0);\r\n};\r\n\r\nStatementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitStatement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.StatementContext = StatementContext;\r\n\r\nLscParser.prototype.statement = function() {\r\n\r\n    var localctx = new StatementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 2, LscParser.RULE_statement);\r\n    try {\r\n        this.state = 175;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 166;\r\n            this.featureDecl();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 167;\r\n            this.diacriticDecl();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 168;\r\n            this.symbolDecl();\r\n            break;\r\n\r\n        case 4:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 169;\r\n            this.classDecl();\r\n            break;\r\n\r\n        case 5:\r\n            this.enterOuterAlt(localctx, 5);\r\n            this.state = 170;\r\n            this.syllableDecl();\r\n            break;\r\n\r\n        case 6:\r\n            this.enterOuterAlt(localctx, 6);\r\n            this.state = 171;\r\n            this.deromanizer();\r\n            break;\r\n\r\n        case 7:\r\n            this.enterOuterAlt(localctx, 7);\r\n            this.state = 172;\r\n            this.changeRule();\r\n            break;\r\n\r\n        case 8:\r\n            this.enterOuterAlt(localctx, 8);\r\n            this.state = 173;\r\n            this.interRomanizer();\r\n            break;\r\n\r\n        case 9:\r\n            this.enterOuterAlt(localctx, 9);\r\n            this.state = 174;\r\n            this.romanizer();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ClassDeclContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_classDecl;\r\n    return this;\r\n}\r\n\r\nClassDeclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nClassDeclContext.prototype.constructor = ClassDeclContext;\r\n\r\nClassDeclContext.prototype.CLASS_DECL = function() {\r\n    return this.getToken(LscParser.CLASS_DECL, 0);\r\n};\r\n\r\nClassDeclContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nClassDeclContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nClassDeclContext.prototype.LIST_START = function() {\r\n    return this.getToken(LscParser.LIST_START, 0);\r\n};\r\n\r\nClassDeclContext.prototype.classElement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(ClassElementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(ClassElementContext,i);\r\n    }\r\n};\r\n\r\nClassDeclContext.prototype.LIST_END = function() {\r\n    return this.getToken(LscParser.LIST_END, 0);\r\n};\r\n\r\nClassDeclContext.prototype.SEP = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.SEP);\r\n    } else {\r\n        return this.getToken(LscParser.SEP, i);\r\n    }\r\n};\r\n\r\n\r\nClassDeclContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitClassDecl(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ClassDeclContext = ClassDeclContext;\r\n\r\nLscParser.prototype.classDecl = function() {\r\n\r\n    var localctx = new ClassDeclContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 4, LscParser.RULE_classDecl);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 177;\r\n        this.match(LscParser.CLASS_DECL);\r\n        this.state = 178;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 179;\r\n        this.name();\r\n        this.state = 180;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 181;\r\n        this.match(LscParser.LIST_START);\r\n        this.state = 182;\r\n        this.classElement();\r\n        this.state = 187;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.SEP) {\r\n            this.state = 183;\r\n            this.match(LscParser.SEP);\r\n            this.state = 184;\r\n            this.classElement();\r\n            this.state = 189;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 190;\r\n        this.match(LscParser.LIST_END);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ClassElementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_classElement;\r\n    return this;\r\n}\r\n\r\nClassElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nClassElementContext.prototype.constructor = ClassElementContext;\r\n\r\nClassElementContext.prototype.classRef = function() {\r\n    return this.getTypedRuleContext(ClassRefContext,0);\r\n};\r\n\r\nClassElementContext.prototype.text = function() {\r\n    return this.getTypedRuleContext(TextContext,0);\r\n};\r\n\r\nClassElementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitClassElement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ClassElementContext = ClassElementContext;\r\n\r\nLscParser.prototype.classElement = function() {\r\n\r\n    var localctx = new ClassElementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 6, LscParser.RULE_classElement);\r\n    try {\r\n        this.state = 194;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.CLASSREF:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 192;\r\n            this.classRef();\r\n            break;\r\n        case LscParser.NAME:\r\n        case LscParser.STR1:\r\n        case LscParser.STR:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 193;\r\n            this.text();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FeatureDeclContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_featureDecl;\r\n    return this;\r\n}\r\n\r\nFeatureDeclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFeatureDeclContext.prototype.constructor = FeatureDeclContext;\r\n\r\nFeatureDeclContext.prototype.FEATURE_DECL = function() {\r\n    return this.getToken(LscParser.FEATURE_DECL, 0);\r\n};\r\n\r\nFeatureDeclContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nFeatureDeclContext.prototype.plusFeature = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(PlusFeatureContext);\r\n    } else {\r\n        return this.getTypedRuleContext(PlusFeatureContext,i);\r\n    }\r\n};\r\n\r\nFeatureDeclContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nFeatureDeclContext.prototype.O_PAREN = function() {\r\n    return this.getToken(LscParser.O_PAREN, 0);\r\n};\r\n\r\nFeatureDeclContext.prototype.featureValue = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(FeatureValueContext);\r\n    } else {\r\n        return this.getTypedRuleContext(FeatureValueContext,i);\r\n    }\r\n};\r\n\r\nFeatureDeclContext.prototype.C_PAREN = function() {\r\n    return this.getToken(LscParser.C_PAREN, 0);\r\n};\r\n\r\nFeatureDeclContext.prototype.SEP = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.SEP);\r\n    } else {\r\n        return this.getToken(LscParser.SEP, i);\r\n    }\r\n};\r\n\r\n\r\nFeatureDeclContext.prototype.featureModifier = function() {\r\n    return this.getTypedRuleContext(FeatureModifierContext,0);\r\n};\r\n\r\nFeatureDeclContext.prototype.nullAlias = function() {\r\n    return this.getTypedRuleContext(NullAliasContext,0);\r\n};\r\n\r\nFeatureDeclContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFeatureDecl(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FeatureDeclContext = FeatureDeclContext;\r\n\r\nLscParser.prototype.featureDecl = function() {\r\n\r\n    var localctx = new FeatureDeclContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 8, LscParser.RULE_featureDecl);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 196;\r\n        this.match(LscParser.FEATURE_DECL);\r\n        this.state = 197;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 231;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,14,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.state = 198;\r\n            this.plusFeature();\r\n            this.state = 203;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.SEP) {\r\n                this.state = 199;\r\n                this.match(LscParser.SEP);\r\n                this.state = 200;\r\n                this.plusFeature();\r\n                this.state = 205;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            this.state = 209;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if(_la===LscParser.SYLLABLE_FEATURE) {\r\n                this.state = 206;\r\n                this.featureModifier();\r\n                this.state = 207;\r\n                this.match(LscParser.WHITESPACE);\r\n            }\r\n\r\n            this.state = 211;\r\n            this.name();\r\n            this.state = 213;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if(_la===LscParser.WHITESPACE) {\r\n                this.state = 212;\r\n                this.match(LscParser.WHITESPACE);\r\n            }\r\n\r\n            this.state = 215;\r\n            this.match(LscParser.O_PAREN);\r\n            this.state = 219;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if(_la===LscParser.NULL) {\r\n                this.state = 216;\r\n                this.nullAlias();\r\n                this.state = 217;\r\n                this.match(LscParser.SEP);\r\n            }\r\n\r\n            this.state = 221;\r\n            this.featureValue();\r\n            this.state = 226;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.SEP) {\r\n                this.state = 222;\r\n                this.match(LscParser.SEP);\r\n                this.state = 223;\r\n                this.featureValue();\r\n                this.state = 228;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            this.state = 229;\r\n            this.match(LscParser.C_PAREN);\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FeatureModifierContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_featureModifier;\r\n    return this;\r\n}\r\n\r\nFeatureModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFeatureModifierContext.prototype.constructor = FeatureModifierContext;\r\n\r\nFeatureModifierContext.prototype.SYLLABLE_FEATURE = function() {\r\n    return this.getToken(LscParser.SYLLABLE_FEATURE, 0);\r\n};\r\n\r\nFeatureModifierContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFeatureModifier(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FeatureModifierContext = FeatureModifierContext;\r\n\r\nLscParser.prototype.featureModifier = function() {\r\n\r\n    var localctx = new FeatureModifierContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 10, LscParser.RULE_featureModifier);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 233;\r\n        this.match(LscParser.SYLLABLE_FEATURE);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction PlusFeatureContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_plusFeature;\r\n    return this;\r\n}\r\n\r\nPlusFeatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nPlusFeatureContext.prototype.constructor = PlusFeatureContext;\r\n\r\nPlusFeatureContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nPlusFeatureContext.prototype.featureModifier = function() {\r\n    return this.getTypedRuleContext(FeatureModifierContext,0);\r\n};\r\n\r\nPlusFeatureContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nPlusFeatureContext.prototype.AT_LEAST_ONE = function() {\r\n    return this.getToken(LscParser.AT_LEAST_ONE, 0);\r\n};\r\n\r\nPlusFeatureContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitPlusFeature(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.PlusFeatureContext = PlusFeatureContext;\r\n\r\nLscParser.prototype.plusFeature = function() {\r\n\r\n    var localctx = new PlusFeatureContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 12, LscParser.RULE_plusFeature);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 238;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.SYLLABLE_FEATURE) {\r\n            this.state = 235;\r\n            this.featureModifier();\r\n            this.state = 236;\r\n            this.match(LscParser.WHITESPACE);\r\n        }\r\n\r\n        this.state = 241;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.AT_LEAST_ONE) {\r\n            this.state = 240;\r\n            this.match(LscParser.AT_LEAST_ONE);\r\n        }\r\n\r\n        this.state = 243;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction NullAliasContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_nullAlias;\r\n    return this;\r\n}\r\n\r\nNullAliasContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nNullAliasContext.prototype.constructor = NullAliasContext;\r\n\r\nNullAliasContext.prototype.NULL = function() {\r\n    return this.getToken(LscParser.NULL, 0);\r\n};\r\n\r\nNullAliasContext.prototype.featureValue = function() {\r\n    return this.getTypedRuleContext(FeatureValueContext,0);\r\n};\r\n\r\nNullAliasContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitNullAlias(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.NullAliasContext = NullAliasContext;\r\n\r\nLscParser.prototype.nullAlias = function() {\r\n\r\n    var localctx = new NullAliasContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 14, LscParser.RULE_nullAlias);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 245;\r\n        this.match(LscParser.NULL);\r\n        this.state = 246;\r\n        this.featureValue();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction DiacriticDeclContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_diacriticDecl;\r\n    return this;\r\n}\r\n\r\nDiacriticDeclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nDiacriticDeclContext.prototype.constructor = DiacriticDeclContext;\r\n\r\nDiacriticDeclContext.prototype.DIACRITIC = function() {\r\n    return this.getToken(LscParser.DIACRITIC, 0);\r\n};\r\n\r\nDiacriticDeclContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nDiacriticDeclContext.prototype.text = function() {\r\n    return this.getTypedRuleContext(TextContext,0);\r\n};\r\n\r\nDiacriticDeclContext.prototype.matrix = function() {\r\n    return this.getTypedRuleContext(MatrixContext,0);\r\n};\r\n\r\nDiacriticDeclContext.prototype.diacriticModifier = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(DiacriticModifierContext);\r\n    } else {\r\n        return this.getTypedRuleContext(DiacriticModifierContext,i);\r\n    }\r\n};\r\n\r\nDiacriticDeclContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitDiacriticDecl(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.DiacriticDeclContext = DiacriticDeclContext;\r\n\r\nLscParser.prototype.diacriticDecl = function() {\r\n\r\n    var localctx = new DiacriticDeclContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 16, LscParser.RULE_diacriticDecl);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 248;\r\n        this.match(LscParser.DIACRITIC);\r\n        this.state = 249;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 250;\r\n        this.text();\r\n        this.state = 251;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 257;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(((((_la - 30)) & ~0x1f) == 0 && ((1 << (_la - 30)) & ((1 << (LscParser.DIA_BEFORE - 30)) | (1 << (LscParser.DIA_FIRST - 30)) | (1 << (LscParser.DIA_FLOATING - 30)))) !== 0)) {\r\n            this.state = 252;\r\n            this.diacriticModifier();\r\n            this.state = 253;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 259;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 260;\r\n        this.matrix();\r\n        this.state = 265;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.WHITESPACE) {\r\n            this.state = 261;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 262;\r\n            this.diacriticModifier();\r\n            this.state = 267;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction DiacriticModifierContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_diacriticModifier;\r\n    return this;\r\n}\r\n\r\nDiacriticModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nDiacriticModifierContext.prototype.constructor = DiacriticModifierContext;\r\n\r\nDiacriticModifierContext.prototype.DIA_BEFORE = function() {\r\n    return this.getToken(LscParser.DIA_BEFORE, 0);\r\n};\r\n\r\nDiacriticModifierContext.prototype.DIA_FIRST = function() {\r\n    return this.getToken(LscParser.DIA_FIRST, 0);\r\n};\r\n\r\nDiacriticModifierContext.prototype.DIA_FLOATING = function() {\r\n    return this.getToken(LscParser.DIA_FLOATING, 0);\r\n};\r\n\r\nDiacriticModifierContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitDiacriticModifier(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.DiacriticModifierContext = DiacriticModifierContext;\r\n\r\nLscParser.prototype.diacriticModifier = function() {\r\n\r\n    var localctx = new DiacriticModifierContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 18, LscParser.RULE_diacriticModifier);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 268;\r\n        _la = this._input.LA(1);\r\n        if(!(((((_la - 30)) & ~0x1f) == 0 && ((1 << (_la - 30)) & ((1 << (LscParser.DIA_BEFORE - 30)) | (1 << (LscParser.DIA_FIRST - 30)) | (1 << (LscParser.DIA_FLOATING - 30)))) !== 0))) {\r\n        this._errHandler.recoverInline(this);\r\n        }\r\n        else {\r\n        \tthis._errHandler.reportMatch(this);\r\n            this.consume();\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SymbolDeclContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_symbolDecl;\r\n    return this;\r\n}\r\n\r\nSymbolDeclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSymbolDeclContext.prototype.constructor = SymbolDeclContext;\r\n\r\nSymbolDeclContext.prototype.SYMBOL = function() {\r\n    return this.getToken(LscParser.SYMBOL, 0);\r\n};\r\n\r\nSymbolDeclContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nSymbolDeclContext.prototype.symbolName = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(SymbolNameContext);\r\n    } else {\r\n        return this.getTypedRuleContext(SymbolNameContext,i);\r\n    }\r\n};\r\n\r\nSymbolDeclContext.prototype.matrix = function() {\r\n    return this.getTypedRuleContext(MatrixContext,0);\r\n};\r\n\r\nSymbolDeclContext.prototype.SEP = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.SEP);\r\n    } else {\r\n        return this.getToken(LscParser.SEP, i);\r\n    }\r\n};\r\n\r\n\r\nSymbolDeclContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSymbolDecl(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SymbolDeclContext = SymbolDeclContext;\r\n\r\nLscParser.prototype.symbolDecl = function() {\r\n\r\n    var localctx = new SymbolDeclContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 20, LscParser.RULE_symbolDecl);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 270;\r\n        this.match(LscParser.SYMBOL);\r\n        this.state = 271;\r\n        this.match(LscParser.WHITESPACE);\r\n        this.state = 272;\r\n        this.symbolName();\r\n        this.state = 282;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.EOF:\r\n        case LscParser.SEP:\r\n        case LscParser.NEWLINE:\r\n            this.state = 277;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.SEP) {\r\n                this.state = 273;\r\n                this.match(LscParser.SEP);\r\n                this.state = 274;\r\n                this.symbolName();\r\n                this.state = 279;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            break;\r\n        case LscParser.WHITESPACE:\r\n            this.state = 280;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 281;\r\n            this.matrix();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SymbolNameContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_symbolName;\r\n    return this;\r\n}\r\n\r\nSymbolNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSymbolNameContext.prototype.constructor = SymbolNameContext;\r\n\r\nSymbolNameContext.prototype.text = function() {\r\n    return this.getTypedRuleContext(TextContext,0);\r\n};\r\n\r\nSymbolNameContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSymbolName(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SymbolNameContext = SymbolNameContext;\r\n\r\nLscParser.prototype.symbolName = function() {\r\n\r\n    var localctx = new SymbolNameContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 22, LscParser.RULE_symbolName);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 284;\r\n        this.text();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SyllableDeclContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_syllableDecl;\r\n    return this;\r\n}\r\n\r\nSyllableDeclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSyllableDeclContext.prototype.constructor = SyllableDeclContext;\r\n\r\nSyllableDeclContext.prototype.SYLLABLE_DECL = function() {\r\n    return this.getToken(LscParser.SYLLABLE_DECL, 0);\r\n};\r\n\r\nSyllableDeclContext.prototype.RULE_START = function() {\r\n    return this.getToken(LscParser.RULE_START, 0);\r\n};\r\n\r\nSyllableDeclContext.prototype.EXPLICIT_SYLLABLES = function() {\r\n    return this.getToken(LscParser.EXPLICIT_SYLLABLES, 0);\r\n};\r\n\r\nSyllableDeclContext.prototype.CLEAR_SYLLABLES = function() {\r\n    return this.getToken(LscParser.CLEAR_SYLLABLES, 0);\r\n};\r\n\r\nSyllableDeclContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nSyllableDeclContext.prototype.syllablePattern = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(SyllablePatternContext);\r\n    } else {\r\n        return this.getTypedRuleContext(SyllablePatternContext,i);\r\n    }\r\n};\r\n\r\nSyllableDeclContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSyllableDecl(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SyllableDeclContext = SyllableDeclContext;\r\n\r\nLscParser.prototype.syllableDecl = function() {\r\n\r\n    var localctx = new SyllableDeclContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 24, LscParser.RULE_syllableDecl);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 286;\r\n        this.match(LscParser.SYLLABLE_DECL);\r\n        this.state = 287;\r\n        this.match(LscParser.RULE_START);\r\n        this.state = 304;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,24,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.state = 289; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            do {\r\n                this.state = 288;\r\n                this.match(LscParser.NEWLINE);\r\n                this.state = 291; \r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            } while(_la===LscParser.NEWLINE);\r\n            this.state = 293;\r\n            _la = this._input.LA(1);\r\n            if(!(_la===LscParser.EXPLICIT_SYLLABLES || _la===LscParser.CLEAR_SYLLABLES)) {\r\n            this._errHandler.recoverInline(this);\r\n            }\r\n            else {\r\n            \tthis._errHandler.reportMatch(this);\r\n                this.consume();\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            this.state = 300; \r\n            this._errHandler.sync(this);\r\n            var _alt = 1;\r\n            do {\r\n            \tswitch (_alt) {\r\n            \tcase 1:\r\n            \t\tthis.state = 295; \r\n            \t\tthis._errHandler.sync(this);\r\n            \t\t_la = this._input.LA(1);\r\n            \t\tdo {\r\n            \t\t    this.state = 294;\r\n            \t\t    this.match(LscParser.NEWLINE);\r\n            \t\t    this.state = 297; \r\n            \t\t    this._errHandler.sync(this);\r\n            \t\t    _la = this._input.LA(1);\r\n            \t\t} while(_la===LscParser.NEWLINE);\r\n            \t\tthis.state = 299;\r\n            \t\tthis.syllablePattern();\r\n            \t\tbreak;\r\n            \tdefault:\r\n            \t\tthrow new antlr4.error.NoViableAltException(this);\r\n            \t}\r\n            \tthis.state = 302; \r\n            \tthis._errHandler.sync(this);\r\n            \t_alt = this._interp.adaptivePredict(this._input,23, this._ctx);\r\n            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SyllablePatternContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_syllablePattern;\r\n    return this;\r\n}\r\n\r\nSyllablePatternContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSyllablePatternContext.prototype.constructor = SyllablePatternContext;\r\n\r\nSyllablePatternContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nSyllablePatternContext.prototype.compoundEnvironment = function() {\r\n    return this.getTypedRuleContext(CompoundEnvironmentContext,0);\r\n};\r\n\r\nSyllablePatternContext.prototype.CHANGE = function() {\r\n    return this.getToken(LscParser.CHANGE, 0);\r\n};\r\n\r\nSyllablePatternContext.prototype.matrix = function() {\r\n    return this.getTypedRuleContext(MatrixContext,0);\r\n};\r\n\r\nSyllablePatternContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSyllablePattern(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SyllablePatternContext = SyllablePatternContext;\r\n\r\nLscParser.prototype.syllablePattern = function() {\r\n\r\n    var localctx = new SyllablePatternContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 26, LscParser.RULE_syllablePattern);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 306;\r\n        this.ruleElement();\r\n        this.state = 309;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.CHANGE) {\r\n            this.state = 307;\r\n            this.match(LscParser.CHANGE);\r\n            this.state = 308;\r\n            this.matrix();\r\n        }\r\n\r\n        this.state = 311;\r\n        this.compoundEnvironment();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction DeromanizerContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_deromanizer;\r\n    return this;\r\n}\r\n\r\nDeromanizerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nDeromanizerContext.prototype.constructor = DeromanizerContext;\r\n\r\nDeromanizerContext.prototype.DEROMANIZER = function() {\r\n    return this.getToken(LscParser.DEROMANIZER, 0);\r\n};\r\n\r\nDeromanizerContext.prototype.RULE_START = function() {\r\n    return this.getToken(LscParser.RULE_START, 0);\r\n};\r\n\r\nDeromanizerContext.prototype.block = function() {\r\n    return this.getTypedRuleContext(BlockContext,0);\r\n};\r\n\r\nDeromanizerContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nDeromanizerContext.prototype.LITERAL = function() {\r\n    return this.getToken(LscParser.LITERAL, 0);\r\n};\r\n\r\nDeromanizerContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nDeromanizerContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitDeromanizer(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.DeromanizerContext = DeromanizerContext;\r\n\r\nLscParser.prototype.deromanizer = function() {\r\n\r\n    var localctx = new DeromanizerContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 28, LscParser.RULE_deromanizer);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 313;\r\n        this.match(LscParser.DEROMANIZER);\r\n        this.state = 316;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.WHITESPACE) {\r\n            this.state = 314;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 315;\r\n            this.match(LscParser.LITERAL);\r\n        }\r\n\r\n        this.state = 318;\r\n        this.match(LscParser.RULE_START);\r\n        this.state = 320; \r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        do {\r\n            this.state = 319;\r\n            this.match(LscParser.NEWLINE);\r\n            this.state = 322; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        } while(_la===LscParser.NEWLINE);\r\n        this.state = 324;\r\n        this.block();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction RomanizerContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_romanizer;\r\n    return this;\r\n}\r\n\r\nRomanizerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nRomanizerContext.prototype.constructor = RomanizerContext;\r\n\r\nRomanizerContext.prototype.ROMANIZER = function() {\r\n    return this.getToken(LscParser.ROMANIZER, 0);\r\n};\r\n\r\nRomanizerContext.prototype.RULE_START = function() {\r\n    return this.getToken(LscParser.RULE_START, 0);\r\n};\r\n\r\nRomanizerContext.prototype.block = function() {\r\n    return this.getTypedRuleContext(BlockContext,0);\r\n};\r\n\r\nRomanizerContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nRomanizerContext.prototype.LITERAL = function() {\r\n    return this.getToken(LscParser.LITERAL, 0);\r\n};\r\n\r\nRomanizerContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nRomanizerContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitRomanizer(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.RomanizerContext = RomanizerContext;\r\n\r\nLscParser.prototype.romanizer = function() {\r\n\r\n    var localctx = new RomanizerContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 30, LscParser.RULE_romanizer);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 326;\r\n        this.match(LscParser.ROMANIZER);\r\n        this.state = 329;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.WHITESPACE) {\r\n            this.state = 327;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 328;\r\n            this.match(LscParser.LITERAL);\r\n        }\r\n\r\n        this.state = 331;\r\n        this.match(LscParser.RULE_START);\r\n        this.state = 333; \r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        do {\r\n            this.state = 332;\r\n            this.match(LscParser.NEWLINE);\r\n            this.state = 335; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        } while(_la===LscParser.NEWLINE);\r\n        this.state = 337;\r\n        this.block();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction InterRomanizerContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_interRomanizer;\r\n    return this;\r\n}\r\n\r\nInterRomanizerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nInterRomanizerContext.prototype.constructor = InterRomanizerContext;\r\n\r\nInterRomanizerContext.prototype.ROMANIZER = function() {\r\n    return this.getToken(LscParser.ROMANIZER, 0);\r\n};\r\n\r\nInterRomanizerContext.prototype.HYPHEN = function() {\r\n    return this.getToken(LscParser.HYPHEN, 0);\r\n};\r\n\r\nInterRomanizerContext.prototype.ruleName = function() {\r\n    return this.getTypedRuleContext(RuleNameContext,0);\r\n};\r\n\r\nInterRomanizerContext.prototype.RULE_START = function() {\r\n    return this.getToken(LscParser.RULE_START, 0);\r\n};\r\n\r\nInterRomanizerContext.prototype.block = function() {\r\n    return this.getTypedRuleContext(BlockContext,0);\r\n};\r\n\r\nInterRomanizerContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nInterRomanizerContext.prototype.LITERAL = function() {\r\n    return this.getToken(LscParser.LITERAL, 0);\r\n};\r\n\r\nInterRomanizerContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nInterRomanizerContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitInterRomanizer(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.InterRomanizerContext = InterRomanizerContext;\r\n\r\nLscParser.prototype.interRomanizer = function() {\r\n\r\n    var localctx = new InterRomanizerContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 32, LscParser.RULE_interRomanizer);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 339;\r\n        this.match(LscParser.ROMANIZER);\r\n        this.state = 340;\r\n        this.match(LscParser.HYPHEN);\r\n        this.state = 341;\r\n        this.ruleName();\r\n        this.state = 344;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.WHITESPACE) {\r\n            this.state = 342;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 343;\r\n            this.match(LscParser.LITERAL);\r\n        }\r\n\r\n        this.state = 346;\r\n        this.match(LscParser.RULE_START);\r\n        this.state = 348; \r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        do {\r\n            this.state = 347;\r\n            this.match(LscParser.NEWLINE);\r\n            this.state = 350; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        } while(_la===LscParser.NEWLINE);\r\n        this.state = 352;\r\n        this.block();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ChangeRuleContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_changeRule;\r\n    return this;\r\n}\r\n\r\nChangeRuleContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nChangeRuleContext.prototype.constructor = ChangeRuleContext;\r\n\r\nChangeRuleContext.prototype.ruleName = function() {\r\n    return this.getTypedRuleContext(RuleNameContext,0);\r\n};\r\n\r\nChangeRuleContext.prototype.block = function() {\r\n    return this.getTypedRuleContext(BlockContext,0);\r\n};\r\n\r\nChangeRuleContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nChangeRuleContext.prototype.changeRuleModifier = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(ChangeRuleModifierContext);\r\n    } else {\r\n        return this.getTypedRuleContext(ChangeRuleModifierContext,i);\r\n    }\r\n};\r\n\r\nChangeRuleContext.prototype.RULE_START = function() {\r\n    return this.getToken(LscParser.RULE_START, 0);\r\n};\r\n\r\nChangeRuleContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nChangeRuleContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitChangeRule(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ChangeRuleContext = ChangeRuleContext;\r\n\r\nLscParser.prototype.changeRule = function() {\r\n\r\n    var localctx = new ChangeRuleContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 34, LscParser.RULE_changeRule);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 354;\r\n        this.ruleName();\r\n        this.state = 359;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.WHITESPACE) {\r\n            this.state = 355;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 356;\r\n            this.changeRuleModifier();\r\n            this.state = 361;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 363;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.RULE_START) {\r\n            this.state = 362;\r\n            this.match(LscParser.RULE_START);\r\n        }\r\n\r\n        this.state = 366; \r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        do {\r\n            this.state = 365;\r\n            this.match(LscParser.NEWLINE);\r\n            this.state = 368; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        } while(_la===LscParser.NEWLINE);\r\n        this.state = 370;\r\n        this.block();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ChangeRuleModifierContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_changeRuleModifier;\r\n    return this;\r\n}\r\n\r\nChangeRuleModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nChangeRuleModifierContext.prototype.constructor = ChangeRuleModifierContext;\r\n\r\nChangeRuleModifierContext.prototype.filter = function() {\r\n    return this.getTypedRuleContext(FilterContext,0);\r\n};\r\n\r\nChangeRuleModifierContext.prototype.PROPAGATE = function() {\r\n    return this.getToken(LscParser.PROPAGATE, 0);\r\n};\r\n\r\nChangeRuleModifierContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitChangeRuleModifier(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ChangeRuleModifierContext = ChangeRuleModifierContext;\r\n\r\nLscParser.prototype.changeRuleModifier = function() {\r\n\r\n    var localctx = new ChangeRuleModifierContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 36, LscParser.RULE_changeRuleModifier);\r\n    try {\r\n        this.state = 374;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.MATRIX_START:\r\n        case LscParser.CLASSREF:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 372;\r\n            this.filter();\r\n            break;\r\n        case LscParser.PROPAGATE:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 373;\r\n            this.match(LscParser.PROPAGATE);\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FilterContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_filter;\r\n    return this;\r\n}\r\n\r\nFilterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFilterContext.prototype.constructor = FilterContext;\r\n\r\nFilterContext.prototype.classRef = function() {\r\n    return this.getTypedRuleContext(ClassRefContext,0);\r\n};\r\n\r\nFilterContext.prototype.fancyMatrix = function() {\r\n    return this.getTypedRuleContext(FancyMatrixContext,0);\r\n};\r\n\r\nFilterContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFilter(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FilterContext = FilterContext;\r\n\r\nLscParser.prototype.filter = function() {\r\n\r\n    var localctx = new FilterContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 38, LscParser.RULE_filter);\r\n    try {\r\n        this.state = 378;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.CLASSREF:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 376;\r\n            this.classRef();\r\n            break;\r\n        case LscParser.MATRIX_START:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 377;\r\n            this.fancyMatrix();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BlockContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_block;\r\n    return this;\r\n}\r\n\r\nBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBlockContext.prototype.constructor = BlockContext;\r\n\r\nBlockContext.prototype.blockElement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(BlockElementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(BlockElementContext,i);\r\n    }\r\n};\r\n\r\nBlockContext.prototype.blockType = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(BlockTypeContext);\r\n    } else {\r\n        return this.getTypedRuleContext(BlockTypeContext,i);\r\n    }\r\n};\r\n\r\nBlockContext.prototype.RULE_START = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.RULE_START);\r\n    } else {\r\n        return this.getToken(LscParser.RULE_START, i);\r\n    }\r\n};\r\n\r\n\r\nBlockContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nBlockContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nBlockContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBlock(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BlockContext = BlockContext;\r\n\r\nLscParser.prototype.block = function() {\r\n\r\n    var localctx = new BlockContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 40, LscParser.RULE_block);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 380;\r\n        this.blockElement();\r\n        this.state = 400;\r\n        this._errHandler.sync(this);\r\n        var _alt = this._interp.adaptivePredict(this._input,40,this._ctx)\r\n        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\r\n            if(_alt===1) {\r\n                this.state = 382; \r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n                do {\r\n                    this.state = 381;\r\n                    this.match(LscParser.NEWLINE);\r\n                    this.state = 384; \r\n                    this._errHandler.sync(this);\r\n                    _la = this._input.LA(1);\r\n                } while(_la===LscParser.NEWLINE);\r\n                this.state = 386;\r\n                this.blockType();\r\n                this.state = 387;\r\n                this.match(LscParser.RULE_START);\r\n                this.state = 394;\r\n                this._errHandler.sync(this);\r\n                switch(this._input.LA(1)) {\r\n                case LscParser.WHITESPACE:\r\n                    this.state = 388;\r\n                    this.match(LscParser.WHITESPACE);\r\n                    break;\r\n                case LscParser.NEWLINE:\r\n                    this.state = 390; \r\n                    this._errHandler.sync(this);\r\n                    _la = this._input.LA(1);\r\n                    do {\r\n                        this.state = 389;\r\n                        this.match(LscParser.NEWLINE);\r\n                        this.state = 392; \r\n                        this._errHandler.sync(this);\r\n                        _la = this._input.LA(1);\r\n                    } while(_la===LscParser.NEWLINE);\r\n                    break;\r\n                default:\r\n                    throw new antlr4.error.NoViableAltException(this);\r\n                }\r\n                this.state = 396;\r\n                this.blockElement(); \r\n            }\r\n            this.state = 402;\r\n            this._errHandler.sync(this);\r\n            _alt = this._interp.adaptivePredict(this._input,40,this._ctx);\r\n        }\r\n\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BlockElementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_blockElement;\r\n    return this;\r\n}\r\n\r\nBlockElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBlockElementContext.prototype.constructor = BlockElementContext;\r\n\r\nBlockElementContext.prototype.expressionList = function() {\r\n    return this.getTypedRuleContext(ExpressionListContext,0);\r\n};\r\n\r\nBlockElementContext.prototype.O_PAREN = function() {\r\n    return this.getToken(LscParser.O_PAREN, 0);\r\n};\r\n\r\nBlockElementContext.prototype.block = function() {\r\n    return this.getTypedRuleContext(BlockContext,0);\r\n};\r\n\r\nBlockElementContext.prototype.C_PAREN = function() {\r\n    return this.getToken(LscParser.C_PAREN, 0);\r\n};\r\n\r\nBlockElementContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nBlockElementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBlockElement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BlockElementContext = BlockElementContext;\r\n\r\nLscParser.prototype.blockElement = function() {\r\n\r\n    var localctx = new BlockElementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 42, LscParser.RULE_blockElement);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.state = 420;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,43,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 403;\r\n            this.expressionList();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 404;\r\n            this.match(LscParser.O_PAREN);\r\n            this.state = 408;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.NEWLINE) {\r\n                this.state = 405;\r\n                this.match(LscParser.NEWLINE);\r\n                this.state = 410;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            this.state = 411;\r\n            this.block();\r\n            this.state = 415;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            while(_la===LscParser.NEWLINE) {\r\n                this.state = 412;\r\n                this.match(LscParser.NEWLINE);\r\n                this.state = 417;\r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n            }\r\n            this.state = 418;\r\n            this.match(LscParser.C_PAREN);\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BlockTypeContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_blockType;\r\n    return this;\r\n}\r\n\r\nBlockTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBlockTypeContext.prototype.constructor = BlockTypeContext;\r\n\r\nBlockTypeContext.prototype.ALL_MATCHING = function() {\r\n    return this.getToken(LscParser.ALL_MATCHING, 0);\r\n};\r\n\r\nBlockTypeContext.prototype.FIRST_MATCHING = function() {\r\n    return this.getToken(LscParser.FIRST_MATCHING, 0);\r\n};\r\n\r\nBlockTypeContext.prototype.WHITESPACE = function() {\r\n    return this.getToken(LscParser.WHITESPACE, 0);\r\n};\r\n\r\nBlockTypeContext.prototype.PROPAGATE = function() {\r\n    return this.getToken(LscParser.PROPAGATE, 0);\r\n};\r\n\r\nBlockTypeContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBlockType(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BlockTypeContext = BlockTypeContext;\r\n\r\nLscParser.prototype.blockType = function() {\r\n\r\n    var localctx = new BlockTypeContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 44, LscParser.RULE_blockType);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 422;\r\n        _la = this._input.LA(1);\r\n        if(!(_la===LscParser.ALL_MATCHING || _la===LscParser.FIRST_MATCHING)) {\r\n        this._errHandler.recoverInline(this);\r\n        }\r\n        else {\r\n        \tthis._errHandler.reportMatch(this);\r\n            this.consume();\r\n        }\r\n        this.state = 425;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.WHITESPACE) {\r\n            this.state = 423;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 424;\r\n            this.match(LscParser.PROPAGATE);\r\n        }\r\n\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ExpressionListContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_expressionList;\r\n    return this;\r\n}\r\n\r\nExpressionListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nExpressionListContext.prototype.constructor = ExpressionListContext;\r\n\r\nExpressionListContext.prototype.expression = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(ExpressionContext);\r\n    } else {\r\n        return this.getTypedRuleContext(ExpressionContext,i);\r\n    }\r\n};\r\n\r\nExpressionListContext.prototype.NEWLINE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NEWLINE);\r\n    } else {\r\n        return this.getToken(LscParser.NEWLINE, i);\r\n    }\r\n};\r\n\r\n\r\nExpressionListContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitExpressionList(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ExpressionListContext = ExpressionListContext;\r\n\r\nLscParser.prototype.expressionList = function() {\r\n\r\n    var localctx = new ExpressionListContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 46, LscParser.RULE_expressionList);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 427;\r\n        this.expression();\r\n        this.state = 436;\r\n        this._errHandler.sync(this);\r\n        var _alt = this._interp.adaptivePredict(this._input,46,this._ctx)\r\n        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\r\n            if(_alt===1) {\r\n                this.state = 429; \r\n                this._errHandler.sync(this);\r\n                _la = this._input.LA(1);\r\n                do {\r\n                    this.state = 428;\r\n                    this.match(LscParser.NEWLINE);\r\n                    this.state = 431; \r\n                    this._errHandler.sync(this);\r\n                    _la = this._input.LA(1);\r\n                } while(_la===LscParser.NEWLINE);\r\n                this.state = 433;\r\n                this.expression(); \r\n            }\r\n            this.state = 438;\r\n            this._errHandler.sync(this);\r\n            _alt = this._interp.adaptivePredict(this._input,46,this._ctx);\r\n        }\r\n\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction RuleNameContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_ruleName;\r\n    return this;\r\n}\r\n\r\nRuleNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nRuleNameContext.prototype.constructor = RuleNameContext;\r\n\r\nRuleNameContext.prototype.NAME = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NAME);\r\n    } else {\r\n        return this.getToken(LscParser.NAME, i);\r\n    }\r\n};\r\n\r\n\r\nRuleNameContext.prototype.HYPHEN = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.HYPHEN);\r\n    } else {\r\n        return this.getToken(LscParser.HYPHEN, i);\r\n    }\r\n};\r\n\r\n\r\nRuleNameContext.prototype.NUMBER = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.NUMBER);\r\n    } else {\r\n        return this.getToken(LscParser.NUMBER, i);\r\n    }\r\n};\r\n\r\n\r\nRuleNameContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitRuleName(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.RuleNameContext = RuleNameContext;\r\n\r\nLscParser.prototype.ruleName = function() {\r\n\r\n    var localctx = new RuleNameContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 48, LscParser.RULE_ruleName);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 439;\r\n        this.match(LscParser.NAME);\r\n        this.state = 444;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.HYPHEN) {\r\n            this.state = 440;\r\n            this.match(LscParser.HYPHEN);\r\n            this.state = 441;\r\n            _la = this._input.LA(1);\r\n            if(!(_la===LscParser.NUMBER || _la===LscParser.NAME)) {\r\n            this._errHandler.recoverInline(this);\r\n            }\r\n            else {\r\n            \tthis._errHandler.reportMatch(this);\r\n                this.consume();\r\n            }\r\n            this.state = 446;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ExpressionContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_expression;\r\n    return this;\r\n}\r\n\r\nExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nExpressionContext.prototype.constructor = ExpressionContext;\r\n\r\nExpressionContext.prototype.UNCHANGED = function() {\r\n    return this.getToken(LscParser.UNCHANGED, 0);\r\n};\r\n\r\nExpressionContext.prototype.from = function() {\r\n    return this.getTypedRuleContext(FromContext,0);\r\n};\r\n\r\nExpressionContext.prototype.CHANGE = function() {\r\n    return this.getToken(LscParser.CHANGE, 0);\r\n};\r\n\r\nExpressionContext.prototype.to = function() {\r\n    return this.getTypedRuleContext(ToContext,0);\r\n};\r\n\r\nExpressionContext.prototype.compoundEnvironment = function() {\r\n    return this.getTypedRuleContext(CompoundEnvironmentContext,0);\r\n};\r\n\r\nExpressionContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitExpression(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ExpressionContext = ExpressionContext;\r\n\r\nLscParser.prototype.expression = function() {\r\n\r\n    var localctx = new ExpressionContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 50, LscParser.RULE_expression);\r\n    try {\r\n        this.state = 453;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.UNCHANGED:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 447;\r\n            this.match(LscParser.UNCHANGED);\r\n            break;\r\n        case LscParser.O_PAREN:\r\n        case LscParser.NULL:\r\n        case LscParser.MATRIX_START:\r\n        case LscParser.LIST_START:\r\n        case LscParser.NEGATION:\r\n        case LscParser.SYLLABLE_BOUNDARY:\r\n        case LscParser.WORD_BOUNDARY:\r\n        case LscParser.BETWEEN_WORDS:\r\n        case LscParser.CLASSREF:\r\n        case LscParser.ANY_SYLLABLE:\r\n        case LscParser.NAME:\r\n        case LscParser.STR1:\r\n        case LscParser.STR:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 448;\r\n            this.from();\r\n            this.state = 449;\r\n            this.match(LscParser.CHANGE);\r\n            this.state = 450;\r\n            this.to();\r\n            this.state = 451;\r\n            this.compoundEnvironment();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FromContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_from;\r\n    return this;\r\n}\r\n\r\nFromContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFromContext.prototype.constructor = FromContext;\r\n\r\nFromContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nFromContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFrom(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FromContext = FromContext;\r\n\r\nLscParser.prototype.from = function() {\r\n\r\n    var localctx = new FromContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 52, LscParser.RULE_from);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 455;\r\n        this.ruleElement();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ToContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_to;\r\n    return this;\r\n}\r\n\r\nToContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nToContext.prototype.constructor = ToContext;\r\n\r\nToContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nToContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitTo(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ToContext = ToContext;\r\n\r\nLscParser.prototype.to = function() {\r\n\r\n    var localctx = new ToContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 54, LscParser.RULE_to);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 457;\r\n        this.ruleElement();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction RuleElementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_ruleElement;\r\n    return this;\r\n}\r\n\r\nRuleElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nRuleElementContext.prototype.constructor = RuleElementContext;\r\n\r\nRuleElementContext.prototype.bounded = function() {\r\n    return this.getTypedRuleContext(BoundedContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.intersection = function() {\r\n    return this.getTypedRuleContext(IntersectionContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.negated = function() {\r\n    return this.getTypedRuleContext(NegatedContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.postfix = function() {\r\n    return this.getTypedRuleContext(PostfixContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.sequence = function() {\r\n    return this.getTypedRuleContext(SequenceContext,0);\r\n};\r\n\r\nRuleElementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitRuleElement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.RuleElementContext = RuleElementContext;\r\n\r\nLscParser.prototype.ruleElement = function() {\r\n\r\n    var localctx = new RuleElementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 56, LscParser.RULE_ruleElement);\r\n    try {\r\n        this.state = 465;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,49,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 459;\r\n            this.bounded();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 460;\r\n            this.intersection();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 461;\r\n            this.negated();\r\n            break;\r\n\r\n        case 4:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 462;\r\n            this.postfix();\r\n            break;\r\n\r\n        case 5:\r\n            this.enterOuterAlt(localctx, 5);\r\n            this.state = 463;\r\n            this.simple();\r\n            break;\r\n\r\n        case 6:\r\n            this.enterOuterAlt(localctx, 6);\r\n            this.state = 464;\r\n            this.sequence();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BoundedContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_bounded;\r\n    return this;\r\n}\r\n\r\nBoundedContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBoundedContext.prototype.constructor = BoundedContext;\r\n\r\nBoundedContext.prototype.group = function() {\r\n    return this.getTypedRuleContext(GroupContext,0);\r\n};\r\n\r\nBoundedContext.prototype.list = function() {\r\n    return this.getTypedRuleContext(ListContext,0);\r\n};\r\n\r\nBoundedContext.prototype.lookaround = function() {\r\n    return this.getTypedRuleContext(LookaroundContext,0);\r\n};\r\n\r\nBoundedContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBounded(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BoundedContext = BoundedContext;\r\n\r\nLscParser.prototype.bounded = function() {\r\n\r\n    var localctx = new BoundedContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 58, LscParser.RULE_bounded);\r\n    try {\r\n        this.state = 470;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,50,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 467;\r\n            this.group();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 468;\r\n            this.list();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 469;\r\n            this.lookaround();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction GroupContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_group;\r\n    return this;\r\n}\r\n\r\nGroupContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nGroupContext.prototype.constructor = GroupContext;\r\n\r\nGroupContext.prototype.O_PAREN = function() {\r\n    return this.getToken(LscParser.O_PAREN, 0);\r\n};\r\n\r\nGroupContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nGroupContext.prototype.C_PAREN = function() {\r\n    return this.getToken(LscParser.C_PAREN, 0);\r\n};\r\n\r\nGroupContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitGroup(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.GroupContext = GroupContext;\r\n\r\nLscParser.prototype.group = function() {\r\n\r\n    var localctx = new GroupContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 60, LscParser.RULE_group);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 472;\r\n        this.match(LscParser.O_PAREN);\r\n        this.state = 473;\r\n        this.ruleElement();\r\n        this.state = 474;\r\n        this.match(LscParser.C_PAREN);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ListContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_list;\r\n    return this;\r\n}\r\n\r\nListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nListContext.prototype.constructor = ListContext;\r\n\r\nListContext.prototype.LIST_START = function() {\r\n    return this.getToken(LscParser.LIST_START, 0);\r\n};\r\n\r\nListContext.prototype.ruleElement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(RuleElementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(RuleElementContext,i);\r\n    }\r\n};\r\n\r\nListContext.prototype.LIST_END = function() {\r\n    return this.getToken(LscParser.LIST_END, 0);\r\n};\r\n\r\nListContext.prototype.SEP = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.SEP);\r\n    } else {\r\n        return this.getToken(LscParser.SEP, i);\r\n    }\r\n};\r\n\r\n\r\nListContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitList(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ListContext = ListContext;\r\n\r\nLscParser.prototype.list = function() {\r\n\r\n    var localctx = new ListContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 62, LscParser.RULE_list);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 476;\r\n        this.match(LscParser.LIST_START);\r\n        this.state = 477;\r\n        this.ruleElement();\r\n        this.state = 482;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.SEP) {\r\n            this.state = 478;\r\n            this.match(LscParser.SEP);\r\n            this.state = 479;\r\n            this.ruleElement();\r\n            this.state = 484;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 485;\r\n        this.match(LscParser.LIST_END);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction LookaroundContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_lookaround;\r\n    return this;\r\n}\r\n\r\nLookaroundContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nLookaroundContext.prototype.constructor = LookaroundContext;\r\n\r\nLookaroundContext.prototype.O_PAREN = function() {\r\n    return this.getToken(LscParser.O_PAREN, 0);\r\n};\r\n\r\nLookaroundContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nLookaroundContext.prototype.compoundEnvironment = function() {\r\n    return this.getTypedRuleContext(CompoundEnvironmentContext,0);\r\n};\r\n\r\nLookaroundContext.prototype.C_PAREN = function() {\r\n    return this.getToken(LscParser.C_PAREN, 0);\r\n};\r\n\r\nLookaroundContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitLookaround(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.LookaroundContext = LookaroundContext;\r\n\r\nLscParser.prototype.lookaround = function() {\r\n\r\n    var localctx = new LookaroundContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 64, LscParser.RULE_lookaround);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 487;\r\n        this.match(LscParser.O_PAREN);\r\n        this.state = 488;\r\n        this.ruleElement();\r\n        this.state = 489;\r\n        this.compoundEnvironment();\r\n        this.state = 490;\r\n        this.match(LscParser.C_PAREN);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SequenceContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_sequence;\r\n    return this;\r\n}\r\n\r\nSequenceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSequenceContext.prototype.constructor = SequenceContext;\r\n\r\nSequenceContext.prototype.freeElement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(FreeElementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(FreeElementContext,i);\r\n    }\r\n};\r\n\r\nSequenceContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nSequenceContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSequence(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SequenceContext = SequenceContext;\r\n\r\nLscParser.prototype.sequence = function() {\r\n\r\n    var localctx = new SequenceContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 66, LscParser.RULE_sequence);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 492;\r\n        this.freeElement();\r\n        this.state = 495; \r\n        this._errHandler.sync(this);\r\n        var _alt = 1;\r\n        do {\r\n        \tswitch (_alt) {\r\n        \tcase 1:\r\n        \t\tthis.state = 493;\r\n        \t\tthis.match(LscParser.WHITESPACE);\r\n        \t\tthis.state = 494;\r\n        \t\tthis.freeElement();\r\n        \t\tbreak;\r\n        \tdefault:\r\n        \t\tthrow new antlr4.error.NoViableAltException(this);\r\n        \t}\r\n        \tthis.state = 497; \r\n        \tthis._errHandler.sync(this);\r\n        \t_alt = this._interp.adaptivePredict(this._input,52, this._ctx);\r\n        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FreeElementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_freeElement;\r\n    return this;\r\n}\r\n\r\nFreeElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFreeElementContext.prototype.constructor = FreeElementContext;\r\n\r\nFreeElementContext.prototype.bounded = function() {\r\n    return this.getTypedRuleContext(BoundedContext,0);\r\n};\r\n\r\nFreeElementContext.prototype.intersection = function() {\r\n    return this.getTypedRuleContext(IntersectionContext,0);\r\n};\r\n\r\nFreeElementContext.prototype.negated = function() {\r\n    return this.getTypedRuleContext(NegatedContext,0);\r\n};\r\n\r\nFreeElementContext.prototype.postfix = function() {\r\n    return this.getTypedRuleContext(PostfixContext,0);\r\n};\r\n\r\nFreeElementContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nFreeElementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFreeElement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FreeElementContext = FreeElementContext;\r\n\r\nLscParser.prototype.freeElement = function() {\r\n\r\n    var localctx = new FreeElementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 68, LscParser.RULE_freeElement);\r\n    try {\r\n        this.state = 504;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,53,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 499;\r\n            this.bounded();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 500;\r\n            this.intersection();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 501;\r\n            this.negated();\r\n            break;\r\n\r\n        case 4:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 502;\r\n            this.postfix();\r\n            break;\r\n\r\n        case 5:\r\n            this.enterOuterAlt(localctx, 5);\r\n            this.state = 503;\r\n            this.simple();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction CompoundEnvironmentContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_compoundEnvironment;\r\n    return this;\r\n}\r\n\r\nCompoundEnvironmentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nCompoundEnvironmentContext.prototype.constructor = CompoundEnvironmentContext;\r\n\r\nCompoundEnvironmentContext.prototype.CONDITION = function() {\r\n    return this.getToken(LscParser.CONDITION, 0);\r\n};\r\n\r\nCompoundEnvironmentContext.prototype.condition = function() {\r\n    return this.getTypedRuleContext(ConditionContext,0);\r\n};\r\n\r\nCompoundEnvironmentContext.prototype.EXCLUSION = function() {\r\n    return this.getToken(LscParser.EXCLUSION, 0);\r\n};\r\n\r\nCompoundEnvironmentContext.prototype.exclusion = function() {\r\n    return this.getTypedRuleContext(ExclusionContext,0);\r\n};\r\n\r\nCompoundEnvironmentContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitCompoundEnvironment(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.CompoundEnvironmentContext = CompoundEnvironmentContext;\r\n\r\nLscParser.prototype.compoundEnvironment = function() {\r\n\r\n    var localctx = new CompoundEnvironmentContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 70, LscParser.RULE_compoundEnvironment);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 508;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.CONDITION) {\r\n            this.state = 506;\r\n            this.match(LscParser.CONDITION);\r\n            this.state = 507;\r\n            this.condition();\r\n        }\r\n\r\n        this.state = 512;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.EXCLUSION) {\r\n            this.state = 510;\r\n            this.match(LscParser.EXCLUSION);\r\n            this.state = 511;\r\n            this.exclusion();\r\n        }\r\n\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ConditionContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_condition;\r\n    return this;\r\n}\r\n\r\nConditionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nConditionContext.prototype.constructor = ConditionContext;\r\n\r\nConditionContext.prototype.environment = function() {\r\n    return this.getTypedRuleContext(EnvironmentContext,0);\r\n};\r\n\r\nConditionContext.prototype.environmentList = function() {\r\n    return this.getTypedRuleContext(EnvironmentListContext,0);\r\n};\r\n\r\nConditionContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitCondition(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ConditionContext = ConditionContext;\r\n\r\nLscParser.prototype.condition = function() {\r\n\r\n    var localctx = new ConditionContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 72, LscParser.RULE_condition);\r\n    try {\r\n        this.state = 516;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,56,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 514;\r\n            this.environment();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 515;\r\n            this.environmentList();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ExclusionContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_exclusion;\r\n    return this;\r\n}\r\n\r\nExclusionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nExclusionContext.prototype.constructor = ExclusionContext;\r\n\r\nExclusionContext.prototype.environment = function() {\r\n    return this.getTypedRuleContext(EnvironmentContext,0);\r\n};\r\n\r\nExclusionContext.prototype.environmentList = function() {\r\n    return this.getTypedRuleContext(EnvironmentListContext,0);\r\n};\r\n\r\nExclusionContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitExclusion(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ExclusionContext = ExclusionContext;\r\n\r\nLscParser.prototype.exclusion = function() {\r\n\r\n    var localctx = new ExclusionContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 74, LscParser.RULE_exclusion);\r\n    try {\r\n        this.state = 520;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,57,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 518;\r\n            this.environment();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 519;\r\n            this.environmentList();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction EnvironmentListContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_environmentList;\r\n    return this;\r\n}\r\n\r\nEnvironmentListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nEnvironmentListContext.prototype.constructor = EnvironmentListContext;\r\n\r\nEnvironmentListContext.prototype.LIST_START = function() {\r\n    return this.getToken(LscParser.LIST_START, 0);\r\n};\r\n\r\nEnvironmentListContext.prototype.environment = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(EnvironmentContext);\r\n    } else {\r\n        return this.getTypedRuleContext(EnvironmentContext,i);\r\n    }\r\n};\r\n\r\nEnvironmentListContext.prototype.LIST_END = function() {\r\n    return this.getToken(LscParser.LIST_END, 0);\r\n};\r\n\r\nEnvironmentListContext.prototype.SEP = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.SEP);\r\n    } else {\r\n        return this.getToken(LscParser.SEP, i);\r\n    }\r\n};\r\n\r\n\r\nEnvironmentListContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitEnvironmentList(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.EnvironmentListContext = EnvironmentListContext;\r\n\r\nLscParser.prototype.environmentList = function() {\r\n\r\n    var localctx = new EnvironmentListContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 76, LscParser.RULE_environmentList);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 522;\r\n        this.match(LscParser.LIST_START);\r\n        this.state = 523;\r\n        this.environment();\r\n        this.state = 528;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.SEP) {\r\n            this.state = 524;\r\n            this.match(LscParser.SEP);\r\n            this.state = 525;\r\n            this.environment();\r\n            this.state = 530;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 531;\r\n        this.match(LscParser.LIST_END);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction EnvironmentContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_environment;\r\n    return this;\r\n}\r\n\r\nEnvironmentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nEnvironmentContext.prototype.constructor = EnvironmentContext;\r\n\r\nEnvironmentContext.prototype.ANCHOR = function() {\r\n    return this.getToken(LscParser.ANCHOR, 0);\r\n};\r\n\r\nEnvironmentContext.prototype.environmentBefore = function() {\r\n    return this.getTypedRuleContext(EnvironmentBeforeContext,0);\r\n};\r\n\r\nEnvironmentContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nEnvironmentContext.prototype.environmentAfter = function() {\r\n    return this.getTypedRuleContext(EnvironmentAfterContext,0);\r\n};\r\n\r\nEnvironmentContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitEnvironment(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.EnvironmentContext = EnvironmentContext;\r\n\r\nLscParser.prototype.environment = function() {\r\n\r\n    var localctx = new EnvironmentContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 78, LscParser.RULE_environment);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.state = 546;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,62,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 536;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << LscParser.O_PAREN) | (1 << LscParser.NULL) | (1 << LscParser.MATRIX_START) | (1 << LscParser.LIST_START) | (1 << LscParser.NEGATION) | (1 << LscParser.SYLLABLE_BOUNDARY) | (1 << LscParser.WORD_BOUNDARY) | (1 << LscParser.BETWEEN_WORDS) | (1 << LscParser.CLASSREF))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (LscParser.ANY_SYLLABLE - 37)) | (1 << (LscParser.NAME - 37)) | (1 << (LscParser.STR1 - 37)) | (1 << (LscParser.STR - 37)))) !== 0)) {\r\n                this.state = 533;\r\n                this.environmentBefore();\r\n                this.state = 534;\r\n                this.match(LscParser.WHITESPACE);\r\n            }\r\n\r\n            this.state = 538;\r\n            this.match(LscParser.ANCHOR);\r\n            this.state = 541;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if(_la===LscParser.WHITESPACE) {\r\n                this.state = 539;\r\n                this.match(LscParser.WHITESPACE);\r\n                this.state = 540;\r\n                this.environmentAfter();\r\n            }\r\n\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 544;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << LscParser.O_PAREN) | (1 << LscParser.NULL) | (1 << LscParser.MATRIX_START) | (1 << LscParser.LIST_START) | (1 << LscParser.NEGATION) | (1 << LscParser.SYLLABLE_BOUNDARY) | (1 << LscParser.WORD_BOUNDARY) | (1 << LscParser.BETWEEN_WORDS) | (1 << LscParser.CLASSREF))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (LscParser.ANY_SYLLABLE - 37)) | (1 << (LscParser.NAME - 37)) | (1 << (LscParser.STR1 - 37)) | (1 << (LscParser.STR - 37)))) !== 0)) {\r\n                this.state = 543;\r\n                this.environmentBefore();\r\n            }\r\n\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction EnvironmentBeforeContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_environmentBefore;\r\n    return this;\r\n}\r\n\r\nEnvironmentBeforeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nEnvironmentBeforeContext.prototype.constructor = EnvironmentBeforeContext;\r\n\r\nEnvironmentBeforeContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nEnvironmentBeforeContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitEnvironmentBefore(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.EnvironmentBeforeContext = EnvironmentBeforeContext;\r\n\r\nLscParser.prototype.environmentBefore = function() {\r\n\r\n    var localctx = new EnvironmentBeforeContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 80, LscParser.RULE_environmentBefore);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 548;\r\n        this.ruleElement();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction EnvironmentAfterContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_environmentAfter;\r\n    return this;\r\n}\r\n\r\nEnvironmentAfterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nEnvironmentAfterContext.prototype.constructor = EnvironmentAfterContext;\r\n\r\nEnvironmentAfterContext.prototype.ruleElement = function() {\r\n    return this.getTypedRuleContext(RuleElementContext,0);\r\n};\r\n\r\nEnvironmentAfterContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitEnvironmentAfter(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.EnvironmentAfterContext = EnvironmentAfterContext;\r\n\r\nLscParser.prototype.environmentAfter = function() {\r\n\r\n    var localctx = new EnvironmentAfterContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 82, LscParser.RULE_environmentAfter);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 550;\r\n        this.ruleElement();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction IntersectionContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_intersection;\r\n    return this;\r\n}\r\n\r\nIntersectionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nIntersectionContext.prototype.constructor = IntersectionContext;\r\n\r\nIntersectionContext.prototype.interfixElement = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(InterfixElementContext);\r\n    } else {\r\n        return this.getTypedRuleContext(InterfixElementContext,i);\r\n    }\r\n};\r\n\r\nIntersectionContext.prototype.INTERSECTION = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.INTERSECTION);\r\n    } else {\r\n        return this.getToken(LscParser.INTERSECTION, i);\r\n    }\r\n};\r\n\r\n\r\nIntersectionContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitIntersection(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.IntersectionContext = IntersectionContext;\r\n\r\nLscParser.prototype.intersection = function() {\r\n\r\n    var localctx = new IntersectionContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 84, LscParser.RULE_intersection);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 552;\r\n        this.interfixElement();\r\n        this.state = 555; \r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        do {\r\n            this.state = 553;\r\n            this.match(LscParser.INTERSECTION);\r\n            this.state = 554;\r\n            this.interfixElement();\r\n            this.state = 557; \r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        } while(_la===LscParser.INTERSECTION);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction InterfixElementContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_interfixElement;\r\n    return this;\r\n}\r\n\r\nInterfixElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nInterfixElementContext.prototype.constructor = InterfixElementContext;\r\n\r\nInterfixElementContext.prototype.bounded = function() {\r\n    return this.getTypedRuleContext(BoundedContext,0);\r\n};\r\n\r\nInterfixElementContext.prototype.negated = function() {\r\n    return this.getTypedRuleContext(NegatedContext,0);\r\n};\r\n\r\nInterfixElementContext.prototype.postfix = function() {\r\n    return this.getTypedRuleContext(PostfixContext,0);\r\n};\r\n\r\nInterfixElementContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nInterfixElementContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitInterfixElement(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.InterfixElementContext = InterfixElementContext;\r\n\r\nLscParser.prototype.interfixElement = function() {\r\n\r\n    var localctx = new InterfixElementContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 86, LscParser.RULE_interfixElement);\r\n    try {\r\n        this.state = 563;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,64,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 559;\r\n            this.bounded();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 560;\r\n            this.negated();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 561;\r\n            this.postfix();\r\n            break;\r\n\r\n        case 4:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 562;\r\n            this.simple();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction NegatedContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_negated;\r\n    return this;\r\n}\r\n\r\nNegatedContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nNegatedContext.prototype.constructor = NegatedContext;\r\n\r\nNegatedContext.prototype.NEGATION = function() {\r\n    return this.getToken(LscParser.NEGATION, 0);\r\n};\r\n\r\nNegatedContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nNegatedContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitNegated(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.NegatedContext = NegatedContext;\r\n\r\nLscParser.prototype.negated = function() {\r\n\r\n    var localctx = new NegatedContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 88, LscParser.RULE_negated);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 565;\r\n        this.match(LscParser.NEGATION);\r\n        this.state = 566;\r\n        this.simple();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction PostfixContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_postfix;\r\n    return this;\r\n}\r\n\r\nPostfixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nPostfixContext.prototype.constructor = PostfixContext;\r\n\r\nPostfixContext.prototype.capture = function() {\r\n    return this.getTypedRuleContext(CaptureContext,0);\r\n};\r\n\r\nPostfixContext.prototype.repeater = function() {\r\n    return this.getTypedRuleContext(RepeaterContext,0);\r\n};\r\n\r\nPostfixContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitPostfix(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.PostfixContext = PostfixContext;\r\n\r\nLscParser.prototype.postfix = function() {\r\n\r\n    var localctx = new PostfixContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 90, LscParser.RULE_postfix);\r\n    try {\r\n        this.state = 570;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,65,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 568;\r\n            this.capture();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 569;\r\n            this.repeater();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction CaptureContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_capture;\r\n    return this;\r\n}\r\n\r\nCaptureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nCaptureContext.prototype.constructor = CaptureContext;\r\n\r\nCaptureContext.prototype.captureRef = function() {\r\n    return this.getTypedRuleContext(CaptureRefContext,0);\r\n};\r\n\r\nCaptureContext.prototype.bounded = function() {\r\n    return this.getTypedRuleContext(BoundedContext,0);\r\n};\r\n\r\nCaptureContext.prototype.negated = function() {\r\n    return this.getTypedRuleContext(NegatedContext,0);\r\n};\r\n\r\nCaptureContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nCaptureContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitCapture(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.CaptureContext = CaptureContext;\r\n\r\nLscParser.prototype.capture = function() {\r\n\r\n    var localctx = new CaptureContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 92, LscParser.RULE_capture);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 575;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.O_PAREN:\r\n        case LscParser.LIST_START:\r\n            this.state = 572;\r\n            this.bounded();\r\n            break;\r\n        case LscParser.NEGATION:\r\n            this.state = 573;\r\n            this.negated();\r\n            break;\r\n        case LscParser.NULL:\r\n        case LscParser.MATRIX_START:\r\n        case LscParser.SYLLABLE_BOUNDARY:\r\n        case LscParser.WORD_BOUNDARY:\r\n        case LscParser.BETWEEN_WORDS:\r\n        case LscParser.CLASSREF:\r\n        case LscParser.ANY_SYLLABLE:\r\n        case LscParser.NAME:\r\n        case LscParser.STR1:\r\n        case LscParser.STR:\r\n            this.state = 574;\r\n            this.simple();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n        this.state = 577;\r\n        this.captureRef();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction RepeaterContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_repeater;\r\n    return this;\r\n}\r\n\r\nRepeaterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nRepeaterContext.prototype.constructor = RepeaterContext;\r\n\r\nRepeaterContext.prototype.repeaterType = function() {\r\n    return this.getTypedRuleContext(RepeaterTypeContext,0);\r\n};\r\n\r\nRepeaterContext.prototype.bounded = function() {\r\n    return this.getTypedRuleContext(BoundedContext,0);\r\n};\r\n\r\nRepeaterContext.prototype.simple = function() {\r\n    return this.getTypedRuleContext(SimpleContext,0);\r\n};\r\n\r\nRepeaterContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitRepeater(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.RepeaterContext = RepeaterContext;\r\n\r\nLscParser.prototype.repeater = function() {\r\n\r\n    var localctx = new RepeaterContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 94, LscParser.RULE_repeater);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 581;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.O_PAREN:\r\n        case LscParser.LIST_START:\r\n            this.state = 579;\r\n            this.bounded();\r\n            break;\r\n        case LscParser.NULL:\r\n        case LscParser.MATRIX_START:\r\n        case LscParser.SYLLABLE_BOUNDARY:\r\n        case LscParser.WORD_BOUNDARY:\r\n        case LscParser.BETWEEN_WORDS:\r\n        case LscParser.CLASSREF:\r\n        case LscParser.ANY_SYLLABLE:\r\n        case LscParser.NAME:\r\n        case LscParser.STR1:\r\n        case LscParser.STR:\r\n            this.state = 580;\r\n            this.simple();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n        this.state = 583;\r\n        this.repeaterType();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SimpleContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_simple;\r\n    return this;\r\n}\r\n\r\nSimpleContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSimpleContext.prototype.constructor = SimpleContext;\r\n\r\nSimpleContext.prototype.anySyllable = function() {\r\n    return this.getTypedRuleContext(AnySyllableContext,0);\r\n};\r\n\r\nSimpleContext.prototype.classRef = function() {\r\n    return this.getTypedRuleContext(ClassRefContext,0);\r\n};\r\n\r\nSimpleContext.prototype.captureRef = function() {\r\n    return this.getTypedRuleContext(CaptureRefContext,0);\r\n};\r\n\r\nSimpleContext.prototype.fancyMatrix = function() {\r\n    return this.getTypedRuleContext(FancyMatrixContext,0);\r\n};\r\n\r\nSimpleContext.prototype.empty = function() {\r\n    return this.getTypedRuleContext(EmptyContext,0);\r\n};\r\n\r\nSimpleContext.prototype.sylBoundary = function() {\r\n    return this.getTypedRuleContext(SylBoundaryContext,0);\r\n};\r\n\r\nSimpleContext.prototype.boundary = function() {\r\n    return this.getTypedRuleContext(BoundaryContext,0);\r\n};\r\n\r\nSimpleContext.prototype.betweenWords = function() {\r\n    return this.getTypedRuleContext(BetweenWordsContext,0);\r\n};\r\n\r\nSimpleContext.prototype.text = function() {\r\n    return this.getTypedRuleContext(TextContext,0);\r\n};\r\n\r\nSimpleContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSimple(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SimpleContext = SimpleContext;\r\n\r\nLscParser.prototype.simple = function() {\r\n\r\n    var localctx = new SimpleContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 96, LscParser.RULE_simple);\r\n    try {\r\n        this.state = 594;\r\n        this._errHandler.sync(this);\r\n        var la_ = this._interp.adaptivePredict(this._input,68,this._ctx);\r\n        switch(la_) {\r\n        case 1:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 585;\r\n            this.anySyllable();\r\n            break;\r\n\r\n        case 2:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 586;\r\n            this.classRef();\r\n            break;\r\n\r\n        case 3:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 587;\r\n            this.captureRef();\r\n            break;\r\n\r\n        case 4:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 588;\r\n            this.fancyMatrix();\r\n            break;\r\n\r\n        case 5:\r\n            this.enterOuterAlt(localctx, 5);\r\n            this.state = 589;\r\n            this.empty();\r\n            break;\r\n\r\n        case 6:\r\n            this.enterOuterAlt(localctx, 6);\r\n            this.state = 590;\r\n            this.sylBoundary();\r\n            break;\r\n\r\n        case 7:\r\n            this.enterOuterAlt(localctx, 7);\r\n            this.state = 591;\r\n            this.boundary();\r\n            break;\r\n\r\n        case 8:\r\n            this.enterOuterAlt(localctx, 8);\r\n            this.state = 592;\r\n            this.betweenWords();\r\n            break;\r\n\r\n        case 9:\r\n            this.enterOuterAlt(localctx, 9);\r\n            this.state = 593;\r\n            this.text();\r\n            break;\r\n\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction AnySyllableContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_anySyllable;\r\n    return this;\r\n}\r\n\r\nAnySyllableContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nAnySyllableContext.prototype.constructor = AnySyllableContext;\r\n\r\nAnySyllableContext.prototype.ANY_SYLLABLE = function() {\r\n    return this.getToken(LscParser.ANY_SYLLABLE, 0);\r\n};\r\n\r\nAnySyllableContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitAnySyllable(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.AnySyllableContext = AnySyllableContext;\r\n\r\nLscParser.prototype.anySyllable = function() {\r\n\r\n    var localctx = new AnySyllableContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 98, LscParser.RULE_anySyllable);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 596;\r\n        this.match(LscParser.ANY_SYLLABLE);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction ClassRefContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_classRef;\r\n    return this;\r\n}\r\n\r\nClassRefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nClassRefContext.prototype.constructor = ClassRefContext;\r\n\r\nClassRefContext.prototype.CLASSREF = function() {\r\n    return this.getToken(LscParser.CLASSREF, 0);\r\n};\r\n\r\nClassRefContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nClassRefContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitClassRef(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.ClassRefContext = ClassRefContext;\r\n\r\nLscParser.prototype.classRef = function() {\r\n\r\n    var localctx = new ClassRefContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 100, LscParser.RULE_classRef);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 598;\r\n        this.match(LscParser.CLASSREF);\r\n        this.state = 599;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction CaptureRefContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_captureRef;\r\n    return this;\r\n}\r\n\r\nCaptureRefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nCaptureRefContext.prototype.constructor = CaptureRefContext;\r\n\r\nCaptureRefContext.prototype.WORD_BOUNDARY = function() {\r\n    return this.getToken(LscParser.WORD_BOUNDARY, 0);\r\n};\r\n\r\nCaptureRefContext.prototype.NUMBER = function() {\r\n    return this.getToken(LscParser.NUMBER, 0);\r\n};\r\n\r\nCaptureRefContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitCaptureRef(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.CaptureRefContext = CaptureRefContext;\r\n\r\nLscParser.prototype.captureRef = function() {\r\n\r\n    var localctx = new CaptureRefContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 102, LscParser.RULE_captureRef);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 601;\r\n        this.match(LscParser.WORD_BOUNDARY);\r\n        this.state = 602;\r\n        this.match(LscParser.NUMBER);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FancyMatrixContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_fancyMatrix;\r\n    return this;\r\n}\r\n\r\nFancyMatrixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFancyMatrixContext.prototype.constructor = FancyMatrixContext;\r\n\r\nFancyMatrixContext.prototype.MATRIX_START = function() {\r\n    return this.getToken(LscParser.MATRIX_START, 0);\r\n};\r\n\r\nFancyMatrixContext.prototype.MATRIX_END = function() {\r\n    return this.getToken(LscParser.MATRIX_END, 0);\r\n};\r\n\r\nFancyMatrixContext.prototype.fancyValue = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(FancyValueContext);\r\n    } else {\r\n        return this.getTypedRuleContext(FancyValueContext,i);\r\n    }\r\n};\r\n\r\nFancyMatrixContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nFancyMatrixContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFancyMatrix(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FancyMatrixContext = FancyMatrixContext;\r\n\r\nLscParser.prototype.fancyMatrix = function() {\r\n\r\n    var localctx = new FancyMatrixContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 104, LscParser.RULE_fancyMatrix);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 604;\r\n        this.match(LscParser.MATRIX_START);\r\n        this.state = 606;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << LscParser.NULL) | (1 << LscParser.AT_LEAST_ONE) | (1 << LscParser.HYPHEN) | (1 << LscParser.NEGATION) | (1 << LscParser.WORD_BOUNDARY))) !== 0) || _la===LscParser.NAME) {\r\n            this.state = 605;\r\n            this.fancyValue();\r\n        }\r\n\r\n        this.state = 612;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.WHITESPACE) {\r\n            this.state = 608;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 609;\r\n            this.fancyValue();\r\n            this.state = 614;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 615;\r\n        this.match(LscParser.MATRIX_END);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FancyValueContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_fancyValue;\r\n    return this;\r\n}\r\n\r\nFancyValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFancyValueContext.prototype.constructor = FancyValueContext;\r\n\r\nFancyValueContext.prototype.plusFeatureValue = function() {\r\n    return this.getTypedRuleContext(PlusFeatureValueContext,0);\r\n};\r\n\r\nFancyValueContext.prototype.featureValue = function() {\r\n    return this.getTypedRuleContext(FeatureValueContext,0);\r\n};\r\n\r\nFancyValueContext.prototype.negatedValue = function() {\r\n    return this.getTypedRuleContext(NegatedValueContext,0);\r\n};\r\n\r\nFancyValueContext.prototype.absentFeature = function() {\r\n    return this.getTypedRuleContext(AbsentFeatureContext,0);\r\n};\r\n\r\nFancyValueContext.prototype.featureVariable = function() {\r\n    return this.getTypedRuleContext(FeatureVariableContext,0);\r\n};\r\n\r\nFancyValueContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFancyValue(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FancyValueContext = FancyValueContext;\r\n\r\nLscParser.prototype.fancyValue = function() {\r\n\r\n    var localctx = new FancyValueContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 106, LscParser.RULE_fancyValue);\r\n    try {\r\n        this.state = 622;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.AT_LEAST_ONE:\r\n        case LscParser.HYPHEN:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 617;\r\n            this.plusFeatureValue();\r\n            break;\r\n        case LscParser.NAME:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 618;\r\n            this.featureValue();\r\n            break;\r\n        case LscParser.NEGATION:\r\n            this.enterOuterAlt(localctx, 3);\r\n            this.state = 619;\r\n            this.negatedValue();\r\n            break;\r\n        case LscParser.NULL:\r\n            this.enterOuterAlt(localctx, 4);\r\n            this.state = 620;\r\n            this.absentFeature();\r\n            break;\r\n        case LscParser.WORD_BOUNDARY:\r\n            this.enterOuterAlt(localctx, 5);\r\n            this.state = 621;\r\n            this.featureVariable();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction NegatedValueContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_negatedValue;\r\n    return this;\r\n}\r\n\r\nNegatedValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nNegatedValueContext.prototype.constructor = NegatedValueContext;\r\n\r\nNegatedValueContext.prototype.NEGATION = function() {\r\n    return this.getToken(LscParser.NEGATION, 0);\r\n};\r\n\r\nNegatedValueContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nNegatedValueContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitNegatedValue(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.NegatedValueContext = NegatedValueContext;\r\n\r\nLscParser.prototype.negatedValue = function() {\r\n\r\n    var localctx = new NegatedValueContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 108, LscParser.RULE_negatedValue);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 624;\r\n        this.match(LscParser.NEGATION);\r\n        this.state = 625;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction AbsentFeatureContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_absentFeature;\r\n    return this;\r\n}\r\n\r\nAbsentFeatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nAbsentFeatureContext.prototype.constructor = AbsentFeatureContext;\r\n\r\nAbsentFeatureContext.prototype.NULL = function() {\r\n    return this.getToken(LscParser.NULL, 0);\r\n};\r\n\r\nAbsentFeatureContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nAbsentFeatureContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitAbsentFeature(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.AbsentFeatureContext = AbsentFeatureContext;\r\n\r\nLscParser.prototype.absentFeature = function() {\r\n\r\n    var localctx = new AbsentFeatureContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 110, LscParser.RULE_absentFeature);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 627;\r\n        this.match(LscParser.NULL);\r\n        this.state = 628;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FeatureVariableContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_featureVariable;\r\n    return this;\r\n}\r\n\r\nFeatureVariableContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFeatureVariableContext.prototype.constructor = FeatureVariableContext;\r\n\r\nFeatureVariableContext.prototype.WORD_BOUNDARY = function() {\r\n    return this.getToken(LscParser.WORD_BOUNDARY, 0);\r\n};\r\n\r\nFeatureVariableContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nFeatureVariableContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFeatureVariable(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FeatureVariableContext = FeatureVariableContext;\r\n\r\nLscParser.prototype.featureVariable = function() {\r\n\r\n    var localctx = new FeatureVariableContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 112, LscParser.RULE_featureVariable);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 630;\r\n        this.match(LscParser.WORD_BOUNDARY);\r\n        this.state = 631;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction EmptyContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_empty;\r\n    return this;\r\n}\r\n\r\nEmptyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nEmptyContext.prototype.constructor = EmptyContext;\r\n\r\nEmptyContext.prototype.NULL = function() {\r\n    return this.getToken(LscParser.NULL, 0);\r\n};\r\n\r\nEmptyContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitEmpty(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.EmptyContext = EmptyContext;\r\n\r\nLscParser.prototype.empty = function() {\r\n\r\n    var localctx = new EmptyContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 114, LscParser.RULE_empty);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 633;\r\n        this.match(LscParser.NULL);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction SylBoundaryContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_sylBoundary;\r\n    return this;\r\n}\r\n\r\nSylBoundaryContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nSylBoundaryContext.prototype.constructor = SylBoundaryContext;\r\n\r\nSylBoundaryContext.prototype.SYLLABLE_BOUNDARY = function() {\r\n    return this.getToken(LscParser.SYLLABLE_BOUNDARY, 0);\r\n};\r\n\r\nSylBoundaryContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitSylBoundary(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.SylBoundaryContext = SylBoundaryContext;\r\n\r\nLscParser.prototype.sylBoundary = function() {\r\n\r\n    var localctx = new SylBoundaryContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 116, LscParser.RULE_sylBoundary);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 635;\r\n        this.match(LscParser.SYLLABLE_BOUNDARY);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BoundaryContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_boundary;\r\n    return this;\r\n}\r\n\r\nBoundaryContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBoundaryContext.prototype.constructor = BoundaryContext;\r\n\r\nBoundaryContext.prototype.WORD_BOUNDARY = function() {\r\n    return this.getToken(LscParser.WORD_BOUNDARY, 0);\r\n};\r\n\r\nBoundaryContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBoundary(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BoundaryContext = BoundaryContext;\r\n\r\nLscParser.prototype.boundary = function() {\r\n\r\n    var localctx = new BoundaryContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 118, LscParser.RULE_boundary);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 637;\r\n        this.match(LscParser.WORD_BOUNDARY);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction BetweenWordsContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_betweenWords;\r\n    return this;\r\n}\r\n\r\nBetweenWordsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nBetweenWordsContext.prototype.constructor = BetweenWordsContext;\r\n\r\nBetweenWordsContext.prototype.BETWEEN_WORDS = function() {\r\n    return this.getToken(LscParser.BETWEEN_WORDS, 0);\r\n};\r\n\r\nBetweenWordsContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitBetweenWords(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.BetweenWordsContext = BetweenWordsContext;\r\n\r\nLscParser.prototype.betweenWords = function() {\r\n\r\n    var localctx = new BetweenWordsContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 120, LscParser.RULE_betweenWords);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 639;\r\n        this.match(LscParser.BETWEEN_WORDS);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction RepeaterTypeContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_repeaterType;\r\n    return this;\r\n}\r\n\r\nRepeaterTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nRepeaterTypeContext.prototype.constructor = RepeaterTypeContext;\r\n\r\nRepeaterTypeContext.prototype.AT_LEAST_ONE = function() {\r\n    return this.getToken(LscParser.AT_LEAST_ONE, 0);\r\n};\r\n\r\nRepeaterTypeContext.prototype.NULL = function() {\r\n    return this.getToken(LscParser.NULL, 0);\r\n};\r\n\r\nRepeaterTypeContext.prototype.OPTIONAL = function() {\r\n    return this.getToken(LscParser.OPTIONAL, 0);\r\n};\r\n\r\nRepeaterTypeContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitRepeaterType(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.RepeaterTypeContext = RepeaterTypeContext;\r\n\r\nLscParser.prototype.repeaterType = function() {\r\n\r\n    var localctx = new RepeaterTypeContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 122, LscParser.RULE_repeaterType);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 641;\r\n        _la = this._input.LA(1);\r\n        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << LscParser.NULL) | (1 << LscParser.AT_LEAST_ONE) | (1 << LscParser.OPTIONAL))) !== 0))) {\r\n        this._errHandler.recoverInline(this);\r\n        }\r\n        else {\r\n        \tthis._errHandler.reportMatch(this);\r\n            this.consume();\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction MatrixContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_matrix;\r\n    return this;\r\n}\r\n\r\nMatrixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nMatrixContext.prototype.constructor = MatrixContext;\r\n\r\nMatrixContext.prototype.MATRIX_START = function() {\r\n    return this.getToken(LscParser.MATRIX_START, 0);\r\n};\r\n\r\nMatrixContext.prototype.MATRIX_END = function() {\r\n    return this.getToken(LscParser.MATRIX_END, 0);\r\n};\r\n\r\nMatrixContext.prototype.matrixValue = function(i) {\r\n    if(i===undefined) {\r\n        i = null;\r\n    }\r\n    if(i===null) {\r\n        return this.getTypedRuleContexts(MatrixValueContext);\r\n    } else {\r\n        return this.getTypedRuleContext(MatrixValueContext,i);\r\n    }\r\n};\r\n\r\nMatrixContext.prototype.WHITESPACE = function(i) {\r\n\tif(i===undefined) {\r\n\t\ti = null;\r\n\t}\r\n    if(i===null) {\r\n        return this.getTokens(LscParser.WHITESPACE);\r\n    } else {\r\n        return this.getToken(LscParser.WHITESPACE, i);\r\n    }\r\n};\r\n\r\n\r\nMatrixContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitMatrix(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.MatrixContext = MatrixContext;\r\n\r\nLscParser.prototype.matrix = function() {\r\n\r\n    var localctx = new MatrixContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 124, LscParser.RULE_matrix);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 643;\r\n        this.match(LscParser.MATRIX_START);\r\n        this.state = 645;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(((((_la - 16)) & ~0x1f) == 0 && ((1 << (_la - 16)) & ((1 << (LscParser.AT_LEAST_ONE - 16)) | (1 << (LscParser.HYPHEN - 16)) | (1 << (LscParser.NAME - 16)))) !== 0)) {\r\n            this.state = 644;\r\n            this.matrixValue();\r\n        }\r\n\r\n        this.state = 651;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        while(_la===LscParser.WHITESPACE) {\r\n            this.state = 647;\r\n            this.match(LscParser.WHITESPACE);\r\n            this.state = 648;\r\n            this.matrixValue();\r\n            this.state = 653;\r\n            this._errHandler.sync(this);\r\n            _la = this._input.LA(1);\r\n        }\r\n        this.state = 654;\r\n        this.match(LscParser.MATRIX_END);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction MatrixValueContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_matrixValue;\r\n    return this;\r\n}\r\n\r\nMatrixValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nMatrixValueContext.prototype.constructor = MatrixValueContext;\r\n\r\nMatrixValueContext.prototype.plusFeatureValue = function() {\r\n    return this.getTypedRuleContext(PlusFeatureValueContext,0);\r\n};\r\n\r\nMatrixValueContext.prototype.featureValue = function() {\r\n    return this.getTypedRuleContext(FeatureValueContext,0);\r\n};\r\n\r\nMatrixValueContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitMatrixValue(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.MatrixValueContext = MatrixValueContext;\r\n\r\nLscParser.prototype.matrixValue = function() {\r\n\r\n    var localctx = new MatrixValueContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 126, LscParser.RULE_matrixValue);\r\n    try {\r\n        this.state = 658;\r\n        this._errHandler.sync(this);\r\n        switch(this._input.LA(1)) {\r\n        case LscParser.AT_LEAST_ONE:\r\n        case LscParser.HYPHEN:\r\n            this.enterOuterAlt(localctx, 1);\r\n            this.state = 656;\r\n            this.plusFeatureValue();\r\n            break;\r\n        case LscParser.NAME:\r\n            this.enterOuterAlt(localctx, 2);\r\n            this.state = 657;\r\n            this.featureValue();\r\n            break;\r\n        default:\r\n            throw new antlr4.error.NoViableAltException(this);\r\n        }\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction PlusFeatureValueContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_plusFeatureValue;\r\n    return this;\r\n}\r\n\r\nPlusFeatureValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nPlusFeatureValueContext.prototype.constructor = PlusFeatureValueContext;\r\n\r\nPlusFeatureValueContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nPlusFeatureValueContext.prototype.AT_LEAST_ONE = function() {\r\n    return this.getToken(LscParser.AT_LEAST_ONE, 0);\r\n};\r\n\r\nPlusFeatureValueContext.prototype.HYPHEN = function() {\r\n    return this.getToken(LscParser.HYPHEN, 0);\r\n};\r\n\r\nPlusFeatureValueContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitPlusFeatureValue(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.PlusFeatureValueContext = PlusFeatureValueContext;\r\n\r\nLscParser.prototype.plusFeatureValue = function() {\r\n\r\n    var localctx = new PlusFeatureValueContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 128, LscParser.RULE_plusFeatureValue);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 660;\r\n        _la = this._input.LA(1);\r\n        if(!(_la===LscParser.AT_LEAST_ONE || _la===LscParser.HYPHEN)) {\r\n        this._errHandler.recoverInline(this);\r\n        }\r\n        else {\r\n        \tthis._errHandler.reportMatch(this);\r\n            this.consume();\r\n        }\r\n        this.state = 661;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction FeatureValueContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_featureValue;\r\n    return this;\r\n}\r\n\r\nFeatureValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nFeatureValueContext.prototype.constructor = FeatureValueContext;\r\n\r\nFeatureValueContext.prototype.name = function() {\r\n    return this.getTypedRuleContext(NameContext,0);\r\n};\r\n\r\nFeatureValueContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitFeatureValue(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.FeatureValueContext = FeatureValueContext;\r\n\r\nLscParser.prototype.featureValue = function() {\r\n\r\n    var localctx = new FeatureValueContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 130, LscParser.RULE_featureValue);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 663;\r\n        this.name();\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction NameContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_name;\r\n    return this;\r\n}\r\n\r\nNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nNameContext.prototype.constructor = NameContext;\r\n\r\nNameContext.prototype.NAME = function() {\r\n    return this.getToken(LscParser.NAME, 0);\r\n};\r\n\r\nNameContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitName(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.NameContext = NameContext;\r\n\r\nLscParser.prototype.name = function() {\r\n\r\n    var localctx = new NameContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 132, LscParser.RULE_name);\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 665;\r\n        this.match(LscParser.NAME);\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nfunction TextContext(parser, parent, invokingState) {\r\n\tif(parent===undefined) {\r\n\t    parent = null;\r\n\t}\r\n\tif(invokingState===undefined || invokingState===null) {\r\n\t\tinvokingState = -1;\r\n\t}\r\n\tantlr4.ParserRuleContext.call(this, parent, invokingState);\r\n    this.parser = parser;\r\n    this.ruleIndex = LscParser.RULE_text;\r\n    return this;\r\n}\r\n\r\nTextContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\r\nTextContext.prototype.constructor = TextContext;\r\n\r\nTextContext.prototype.NAME = function() {\r\n    return this.getToken(LscParser.NAME, 0);\r\n};\r\n\r\nTextContext.prototype.STR1 = function() {\r\n    return this.getToken(LscParser.STR1, 0);\r\n};\r\n\r\nTextContext.prototype.STR = function() {\r\n    return this.getToken(LscParser.STR, 0);\r\n};\r\n\r\nTextContext.prototype.NEGATION = function() {\r\n    return this.getToken(LscParser.NEGATION, 0);\r\n};\r\n\r\nTextContext.prototype.accept = function(visitor) {\r\n    if ( visitor instanceof LscVisitor ) {\r\n        return visitor.visitText(this);\r\n    } else {\r\n        return visitor.visitChildren(this);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\nLscParser.TextContext = TextContext;\r\n\r\nLscParser.prototype.text = function() {\r\n\r\n    var localctx = new TextContext(this, this._ctx, this.state);\r\n    this.enterRule(localctx, 134, LscParser.RULE_text);\r\n    var _la = 0; // Token type\r\n    try {\r\n        this.enterOuterAlt(localctx, 1);\r\n        this.state = 667;\r\n        _la = this._input.LA(1);\r\n        if(!(((((_la - 46)) & ~0x1f) == 0 && ((1 << (_la - 46)) & ((1 << (LscParser.NAME - 46)) | (1 << (LscParser.STR1 - 46)) | (1 << (LscParser.STR - 46)))) !== 0))) {\r\n        this._errHandler.recoverInline(this);\r\n        }\r\n        else {\r\n        \tthis._errHandler.reportMatch(this);\r\n            this.consume();\r\n        }\r\n        this.state = 669;\r\n        this._errHandler.sync(this);\r\n        _la = this._input.LA(1);\r\n        if(_la===LscParser.NEGATION) {\r\n            this.state = 668;\r\n            this.match(LscParser.NEGATION);\r\n        }\r\n\r\n    } catch (re) {\r\n    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t        localctx.exception = re;\r\n\t        this._errHandler.reportError(this, re);\r\n\t        this._errHandler.recover(this, re);\r\n\t    } else {\r\n\t    \tthrow re;\r\n\t    }\r\n    } finally {\r\n        this.exitRule();\r\n    }\r\n    return localctx;\r\n};\r\n\r\n\r\nexports.LscParser = LscParser;\r\n","// Generated from Lsc.g4 by ANTLR 4.7.2\r\n// jshint ignore: start\r\nvar antlr4 = require('antlr4/index');\r\n\r\n// This class defines a complete generic visitor for a parse tree produced by LscParser.\r\n\r\nfunction LscVisitor() {\r\n\tantlr4.tree.ParseTreeVisitor.call(this);\r\n\treturn this;\r\n}\r\n\r\nLscVisitor.prototype = Object.create(antlr4.tree.ParseTreeVisitor.prototype);\r\nLscVisitor.prototype.constructor = LscVisitor;\r\n\r\n// Visit a parse tree produced by LscParser#lscFile.\r\nLscVisitor.prototype.visitLscFile = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#statement.\r\nLscVisitor.prototype.visitStatement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#classDecl.\r\nLscVisitor.prototype.visitClassDecl = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#classElement.\r\nLscVisitor.prototype.visitClassElement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#featureDecl.\r\nLscVisitor.prototype.visitFeatureDecl = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#featureModifier.\r\nLscVisitor.prototype.visitFeatureModifier = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#plusFeature.\r\nLscVisitor.prototype.visitPlusFeature = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#nullAlias.\r\nLscVisitor.prototype.visitNullAlias = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#diacriticDecl.\r\nLscVisitor.prototype.visitDiacriticDecl = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#diacriticModifier.\r\nLscVisitor.prototype.visitDiacriticModifier = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#symbolDecl.\r\nLscVisitor.prototype.visitSymbolDecl = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#symbolName.\r\nLscVisitor.prototype.visitSymbolName = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#syllableDecl.\r\nLscVisitor.prototype.visitSyllableDecl = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#syllablePattern.\r\nLscVisitor.prototype.visitSyllablePattern = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#deromanizer.\r\nLscVisitor.prototype.visitDeromanizer = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#romanizer.\r\nLscVisitor.prototype.visitRomanizer = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#interRomanizer.\r\nLscVisitor.prototype.visitInterRomanizer = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#changeRule.\r\nLscVisitor.prototype.visitChangeRule = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#changeRuleModifier.\r\nLscVisitor.prototype.visitChangeRuleModifier = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#filter.\r\nLscVisitor.prototype.visitFilter = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#block.\r\nLscVisitor.prototype.visitBlock = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#blockElement.\r\nLscVisitor.prototype.visitBlockElement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#blockType.\r\nLscVisitor.prototype.visitBlockType = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#expressionList.\r\nLscVisitor.prototype.visitExpressionList = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#ruleName.\r\nLscVisitor.prototype.visitRuleName = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#expression.\r\nLscVisitor.prototype.visitExpression = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#from.\r\nLscVisitor.prototype.visitFrom = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#to.\r\nLscVisitor.prototype.visitTo = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#ruleElement.\r\nLscVisitor.prototype.visitRuleElement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#bounded.\r\nLscVisitor.prototype.visitBounded = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#group.\r\nLscVisitor.prototype.visitGroup = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#list.\r\nLscVisitor.prototype.visitList = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#lookaround.\r\nLscVisitor.prototype.visitLookaround = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#sequence.\r\nLscVisitor.prototype.visitSequence = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#freeElement.\r\nLscVisitor.prototype.visitFreeElement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#compoundEnvironment.\r\nLscVisitor.prototype.visitCompoundEnvironment = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#condition.\r\nLscVisitor.prototype.visitCondition = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#exclusion.\r\nLscVisitor.prototype.visitExclusion = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#environmentList.\r\nLscVisitor.prototype.visitEnvironmentList = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#environment.\r\nLscVisitor.prototype.visitEnvironment = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#environmentBefore.\r\nLscVisitor.prototype.visitEnvironmentBefore = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#environmentAfter.\r\nLscVisitor.prototype.visitEnvironmentAfter = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#intersection.\r\nLscVisitor.prototype.visitIntersection = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#interfixElement.\r\nLscVisitor.prototype.visitInterfixElement = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#negated.\r\nLscVisitor.prototype.visitNegated = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#postfix.\r\nLscVisitor.prototype.visitPostfix = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#capture.\r\nLscVisitor.prototype.visitCapture = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#repeater.\r\nLscVisitor.prototype.visitRepeater = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#simple.\r\nLscVisitor.prototype.visitSimple = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#anySyllable.\r\nLscVisitor.prototype.visitAnySyllable = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#classRef.\r\nLscVisitor.prototype.visitClassRef = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#captureRef.\r\nLscVisitor.prototype.visitCaptureRef = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#fancyMatrix.\r\nLscVisitor.prototype.visitFancyMatrix = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#fancyValue.\r\nLscVisitor.prototype.visitFancyValue = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#negatedValue.\r\nLscVisitor.prototype.visitNegatedValue = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#absentFeature.\r\nLscVisitor.prototype.visitAbsentFeature = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#featureVariable.\r\nLscVisitor.prototype.visitFeatureVariable = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#empty.\r\nLscVisitor.prototype.visitEmpty = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#sylBoundary.\r\nLscVisitor.prototype.visitSylBoundary = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#boundary.\r\nLscVisitor.prototype.visitBoundary = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#betweenWords.\r\nLscVisitor.prototype.visitBetweenWords = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#repeaterType.\r\nLscVisitor.prototype.visitRepeaterType = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#matrix.\r\nLscVisitor.prototype.visitMatrix = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#matrixValue.\r\nLscVisitor.prototype.visitMatrixValue = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#plusFeatureValue.\r\nLscVisitor.prototype.visitPlusFeatureValue = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#featureValue.\r\nLscVisitor.prototype.visitFeatureValue = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#name.\r\nLscVisitor.prototype.visitName = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n// Visit a parse tree produced by LscParser#text.\r\nLscVisitor.prototype.visitText = function(ctx) {\r\n  return this.visitChildren(ctx);\r\n};\r\n\r\n\r\n\r\nexports.LscVisitor = LscVisitor;","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}",null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = @OptIn(ExperimentalStdlibApi::class) buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n/** Returns true when it's safe to convert this collection to a set without changing contains method behavior. */\nprivate fun <T> Collection<T>.safeToConvertToSet() = size > 2 && this is ArrayList\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperationWith(source: Iterable<T>): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection ->\n            when {\n                source is Collection && source.size < 2 -> this\n                else -> if (this.safeToConvertToSet()) toHashSet() else this\n            }\n        else -> toHashSet()\n    }\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperation(): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection -> if (this.safeToConvertToSet()) toHashSet() else this\n        else -> toHashSet()\n    }\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return Char(code.toUShort())\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.abs\nimport kotlin.math.roundToInt\nimport kotlin.math.sign\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * The type can store duration values up to ±146 years with nanosecond precision,\n * and up to ±146 million years with millisecond precision.\n *\n * To construct a duration, use either the extension function [toDuration] available on [Int], [Long], and [Double] numeric types,\n * or the `Duration` companion object functions [Duration.hours], [Duration.minutes], [Duration.seconds], and so on,\n * taking [Int], [Long], or [Double] numbers as parameters.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        // TODO: disable assertions in final version\n        if (isInNanos()) {\n            if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n        } else {\n            if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n            if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.DAYS), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.HOURS), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.MINUTES), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately ±292 years.\n     */\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately ±292 million years.\n     */\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value expressed in the unit which yields the most compact and readable number value.\n     *\n     * Special cases:\n     *  - zero duration is formatted as `\"0s\"`\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *  - very small durations (less than 1e-15 s) are expressed in seconds and formatted in scientific notation\n     *  - very big durations (more than 1e+7 days) are expressed in days and formatted in scientific notation\n     *\n     * @return the value of duration in the automatically determined unit followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val absNs = absoluteValue.toDouble(DurationUnit.NANOSECONDS)\n            var scientific = false\n            var maxDecimals = 0\n            val unit = when {\n                absNs < 1e-6 -> DurationUnit.SECONDS.also { scientific = true }\n                absNs < 1 -> DurationUnit.NANOSECONDS.also { maxDecimals = 7 }\n                absNs < 1e3 -> DurationUnit.NANOSECONDS\n                absNs < 1e6 -> DurationUnit.MICROSECONDS\n                absNs < 1e9 -> DurationUnit.MILLISECONDS\n                absNs < 1000e9 -> DurationUnit.SECONDS\n                absNs < 60_000e9 -> DurationUnit.MINUTES\n                absNs < 3600_000e9 -> DurationUnit.HOURS\n                absNs < 86400e9 * 1e7 -> DurationUnit.DAYS\n                else -> DurationUnit.DAYS.also { scientific = true }\n            }\n            val value = toDouble(unit)\n            when {\n                scientific -> formatScientific(value)\n                maxDecimals > 0 -> formatUpToDecimals(value, maxDecimals)\n                else -> formatToExactDecimals(value, precision(abs(value)))\n            } + unit.shortName()\n        }\n    }\n\n    private fun precision(value: Double): Int = when {\n        value < 1 -> 3\n        value < 10 -> 2\n        value < 100 -> 1\n        else -> 0\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return when {\n            abs(number) < 1e14 -> formatToExactDecimals(number, decimals.coerceAtMost(12))\n            else -> formatScientific(number)\n        } + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            val hasHours = hours != 0\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                append(seconds)\n                if (nanoseconds != 0) {\n                    append('.')\n                    val nss = nanoseconds.toString().padStart(9, '0')\n                    when {\n                        nanoseconds % 1_000_000 == 0 -> appendRange(nss, 0, 3)\n                        nanoseconds % 1_000 == 0 -> appendRange(nss, 0, 6)\n                        else -> append(nss)\n                    }\n                }\n                append('S')\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.toLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).toLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\n@ExperimentalTime private fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\n@ExperimentalTime private fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\n@ExperimentalTime private fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\n@ExperimentalTime private fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\n@ExperimentalTime private fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\ninternal expect fun formatScientific(value: Double): String","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Reverses elements in the list in-place.\n */\npublic actual fun <T> MutableList<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.sequences\n\ninternal actual class ConstrainedOnceSequence<T> actual constructor(sequence: Sequence<T>) : Sequence<T> {\n    private var sequenceRef: Sequence<T>? = sequence\n\n    actual override fun iterator(): Iterator<T> {\n        val sequence = sequenceRef ?: throw IllegalStateException(\"This sequence can be consumed only once.\")\n        sequenceRef = null\n        return sequence.iterator()\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is an upper case letter.\n *\n * A character is considered to be an upper case letter if its [category] is [CharCategory.UPPERCASE_LETTER].\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a lower case letter.\n *\n * A character is considered to be a lower case letter if its [category] is [CharCategory.LOWERCASE_LETTER].\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.joinToString(separator = \"\", prefix = \"gu\") { it.value })\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    /** Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? {\n        if (pattern.startsWith('^') && pattern.endsWith('$'))\n            return find(input)\n        else\n            return Regex(\"^${pattern.trimStart('^').trimEnd('$')}$\", options).find(input)\n    }\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String = input.toString().nativeReplace(nativePattern, replacement)\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual inline fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        val nonGlobalOptions = options.map { it.value }.joinToString(separator = \"\")\n        return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n    }\n\n    /**\n     * Splits the [input] CharSequence around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"$$$$\")\n\n        private val patternEscape = RegExp(\"\"\"[\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n/** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_sb3q2\\$\")\npublic fun Regex_0(pattern: String, option: RegexOption): Regex = Regex(pattern, setOf(option))\n\n/** Creates a regular expression from the specified [pattern] string and the default options.  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_61zpoe\\$\")\npublic fun Regex_1(pattern: String): Regex = Regex(pattern, emptySet())\n\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? = this@findNext.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1)\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\npublic fun String.matches(regex: String): Boolean {\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || (if (this is String) this else this.toString()).matches(\"^[\\\\s\\\\xA0]+$\")\n\n@OptIn(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean =\n    when {\n        this == null -> other == null\n        !ignoreCase -> this == other\n        other == null -> false\n        else -> {\n            val thisLower = this.lowercase()\n            val otherLower = other.lowercase()\n            thisLower == otherLower || (thisLower.uppercase() == otherLower.uppercase())\n        }\n    }\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toUpperCase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toLowerCase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.escapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n\nprivate enum class State {\n    Ready,\n    NotReady,\n    Done,\n    Failed\n}\n\n/**\n * A base class to simplify implementing iterators so that implementations only have to implement [computeNext]\n * to implement the iterator, calling [done] when the iteration is complete.\n */\npublic abstract class AbstractIterator<T> : Iterator<T> {\n    private var state = State.NotReady\n    private var nextValue: T? = null\n\n    override fun hasNext(): Boolean {\n        require(state != State.Failed)\n        return when (state) {\n            State.Done -> false\n            State.Ready -> true\n            else -> tryToComputeNext()\n        }\n    }\n\n    override fun next(): T {\n        if (!hasNext()) throw NoSuchElementException()\n        state = State.NotReady\n        @Suppress(\"UNCHECKED_CAST\")\n        return nextValue as T\n    }\n\n    private fun tryToComputeNext(): Boolean {\n        state = State.Failed\n        computeNext()\n        return state == State.Ready\n    }\n\n    /**\n     * Computes the next item in the iterator.\n     *\n     * This callback method should call one of these two methods:\n     *\n     * * [setNext] with the next value of the iteration\n     * * [done] to indicate there are no more elements\n     *\n     * Failure to call either method will result in the iteration terminating with a failed state\n     */\n    abstract protected fun computeNext(): Unit\n\n    /**\n     * Sets the next value in the iteration, called from the [computeNext] function\n     */\n    protected fun setNext(value: T): Unit {\n        nextValue = value\n        state = State.Ready\n    }\n\n    /**\n     * Sets the state to done so that the iteration terminates.\n     */\n    protected fun done() {\n        state = State.Done\n    }\n}\n\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nprivate open class ReversedListReadOnly<out T>(private val delegate: List<T>) : AbstractList<T>() {\n    override val size: Int get() = delegate.size\n    override fun get(index: Int): T = delegate[reverseElementIndex(index)]\n}\n\nprivate class ReversedList<T>(private val delegate: MutableList<T>) : AbstractMutableList<T>() {\n    override val size: Int get() = delegate.size\n    override fun get(index: Int): T = delegate[reverseElementIndex(index)]\n\n    override fun clear() = delegate.clear()\n    override fun removeAt(index: Int): T = delegate.removeAt(reverseElementIndex(index))\n\n    override fun set(index: Int, element: T): T = delegate.set(reverseElementIndex(index), element)\n    override fun add(index: Int, element: T) {\n        delegate.add(reversePositionIndex(index), element)\n    }\n}\n\nprivate fun List<*>.reverseElementIndex(index: Int) =\n    if (index in 0..lastIndex) lastIndex - index else throw IndexOutOfBoundsException(\"Element index $index must be in range [${0..lastIndex}].\")\n\nprivate fun List<*>.reversePositionIndex(index: Int) =\n    if (index in 0..size) size - index else throw IndexOutOfBoundsException(\"Position index $index must be in range [${0..size}].\")\n\n\n/**\n * Returns a reversed read-only view of the original List.\n * All changes made in the original list will be reflected in the reversed one.\n * @sample samples.collections.ReversedViews.asReversedList\n */\npublic fun <T> List<T>.asReversed(): List<T> = ReversedListReadOnly(this)\n\n/**\n * Returns a reversed mutable view of the original mutable List.\n * All changes made in the original list will be reflected in the reversed one and vice versa.\n * @sample samples.collections.ReversedViews.asReversedMutableList\n */\n@kotlin.jvm.JvmName(\"asReversedMutable\")\npublic fun <T> MutableList<T>.asReversed(): MutableList<T> = ReversedList(this)\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun checkWindowSizeStep(size: Int, step: Int) {\n    require(size > 0 && step > 0) {\n        if (size != step)\n            \"Both size $size and step $step must be greater than zero.\"\n        else\n            \"size $size must be greater than zero.\"\n    }\n}\n\ninternal fun <T> Sequence<T>.windowedSequence(size: Int, step: Int, partialWindows: Boolean, reuseBuffer: Boolean): Sequence<List<T>> {\n    checkWindowSizeStep(size, step)\n    return Sequence { windowedIterator(iterator(), size, step, partialWindows, reuseBuffer) }\n}\n\ninternal fun <T> windowedIterator(iterator: Iterator<T>, size: Int, step: Int, partialWindows: Boolean, reuseBuffer: Boolean): Iterator<List<T>> {\n    if (!iterator.hasNext()) return EmptyIterator\n    return iterator<List<T>> {\n        val bufferInitialCapacity = size.coerceAtMost(1024)\n        val gap = step - size\n        if (gap >= 0) {\n            var buffer = ArrayList<T>(bufferInitialCapacity)\n            var skip = 0\n            for (e in iterator) {\n                if (skip > 0) { skip -= 1; continue }\n                buffer.add(e)\n                if (buffer.size == size) {\n                    yield(buffer)\n                    if (reuseBuffer) buffer.clear() else buffer = ArrayList(size)\n                    skip = gap\n                }\n            }\n            if (buffer.isNotEmpty()) {\n                if (partialWindows || buffer.size == size) yield(buffer)\n            }\n        } else {\n            var buffer = RingBuffer<T>(bufferInitialCapacity)\n            for (e in iterator) {\n                buffer.add(e)\n                if (buffer.isFull()) {\n                    if (buffer.size < size) { buffer = buffer.expanded(maxCapacity = size); continue }\n\n                    yield(if (reuseBuffer) buffer else ArrayList(buffer))\n                    buffer.removeFirst(step)\n                }\n            }\n            if (partialWindows) {\n                while (buffer.size > step) {\n                    yield(if (reuseBuffer) buffer else ArrayList(buffer))\n                    buffer.removeFirst(step)\n                }\n                if (buffer.isNotEmpty()) yield(buffer)\n            }\n        }\n    }\n}\n\ninternal class MovingSubList<out E>(private val list: List<E>) : AbstractList<E>(), RandomAccess {\n    private var fromIndex: Int = 0\n    private var _size: Int = 0\n\n    fun move(fromIndex: Int, toIndex: Int) {\n        checkRangeIndexes(fromIndex, toIndex, list.size)\n        this.fromIndex = fromIndex\n        this._size = toIndex - fromIndex\n    }\n\n    override fun get(index: Int): E {\n        checkElementIndex(index, _size)\n\n        return list[fromIndex + index]\n    }\n\n    override val size: Int get() = _size\n}\n\n\n/**\n * Provides ring buffer implementation.\n *\n * Buffer overflow is not allowed so [add] doesn't overwrite tail but raises an exception.\n */\nprivate class RingBuffer<T>(private val buffer: Array<Any?>, filledSize: Int) : AbstractList<T>(), RandomAccess {\n    init {\n        require(filledSize >= 0) { \"ring buffer filled size should not be negative but it is $filledSize\" }\n        require(filledSize <= buffer.size) { \"ring buffer filled size: $filledSize cannot be larger than the buffer size: ${buffer.size}\" }\n    }\n\n    constructor(capacity: Int) : this(arrayOfNulls<Any?>(capacity), 0)\n\n    private val capacity = buffer.size\n    private var startIndex: Int = 0\n\n    override var size: Int = filledSize\n        private set\n\n    override fun get(index: Int): T {\n        checkElementIndex(index, size)\n        @Suppress(\"UNCHECKED_CAST\")\n        return buffer[startIndex.forward(index)] as T\n    }\n\n    fun isFull() = size == capacity\n\n    override fun iterator(): Iterator<T> = object : AbstractIterator<T>() {\n        private var count = size\n        private var index = startIndex\n\n        override fun computeNext() {\n            if (count == 0) {\n                done()\n            } else {\n                @Suppress(\"UNCHECKED_CAST\")\n                setNext(buffer[index] as T)\n                index = index.forward(1)\n                count--\n            }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        val result: Array<T?> =\n            if (array.size < this.size) array.copyOf(this.size) else array as Array<T?>\n\n        val size = this.size\n\n        var widx = 0\n        var idx = startIndex\n\n        while (widx < size && idx < capacity) {\n            result[widx] = buffer[idx] as T\n            widx++\n            idx++\n        }\n\n        idx = 0\n        while (widx < size) {\n            result[widx] = buffer[idx] as T\n            widx++\n            idx++\n        }\n        if (result.size > this.size) result[this.size] = null\n\n        return result as Array<T>\n    }\n\n    override fun toArray(): Array<Any?> {\n        return toArray(arrayOfNulls(size))\n    }\n\n    /**\n     * Creates a new ring buffer with the capacity equal to the minimum of [maxCapacity] and 1.5 * [capacity].\n     * The returned ring buffer contains the same elements as this ring buffer.\n     */\n    fun expanded(maxCapacity: Int): RingBuffer<T> {\n        val newCapacity = (capacity + (capacity shr 1) + 1).coerceAtMost(maxCapacity)\n        val newBuffer = if (startIndex == 0) buffer.copyOf(newCapacity) else toArray(arrayOfNulls(newCapacity))\n        return RingBuffer(newBuffer, size)\n    }\n\n    /**\n     * Add [element] to the buffer or fail with [IllegalStateException] if no free space available in the buffer\n     */\n    fun add(element: T) {\n        if (isFull()) {\n            throw IllegalStateException(\"ring buffer is full\")\n        }\n\n        buffer[startIndex.forward(size)] = element\n        size++\n    }\n\n    /**\n     * Removes [n] first elements from the buffer or fails with [IllegalArgumentException] if not enough elements in the buffer to remove\n     */\n    fun removeFirst(n: Int) {\n        require(n >= 0) { \"n shouldn't be negative but it is $n\" }\n        require(n <= size) { \"n shouldn't be greater than the buffer size: n = $n, size = $size\" }\n\n        if (n > 0) {\n            val start = startIndex\n            val end = start.forward(n)\n\n            if (start > end) {\n                buffer.fill(null, start, capacity)\n                buffer.fill(null, 0, end)\n            } else {\n                buffer.fill(null, start, end)\n            }\n\n            startIndex = end\n            size -= n\n        }\n    }\n\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int.forward(n: Int): Int = (this + n) % capacity\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [uppercaseChar] to each character produces the same result\n *   - Applying the method [lowercaseChar] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is an upper case letter.\n *\n * A character is considered to be an upper case letter if its [category] is [CharCategory.UPPERCASE_LETTER].\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is a lower case letter.\n *\n * A character is considered to be a lower case letter if its [category] is [CharCategory.LOWERCASE_LETTER].\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 — of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] — of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"KClasses\")\n@file:Suppress(\"UNCHECKED_CAST\")\n\npackage kotlin.reflect\n\nimport kotlin.internal.LowPriorityInOverloadResolution\n\n/**\n * Casts the given [value] to the class represented by this [KClass] object.\n * Throws an exception if the value is `null` or if it is not an instance of this class.\n *\n * This is an experimental function that behaves as a similar function from kotlin.reflect.full on JVM.\n *\n * @see [KClass.isInstance]\n * @see [KClass.safeCast]\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@LowPriorityInOverloadResolution\nfun <T : Any> KClass<T>.cast(value: Any?): T {\n    if (!isInstance(value)) throw ClassCastException(\"Value cannot be cast to $qualifiedOrSimpleName\")\n    return value as T\n}\n\n// TODO: replace with qualifiedName when it is fully supported in K/JS\ninternal expect val KClass<*>.qualifiedOrSimpleName: String?\n\n/**\n * Casts the given [value] to the class represented by this [KClass] object.\n * Returns `null` if the value is `null` or if it is not an instance of this class.\n *\n * This is an experimental function that behaves as a similar function from kotlin.reflect.full on JVM.\n *\n * @see [KClass.isInstance]\n * @see [KClass.cast]\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@LowPriorityInOverloadResolution\nfun <T : Any> KClass<T>.safeCast(value: Any?): T? {\n    return if (isInstance(value)) value as T else null\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}",null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n",null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the map was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n",null,null,null,null,null,null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3796);\n"],"sourceRoot":""}